
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model QuestionPaper
 * 
 */
export type QuestionPaper = $Result.DefaultSelection<Prisma.$QuestionPaperPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Grading
 * 
 */
export type Grading = $Result.DefaultSelection<Prisma.$GradingPayload>
/**
 * Model GradingPage
 * 
 */
export type GradingPage = $Result.DefaultSelection<Prisma.$GradingPagePayload>
/**
 * Model PageAnswer
 * 
 */
export type PageAnswer = $Result.DefaultSelection<Prisma.$PageAnswerPayload>
/**
 * Model Answer
 * 
 */
export type Answer = $Result.DefaultSelection<Prisma.$AnswerPayload>
/**
 * Model Doubt
 * 
 */
export type Doubt = $Result.DefaultSelection<Prisma.$DoubtPayload>
/**
 * Model DoubtMessage
 * 
 */
export type DoubtMessage = $Result.DefaultSelection<Prisma.$DoubtMessagePayload>
/**
 * Model Worksheet
 * 
 */
export type Worksheet = $Result.DefaultSelection<Prisma.$WorksheetPayload>
/**
 * Model WorksheetQuestion
 * 
 */
export type WorksheetQuestion = $Result.DefaultSelection<Prisma.$WorksheetQuestionPayload>
/**
 * Model DoubtRating
 * 
 */
export type DoubtRating = $Result.DefaultSelection<Prisma.$DoubtRatingPayload>
/**
 * Model RevisionSession
 * 
 */
export type RevisionSession = $Result.DefaultSelection<Prisma.$RevisionSessionPayload>
/**
 * Model WeakTopic
 * 
 */
export type WeakTopic = $Result.DefaultSelection<Prisma.$WeakTopicPayload>
/**
 * Model GroupStudySession
 * 
 */
export type GroupStudySession = $Result.DefaultSelection<Prisma.$GroupStudySessionPayload>
/**
 * Model HandlingSkillProgress
 * 
 */
export type HandlingSkillProgress = $Result.DefaultSelection<Prisma.$HandlingSkillProgressPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more QuestionPapers
 * const questionPapers = await prisma.questionPaper.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more QuestionPapers
   * const questionPapers = await prisma.questionPaper.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.questionPaper`: Exposes CRUD operations for the **QuestionPaper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionPapers
    * const questionPapers = await prisma.questionPaper.findMany()
    * ```
    */
  get questionPaper(): Prisma.QuestionPaperDelegate<ExtArgs>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.grading`: Exposes CRUD operations for the **Grading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gradings
    * const gradings = await prisma.grading.findMany()
    * ```
    */
  get grading(): Prisma.GradingDelegate<ExtArgs>;

  /**
   * `prisma.gradingPage`: Exposes CRUD operations for the **GradingPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GradingPages
    * const gradingPages = await prisma.gradingPage.findMany()
    * ```
    */
  get gradingPage(): Prisma.GradingPageDelegate<ExtArgs>;

  /**
   * `prisma.pageAnswer`: Exposes CRUD operations for the **PageAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageAnswers
    * const pageAnswers = await prisma.pageAnswer.findMany()
    * ```
    */
  get pageAnswer(): Prisma.PageAnswerDelegate<ExtArgs>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<ExtArgs>;

  /**
   * `prisma.doubt`: Exposes CRUD operations for the **Doubt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doubts
    * const doubts = await prisma.doubt.findMany()
    * ```
    */
  get doubt(): Prisma.DoubtDelegate<ExtArgs>;

  /**
   * `prisma.doubtMessage`: Exposes CRUD operations for the **DoubtMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoubtMessages
    * const doubtMessages = await prisma.doubtMessage.findMany()
    * ```
    */
  get doubtMessage(): Prisma.DoubtMessageDelegate<ExtArgs>;

  /**
   * `prisma.worksheet`: Exposes CRUD operations for the **Worksheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Worksheets
    * const worksheets = await prisma.worksheet.findMany()
    * ```
    */
  get worksheet(): Prisma.WorksheetDelegate<ExtArgs>;

  /**
   * `prisma.worksheetQuestion`: Exposes CRUD operations for the **WorksheetQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorksheetQuestions
    * const worksheetQuestions = await prisma.worksheetQuestion.findMany()
    * ```
    */
  get worksheetQuestion(): Prisma.WorksheetQuestionDelegate<ExtArgs>;

  /**
   * `prisma.doubtRating`: Exposes CRUD operations for the **DoubtRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoubtRatings
    * const doubtRatings = await prisma.doubtRating.findMany()
    * ```
    */
  get doubtRating(): Prisma.DoubtRatingDelegate<ExtArgs>;

  /**
   * `prisma.revisionSession`: Exposes CRUD operations for the **RevisionSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevisionSessions
    * const revisionSessions = await prisma.revisionSession.findMany()
    * ```
    */
  get revisionSession(): Prisma.RevisionSessionDelegate<ExtArgs>;

  /**
   * `prisma.weakTopic`: Exposes CRUD operations for the **WeakTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeakTopics
    * const weakTopics = await prisma.weakTopic.findMany()
    * ```
    */
  get weakTopic(): Prisma.WeakTopicDelegate<ExtArgs>;

  /**
   * `prisma.groupStudySession`: Exposes CRUD operations for the **GroupStudySession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupStudySessions
    * const groupStudySessions = await prisma.groupStudySession.findMany()
    * ```
    */
  get groupStudySession(): Prisma.GroupStudySessionDelegate<ExtArgs>;

  /**
   * `prisma.handlingSkillProgress`: Exposes CRUD operations for the **HandlingSkillProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HandlingSkillProgresses
    * const handlingSkillProgresses = await prisma.handlingSkillProgress.findMany()
    * ```
    */
  get handlingSkillProgress(): Prisma.HandlingSkillProgressDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    QuestionPaper: 'QuestionPaper',
    Question: 'Question',
    User: 'User',
    Grading: 'Grading',
    GradingPage: 'GradingPage',
    PageAnswer: 'PageAnswer',
    Answer: 'Answer',
    Doubt: 'Doubt',
    DoubtMessage: 'DoubtMessage',
    Worksheet: 'Worksheet',
    WorksheetQuestion: 'WorksheetQuestion',
    DoubtRating: 'DoubtRating',
    RevisionSession: 'RevisionSession',
    WeakTopic: 'WeakTopic',
    GroupStudySession: 'GroupStudySession',
    HandlingSkillProgress: 'HandlingSkillProgress'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "questionPaper" | "question" | "user" | "grading" | "gradingPage" | "pageAnswer" | "answer" | "doubt" | "doubtMessage" | "worksheet" | "worksheetQuestion" | "doubtRating" | "revisionSession" | "weakTopic" | "groupStudySession" | "handlingSkillProgress"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      QuestionPaper: {
        payload: Prisma.$QuestionPaperPayload<ExtArgs>
        fields: Prisma.QuestionPaperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionPaperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionPaperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>
          }
          findFirst: {
            args: Prisma.QuestionPaperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionPaperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>
          }
          findMany: {
            args: Prisma.QuestionPaperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>[]
          }
          create: {
            args: Prisma.QuestionPaperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>
          }
          createMany: {
            args: Prisma.QuestionPaperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionPaperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>[]
          }
          delete: {
            args: Prisma.QuestionPaperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>
          }
          update: {
            args: Prisma.QuestionPaperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>
          }
          deleteMany: {
            args: Prisma.QuestionPaperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionPaperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionPaperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPaperPayload>
          }
          aggregate: {
            args: Prisma.QuestionPaperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionPaper>
          }
          groupBy: {
            args: Prisma.QuestionPaperGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionPaperGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionPaperCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionPaperCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Grading: {
        payload: Prisma.$GradingPayload<ExtArgs>
        fields: Prisma.GradingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>
          }
          findFirst: {
            args: Prisma.GradingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>
          }
          findMany: {
            args: Prisma.GradingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>[]
          }
          create: {
            args: Prisma.GradingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>
          }
          createMany: {
            args: Prisma.GradingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>[]
          }
          delete: {
            args: Prisma.GradingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>
          }
          update: {
            args: Prisma.GradingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>
          }
          deleteMany: {
            args: Prisma.GradingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GradingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>
          }
          aggregate: {
            args: Prisma.GradingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrading>
          }
          groupBy: {
            args: Prisma.GradingGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradingGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradingCountArgs<ExtArgs>
            result: $Utils.Optional<GradingCountAggregateOutputType> | number
          }
        }
      }
      GradingPage: {
        payload: Prisma.$GradingPagePayload<ExtArgs>
        fields: Prisma.GradingPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradingPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradingPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>
          }
          findFirst: {
            args: Prisma.GradingPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradingPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>
          }
          findMany: {
            args: Prisma.GradingPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>[]
          }
          create: {
            args: Prisma.GradingPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>
          }
          createMany: {
            args: Prisma.GradingPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradingPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>[]
          }
          delete: {
            args: Prisma.GradingPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>
          }
          update: {
            args: Prisma.GradingPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>
          }
          deleteMany: {
            args: Prisma.GradingPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradingPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GradingPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradingPagePayload>
          }
          aggregate: {
            args: Prisma.GradingPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradingPage>
          }
          groupBy: {
            args: Prisma.GradingPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradingPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradingPageCountArgs<ExtArgs>
            result: $Utils.Optional<GradingPageCountAggregateOutputType> | number
          }
        }
      }
      PageAnswer: {
        payload: Prisma.$PageAnswerPayload<ExtArgs>
        fields: Prisma.PageAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>
          }
          findFirst: {
            args: Prisma.PageAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>
          }
          findMany: {
            args: Prisma.PageAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>[]
          }
          create: {
            args: Prisma.PageAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>
          }
          createMany: {
            args: Prisma.PageAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>[]
          }
          delete: {
            args: Prisma.PageAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>
          }
          update: {
            args: Prisma.PageAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>
          }
          deleteMany: {
            args: Prisma.PageAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PageAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageAnswerPayload>
          }
          aggregate: {
            args: Prisma.PageAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageAnswer>
          }
          groupBy: {
            args: Prisma.PageAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<PageAnswerCountAggregateOutputType> | number
          }
        }
      }
      Answer: {
        payload: Prisma.$AnswerPayload<ExtArgs>
        fields: Prisma.AnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findFirst: {
            args: Prisma.AnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findMany: {
            args: Prisma.AnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          create: {
            args: Prisma.AnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          createMany: {
            args: Prisma.AnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          delete: {
            args: Prisma.AnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          update: {
            args: Prisma.AnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          deleteMany: {
            args: Prisma.AnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          aggregate: {
            args: Prisma.AnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswer>
          }
          groupBy: {
            args: Prisma.AnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswerCountArgs<ExtArgs>
            result: $Utils.Optional<AnswerCountAggregateOutputType> | number
          }
        }
      }
      Doubt: {
        payload: Prisma.$DoubtPayload<ExtArgs>
        fields: Prisma.DoubtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoubtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoubtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>
          }
          findFirst: {
            args: Prisma.DoubtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoubtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>
          }
          findMany: {
            args: Prisma.DoubtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>[]
          }
          create: {
            args: Prisma.DoubtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>
          }
          createMany: {
            args: Prisma.DoubtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoubtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>[]
          }
          delete: {
            args: Prisma.DoubtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>
          }
          update: {
            args: Prisma.DoubtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>
          }
          deleteMany: {
            args: Prisma.DoubtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoubtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoubtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtPayload>
          }
          aggregate: {
            args: Prisma.DoubtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoubt>
          }
          groupBy: {
            args: Prisma.DoubtGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoubtGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoubtCountArgs<ExtArgs>
            result: $Utils.Optional<DoubtCountAggregateOutputType> | number
          }
        }
      }
      DoubtMessage: {
        payload: Prisma.$DoubtMessagePayload<ExtArgs>
        fields: Prisma.DoubtMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoubtMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoubtMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>
          }
          findFirst: {
            args: Prisma.DoubtMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoubtMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>
          }
          findMany: {
            args: Prisma.DoubtMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>[]
          }
          create: {
            args: Prisma.DoubtMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>
          }
          createMany: {
            args: Prisma.DoubtMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoubtMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>[]
          }
          delete: {
            args: Prisma.DoubtMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>
          }
          update: {
            args: Prisma.DoubtMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>
          }
          deleteMany: {
            args: Prisma.DoubtMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoubtMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoubtMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtMessagePayload>
          }
          aggregate: {
            args: Prisma.DoubtMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoubtMessage>
          }
          groupBy: {
            args: Prisma.DoubtMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoubtMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoubtMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DoubtMessageCountAggregateOutputType> | number
          }
        }
      }
      Worksheet: {
        payload: Prisma.$WorksheetPayload<ExtArgs>
        fields: Prisma.WorksheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorksheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorksheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>
          }
          findFirst: {
            args: Prisma.WorksheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorksheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>
          }
          findMany: {
            args: Prisma.WorksheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>[]
          }
          create: {
            args: Prisma.WorksheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>
          }
          createMany: {
            args: Prisma.WorksheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorksheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>[]
          }
          delete: {
            args: Prisma.WorksheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>
          }
          update: {
            args: Prisma.WorksheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>
          }
          deleteMany: {
            args: Prisma.WorksheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorksheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorksheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetPayload>
          }
          aggregate: {
            args: Prisma.WorksheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorksheet>
          }
          groupBy: {
            args: Prisma.WorksheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorksheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorksheetCountArgs<ExtArgs>
            result: $Utils.Optional<WorksheetCountAggregateOutputType> | number
          }
        }
      }
      WorksheetQuestion: {
        payload: Prisma.$WorksheetQuestionPayload<ExtArgs>
        fields: Prisma.WorksheetQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorksheetQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorksheetQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>
          }
          findFirst: {
            args: Prisma.WorksheetQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorksheetQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>
          }
          findMany: {
            args: Prisma.WorksheetQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>[]
          }
          create: {
            args: Prisma.WorksheetQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>
          }
          createMany: {
            args: Prisma.WorksheetQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorksheetQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>[]
          }
          delete: {
            args: Prisma.WorksheetQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>
          }
          update: {
            args: Prisma.WorksheetQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>
          }
          deleteMany: {
            args: Prisma.WorksheetQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorksheetQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorksheetQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorksheetQuestionPayload>
          }
          aggregate: {
            args: Prisma.WorksheetQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorksheetQuestion>
          }
          groupBy: {
            args: Prisma.WorksheetQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorksheetQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorksheetQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<WorksheetQuestionCountAggregateOutputType> | number
          }
        }
      }
      DoubtRating: {
        payload: Prisma.$DoubtRatingPayload<ExtArgs>
        fields: Prisma.DoubtRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoubtRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoubtRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>
          }
          findFirst: {
            args: Prisma.DoubtRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoubtRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>
          }
          findMany: {
            args: Prisma.DoubtRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>[]
          }
          create: {
            args: Prisma.DoubtRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>
          }
          createMany: {
            args: Prisma.DoubtRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoubtRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>[]
          }
          delete: {
            args: Prisma.DoubtRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>
          }
          update: {
            args: Prisma.DoubtRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>
          }
          deleteMany: {
            args: Prisma.DoubtRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoubtRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoubtRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoubtRatingPayload>
          }
          aggregate: {
            args: Prisma.DoubtRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoubtRating>
          }
          groupBy: {
            args: Prisma.DoubtRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoubtRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoubtRatingCountArgs<ExtArgs>
            result: $Utils.Optional<DoubtRatingCountAggregateOutputType> | number
          }
        }
      }
      RevisionSession: {
        payload: Prisma.$RevisionSessionPayload<ExtArgs>
        fields: Prisma.RevisionSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevisionSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevisionSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>
          }
          findFirst: {
            args: Prisma.RevisionSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevisionSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>
          }
          findMany: {
            args: Prisma.RevisionSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>[]
          }
          create: {
            args: Prisma.RevisionSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>
          }
          createMany: {
            args: Prisma.RevisionSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevisionSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>[]
          }
          delete: {
            args: Prisma.RevisionSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>
          }
          update: {
            args: Prisma.RevisionSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>
          }
          deleteMany: {
            args: Prisma.RevisionSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevisionSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevisionSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionSessionPayload>
          }
          aggregate: {
            args: Prisma.RevisionSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevisionSession>
          }
          groupBy: {
            args: Prisma.RevisionSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevisionSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevisionSessionCountArgs<ExtArgs>
            result: $Utils.Optional<RevisionSessionCountAggregateOutputType> | number
          }
        }
      }
      WeakTopic: {
        payload: Prisma.$WeakTopicPayload<ExtArgs>
        fields: Prisma.WeakTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeakTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeakTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>
          }
          findFirst: {
            args: Prisma.WeakTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeakTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>
          }
          findMany: {
            args: Prisma.WeakTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>[]
          }
          create: {
            args: Prisma.WeakTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>
          }
          createMany: {
            args: Prisma.WeakTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeakTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>[]
          }
          delete: {
            args: Prisma.WeakTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>
          }
          update: {
            args: Prisma.WeakTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>
          }
          deleteMany: {
            args: Prisma.WeakTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeakTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeakTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeakTopicPayload>
          }
          aggregate: {
            args: Prisma.WeakTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeakTopic>
          }
          groupBy: {
            args: Prisma.WeakTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeakTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeakTopicCountArgs<ExtArgs>
            result: $Utils.Optional<WeakTopicCountAggregateOutputType> | number
          }
        }
      }
      GroupStudySession: {
        payload: Prisma.$GroupStudySessionPayload<ExtArgs>
        fields: Prisma.GroupStudySessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupStudySessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupStudySessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>
          }
          findFirst: {
            args: Prisma.GroupStudySessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupStudySessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>
          }
          findMany: {
            args: Prisma.GroupStudySessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>[]
          }
          create: {
            args: Prisma.GroupStudySessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>
          }
          createMany: {
            args: Prisma.GroupStudySessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupStudySessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>[]
          }
          delete: {
            args: Prisma.GroupStudySessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>
          }
          update: {
            args: Prisma.GroupStudySessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>
          }
          deleteMany: {
            args: Prisma.GroupStudySessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupStudySessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupStudySessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupStudySessionPayload>
          }
          aggregate: {
            args: Prisma.GroupStudySessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupStudySession>
          }
          groupBy: {
            args: Prisma.GroupStudySessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupStudySessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupStudySessionCountArgs<ExtArgs>
            result: $Utils.Optional<GroupStudySessionCountAggregateOutputType> | number
          }
        }
      }
      HandlingSkillProgress: {
        payload: Prisma.$HandlingSkillProgressPayload<ExtArgs>
        fields: Prisma.HandlingSkillProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HandlingSkillProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HandlingSkillProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>
          }
          findFirst: {
            args: Prisma.HandlingSkillProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HandlingSkillProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>
          }
          findMany: {
            args: Prisma.HandlingSkillProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>[]
          }
          create: {
            args: Prisma.HandlingSkillProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>
          }
          createMany: {
            args: Prisma.HandlingSkillProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HandlingSkillProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>[]
          }
          delete: {
            args: Prisma.HandlingSkillProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>
          }
          update: {
            args: Prisma.HandlingSkillProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>
          }
          deleteMany: {
            args: Prisma.HandlingSkillProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HandlingSkillProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HandlingSkillProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandlingSkillProgressPayload>
          }
          aggregate: {
            args: Prisma.HandlingSkillProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHandlingSkillProgress>
          }
          groupBy: {
            args: Prisma.HandlingSkillProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<HandlingSkillProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.HandlingSkillProgressCountArgs<ExtArgs>
            result: $Utils.Optional<HandlingSkillProgressCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type QuestionPaperCountOutputType
   */

  export type QuestionPaperCountOutputType = {
    questions: number
    gradings: number
  }

  export type QuestionPaperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionPaperCountOutputTypeCountQuestionsArgs
    gradings?: boolean | QuestionPaperCountOutputTypeCountGradingsArgs
  }

  // Custom InputTypes
  /**
   * QuestionPaperCountOutputType without action
   */
  export type QuestionPaperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaperCountOutputType
     */
    select?: QuestionPaperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionPaperCountOutputType without action
   */
  export type QuestionPaperCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * QuestionPaperCountOutputType without action
   */
  export type QuestionPaperCountOutputTypeCountGradingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradingWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    gradings: number
    doubts: number
    worksheets: number
    doubtRatings: number
    revisionSessions: number
    weakTopics: number
    groupStudySessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gradings?: boolean | UserCountOutputTypeCountGradingsArgs
    doubts?: boolean | UserCountOutputTypeCountDoubtsArgs
    worksheets?: boolean | UserCountOutputTypeCountWorksheetsArgs
    doubtRatings?: boolean | UserCountOutputTypeCountDoubtRatingsArgs
    revisionSessions?: boolean | UserCountOutputTypeCountRevisionSessionsArgs
    weakTopics?: boolean | UserCountOutputTypeCountWeakTopicsArgs
    groupStudySessions?: boolean | UserCountOutputTypeCountGroupStudySessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGradingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoubtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoubtWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorksheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorksheetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoubtRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoubtRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRevisionSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevisionSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWeakTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeakTopicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupStudySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupStudySessionWhereInput
  }


  /**
   * Count Type GradingCountOutputType
   */

  export type GradingCountOutputType = {
    pages: number
    answers: number
  }

  export type GradingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | GradingCountOutputTypeCountPagesArgs
    answers?: boolean | GradingCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * GradingCountOutputType without action
   */
  export type GradingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingCountOutputType
     */
    select?: GradingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradingCountOutputType without action
   */
  export type GradingCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradingPageWhereInput
  }

  /**
   * GradingCountOutputType without action
   */
  export type GradingCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }


  /**
   * Count Type GradingPageCountOutputType
   */

  export type GradingPageCountOutputType = {
    pageAnswers: number
  }

  export type GradingPageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pageAnswers?: boolean | GradingPageCountOutputTypeCountPageAnswersArgs
  }

  // Custom InputTypes
  /**
   * GradingPageCountOutputType without action
   */
  export type GradingPageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPageCountOutputType
     */
    select?: GradingPageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradingPageCountOutputType without action
   */
  export type GradingPageCountOutputTypeCountPageAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageAnswerWhereInput
  }


  /**
   * Count Type DoubtCountOutputType
   */

  export type DoubtCountOutputType = {
    messages: number
    worksheetQuestions: number
  }

  export type DoubtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | DoubtCountOutputTypeCountMessagesArgs
    worksheetQuestions?: boolean | DoubtCountOutputTypeCountWorksheetQuestionsArgs
  }

  // Custom InputTypes
  /**
   * DoubtCountOutputType without action
   */
  export type DoubtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtCountOutputType
     */
    select?: DoubtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoubtCountOutputType without action
   */
  export type DoubtCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoubtMessageWhereInput
  }

  /**
   * DoubtCountOutputType without action
   */
  export type DoubtCountOutputTypeCountWorksheetQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorksheetQuestionWhereInput
  }


  /**
   * Count Type WorksheetCountOutputType
   */

  export type WorksheetCountOutputType = {
    questions: number
    doubts: number
  }

  export type WorksheetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | WorksheetCountOutputTypeCountQuestionsArgs
    doubts?: boolean | WorksheetCountOutputTypeCountDoubtsArgs
  }

  // Custom InputTypes
  /**
   * WorksheetCountOutputType without action
   */
  export type WorksheetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetCountOutputType
     */
    select?: WorksheetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorksheetCountOutputType without action
   */
  export type WorksheetCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorksheetQuestionWhereInput
  }

  /**
   * WorksheetCountOutputType without action
   */
  export type WorksheetCountOutputTypeCountDoubtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoubtWhereInput
  }


  /**
   * Models
   */

  /**
   * Model QuestionPaper
   */

  export type AggregateQuestionPaper = {
    _count: QuestionPaperCountAggregateOutputType | null
    _avg: QuestionPaperAvgAggregateOutputType | null
    _sum: QuestionPaperSumAggregateOutputType | null
    _min: QuestionPaperMinAggregateOutputType | null
    _max: QuestionPaperMaxAggregateOutputType | null
  }

  export type QuestionPaperAvgAggregateOutputType = {
    totalQuestions: number | null
    usageCount: number | null
  }

  export type QuestionPaperSumAggregateOutputType = {
    totalQuestions: number | null
    usageCount: number | null
  }

  export type QuestionPaperMinAggregateOutputType = {
    id: string | null
    title: string | null
    subject: string | null
    gradeLevel: string | null
    language: string | null
    imageUrl: string | null
    imageHash: string | null
    totalQuestions: number | null
    createdAt: Date | null
    updatedAt: Date | null
    usageCount: number | null
  }

  export type QuestionPaperMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subject: string | null
    gradeLevel: string | null
    language: string | null
    imageUrl: string | null
    imageHash: string | null
    totalQuestions: number | null
    createdAt: Date | null
    updatedAt: Date | null
    usageCount: number | null
  }

  export type QuestionPaperCountAggregateOutputType = {
    id: number
    title: number
    subject: number
    gradeLevel: number
    language: number
    imageUrl: number
    imageHash: number
    totalQuestions: number
    createdAt: number
    updatedAt: number
    usageCount: number
    _all: number
  }


  export type QuestionPaperAvgAggregateInputType = {
    totalQuestions?: true
    usageCount?: true
  }

  export type QuestionPaperSumAggregateInputType = {
    totalQuestions?: true
    usageCount?: true
  }

  export type QuestionPaperMinAggregateInputType = {
    id?: true
    title?: true
    subject?: true
    gradeLevel?: true
    language?: true
    imageUrl?: true
    imageHash?: true
    totalQuestions?: true
    createdAt?: true
    updatedAt?: true
    usageCount?: true
  }

  export type QuestionPaperMaxAggregateInputType = {
    id?: true
    title?: true
    subject?: true
    gradeLevel?: true
    language?: true
    imageUrl?: true
    imageHash?: true
    totalQuestions?: true
    createdAt?: true
    updatedAt?: true
    usageCount?: true
  }

  export type QuestionPaperCountAggregateInputType = {
    id?: true
    title?: true
    subject?: true
    gradeLevel?: true
    language?: true
    imageUrl?: true
    imageHash?: true
    totalQuestions?: true
    createdAt?: true
    updatedAt?: true
    usageCount?: true
    _all?: true
  }

  export type QuestionPaperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionPaper to aggregate.
     */
    where?: QuestionPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPapers to fetch.
     */
    orderBy?: QuestionPaperOrderByWithRelationInput | QuestionPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionPapers
    **/
    _count?: true | QuestionPaperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionPaperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionPaperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionPaperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionPaperMaxAggregateInputType
  }

  export type GetQuestionPaperAggregateType<T extends QuestionPaperAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionPaper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionPaper[P]>
      : GetScalarType<T[P], AggregateQuestionPaper[P]>
  }




  export type QuestionPaperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionPaperWhereInput
    orderBy?: QuestionPaperOrderByWithAggregationInput | QuestionPaperOrderByWithAggregationInput[]
    by: QuestionPaperScalarFieldEnum[] | QuestionPaperScalarFieldEnum
    having?: QuestionPaperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionPaperCountAggregateInputType | true
    _avg?: QuestionPaperAvgAggregateInputType
    _sum?: QuestionPaperSumAggregateInputType
    _min?: QuestionPaperMinAggregateInputType
    _max?: QuestionPaperMaxAggregateInputType
  }

  export type QuestionPaperGroupByOutputType = {
    id: string
    title: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt: Date
    updatedAt: Date
    usageCount: number
    _count: QuestionPaperCountAggregateOutputType | null
    _avg: QuestionPaperAvgAggregateOutputType | null
    _sum: QuestionPaperSumAggregateOutputType | null
    _min: QuestionPaperMinAggregateOutputType | null
    _max: QuestionPaperMaxAggregateOutputType | null
  }

  type GetQuestionPaperGroupByPayload<T extends QuestionPaperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionPaperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionPaperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionPaperGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionPaperGroupByOutputType[P]>
        }
      >
    >


  export type QuestionPaperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subject?: boolean
    gradeLevel?: boolean
    language?: boolean
    imageUrl?: boolean
    imageHash?: boolean
    totalQuestions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usageCount?: boolean
    questions?: boolean | QuestionPaper$questionsArgs<ExtArgs>
    gradings?: boolean | QuestionPaper$gradingsArgs<ExtArgs>
    _count?: boolean | QuestionPaperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionPaper"]>

  export type QuestionPaperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subject?: boolean
    gradeLevel?: boolean
    language?: boolean
    imageUrl?: boolean
    imageHash?: boolean
    totalQuestions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usageCount?: boolean
  }, ExtArgs["result"]["questionPaper"]>

  export type QuestionPaperSelectScalar = {
    id?: boolean
    title?: boolean
    subject?: boolean
    gradeLevel?: boolean
    language?: boolean
    imageUrl?: boolean
    imageHash?: boolean
    totalQuestions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usageCount?: boolean
  }

  export type QuestionPaperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionPaper$questionsArgs<ExtArgs>
    gradings?: boolean | QuestionPaper$gradingsArgs<ExtArgs>
    _count?: boolean | QuestionPaperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionPaperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuestionPaperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionPaper"
    objects: {
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      gradings: Prisma.$GradingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      subject: string
      gradeLevel: string
      language: string
      imageUrl: string
      imageHash: string
      totalQuestions: number
      createdAt: Date
      updatedAt: Date
      usageCount: number
    }, ExtArgs["result"]["questionPaper"]>
    composites: {}
  }

  type QuestionPaperGetPayload<S extends boolean | null | undefined | QuestionPaperDefaultArgs> = $Result.GetResult<Prisma.$QuestionPaperPayload, S>

  type QuestionPaperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionPaperFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionPaperCountAggregateInputType | true
    }

  export interface QuestionPaperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionPaper'], meta: { name: 'QuestionPaper' } }
    /**
     * Find zero or one QuestionPaper that matches the filter.
     * @param {QuestionPaperFindUniqueArgs} args - Arguments to find a QuestionPaper
     * @example
     * // Get one QuestionPaper
     * const questionPaper = await prisma.questionPaper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionPaperFindUniqueArgs>(args: SelectSubset<T, QuestionPaperFindUniqueArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionPaper that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionPaperFindUniqueOrThrowArgs} args - Arguments to find a QuestionPaper
     * @example
     * // Get one QuestionPaper
     * const questionPaper = await prisma.questionPaper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionPaperFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionPaperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionPaper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPaperFindFirstArgs} args - Arguments to find a QuestionPaper
     * @example
     * // Get one QuestionPaper
     * const questionPaper = await prisma.questionPaper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionPaperFindFirstArgs>(args?: SelectSubset<T, QuestionPaperFindFirstArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionPaper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPaperFindFirstOrThrowArgs} args - Arguments to find a QuestionPaper
     * @example
     * // Get one QuestionPaper
     * const questionPaper = await prisma.questionPaper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionPaperFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionPaperFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionPapers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPaperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionPapers
     * const questionPapers = await prisma.questionPaper.findMany()
     * 
     * // Get first 10 QuestionPapers
     * const questionPapers = await prisma.questionPaper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionPaperWithIdOnly = await prisma.questionPaper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionPaperFindManyArgs>(args?: SelectSubset<T, QuestionPaperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionPaper.
     * @param {QuestionPaperCreateArgs} args - Arguments to create a QuestionPaper.
     * @example
     * // Create one QuestionPaper
     * const QuestionPaper = await prisma.questionPaper.create({
     *   data: {
     *     // ... data to create a QuestionPaper
     *   }
     * })
     * 
     */
    create<T extends QuestionPaperCreateArgs>(args: SelectSubset<T, QuestionPaperCreateArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionPapers.
     * @param {QuestionPaperCreateManyArgs} args - Arguments to create many QuestionPapers.
     * @example
     * // Create many QuestionPapers
     * const questionPaper = await prisma.questionPaper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionPaperCreateManyArgs>(args?: SelectSubset<T, QuestionPaperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionPapers and returns the data saved in the database.
     * @param {QuestionPaperCreateManyAndReturnArgs} args - Arguments to create many QuestionPapers.
     * @example
     * // Create many QuestionPapers
     * const questionPaper = await prisma.questionPaper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionPapers and only return the `id`
     * const questionPaperWithIdOnly = await prisma.questionPaper.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionPaperCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionPaperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionPaper.
     * @param {QuestionPaperDeleteArgs} args - Arguments to delete one QuestionPaper.
     * @example
     * // Delete one QuestionPaper
     * const QuestionPaper = await prisma.questionPaper.delete({
     *   where: {
     *     // ... filter to delete one QuestionPaper
     *   }
     * })
     * 
     */
    delete<T extends QuestionPaperDeleteArgs>(args: SelectSubset<T, QuestionPaperDeleteArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionPaper.
     * @param {QuestionPaperUpdateArgs} args - Arguments to update one QuestionPaper.
     * @example
     * // Update one QuestionPaper
     * const questionPaper = await prisma.questionPaper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionPaperUpdateArgs>(args: SelectSubset<T, QuestionPaperUpdateArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionPapers.
     * @param {QuestionPaperDeleteManyArgs} args - Arguments to filter QuestionPapers to delete.
     * @example
     * // Delete a few QuestionPapers
     * const { count } = await prisma.questionPaper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionPaperDeleteManyArgs>(args?: SelectSubset<T, QuestionPaperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionPapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPaperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionPapers
     * const questionPaper = await prisma.questionPaper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionPaperUpdateManyArgs>(args: SelectSubset<T, QuestionPaperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionPaper.
     * @param {QuestionPaperUpsertArgs} args - Arguments to update or create a QuestionPaper.
     * @example
     * // Update or create a QuestionPaper
     * const questionPaper = await prisma.questionPaper.upsert({
     *   create: {
     *     // ... data to create a QuestionPaper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionPaper we want to update
     *   }
     * })
     */
    upsert<T extends QuestionPaperUpsertArgs>(args: SelectSubset<T, QuestionPaperUpsertArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionPapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPaperCountArgs} args - Arguments to filter QuestionPapers to count.
     * @example
     * // Count the number of QuestionPapers
     * const count = await prisma.questionPaper.count({
     *   where: {
     *     // ... the filter for the QuestionPapers we want to count
     *   }
     * })
    **/
    count<T extends QuestionPaperCountArgs>(
      args?: Subset<T, QuestionPaperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionPaperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionPaper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPaperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionPaperAggregateArgs>(args: Subset<T, QuestionPaperAggregateArgs>): Prisma.PrismaPromise<GetQuestionPaperAggregateType<T>>

    /**
     * Group by QuestionPaper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPaperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionPaperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionPaperGroupByArgs['orderBy'] }
        : { orderBy?: QuestionPaperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionPaperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionPaperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionPaper model
   */
  readonly fields: QuestionPaperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionPaper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionPaperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends QuestionPaper$questionsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionPaper$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany"> | Null>
    gradings<T extends QuestionPaper$gradingsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionPaper$gradingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionPaper model
   */ 
  interface QuestionPaperFieldRefs {
    readonly id: FieldRef<"QuestionPaper", 'String'>
    readonly title: FieldRef<"QuestionPaper", 'String'>
    readonly subject: FieldRef<"QuestionPaper", 'String'>
    readonly gradeLevel: FieldRef<"QuestionPaper", 'String'>
    readonly language: FieldRef<"QuestionPaper", 'String'>
    readonly imageUrl: FieldRef<"QuestionPaper", 'String'>
    readonly imageHash: FieldRef<"QuestionPaper", 'String'>
    readonly totalQuestions: FieldRef<"QuestionPaper", 'Int'>
    readonly createdAt: FieldRef<"QuestionPaper", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionPaper", 'DateTime'>
    readonly usageCount: FieldRef<"QuestionPaper", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuestionPaper findUnique
   */
  export type QuestionPaperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPaper to fetch.
     */
    where: QuestionPaperWhereUniqueInput
  }

  /**
   * QuestionPaper findUniqueOrThrow
   */
  export type QuestionPaperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPaper to fetch.
     */
    where: QuestionPaperWhereUniqueInput
  }

  /**
   * QuestionPaper findFirst
   */
  export type QuestionPaperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPaper to fetch.
     */
    where?: QuestionPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPapers to fetch.
     */
    orderBy?: QuestionPaperOrderByWithRelationInput | QuestionPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionPapers.
     */
    cursor?: QuestionPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionPapers.
     */
    distinct?: QuestionPaperScalarFieldEnum | QuestionPaperScalarFieldEnum[]
  }

  /**
   * QuestionPaper findFirstOrThrow
   */
  export type QuestionPaperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPaper to fetch.
     */
    where?: QuestionPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPapers to fetch.
     */
    orderBy?: QuestionPaperOrderByWithRelationInput | QuestionPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionPapers.
     */
    cursor?: QuestionPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionPapers.
     */
    distinct?: QuestionPaperScalarFieldEnum | QuestionPaperScalarFieldEnum[]
  }

  /**
   * QuestionPaper findMany
   */
  export type QuestionPaperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPapers to fetch.
     */
    where?: QuestionPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPapers to fetch.
     */
    orderBy?: QuestionPaperOrderByWithRelationInput | QuestionPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionPapers.
     */
    cursor?: QuestionPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPapers.
     */
    skip?: number
    distinct?: QuestionPaperScalarFieldEnum | QuestionPaperScalarFieldEnum[]
  }

  /**
   * QuestionPaper create
   */
  export type QuestionPaperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionPaper.
     */
    data: XOR<QuestionPaperCreateInput, QuestionPaperUncheckedCreateInput>
  }

  /**
   * QuestionPaper createMany
   */
  export type QuestionPaperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionPapers.
     */
    data: QuestionPaperCreateManyInput | QuestionPaperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionPaper createManyAndReturn
   */
  export type QuestionPaperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionPapers.
     */
    data: QuestionPaperCreateManyInput | QuestionPaperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionPaper update
   */
  export type QuestionPaperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionPaper.
     */
    data: XOR<QuestionPaperUpdateInput, QuestionPaperUncheckedUpdateInput>
    /**
     * Choose, which QuestionPaper to update.
     */
    where: QuestionPaperWhereUniqueInput
  }

  /**
   * QuestionPaper updateMany
   */
  export type QuestionPaperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionPapers.
     */
    data: XOR<QuestionPaperUpdateManyMutationInput, QuestionPaperUncheckedUpdateManyInput>
    /**
     * Filter which QuestionPapers to update
     */
    where?: QuestionPaperWhereInput
  }

  /**
   * QuestionPaper upsert
   */
  export type QuestionPaperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionPaper to update in case it exists.
     */
    where: QuestionPaperWhereUniqueInput
    /**
     * In case the QuestionPaper found by the `where` argument doesn't exist, create a new QuestionPaper with this data.
     */
    create: XOR<QuestionPaperCreateInput, QuestionPaperUncheckedCreateInput>
    /**
     * In case the QuestionPaper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionPaperUpdateInput, QuestionPaperUncheckedUpdateInput>
  }

  /**
   * QuestionPaper delete
   */
  export type QuestionPaperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    /**
     * Filter which QuestionPaper to delete.
     */
    where: QuestionPaperWhereUniqueInput
  }

  /**
   * QuestionPaper deleteMany
   */
  export type QuestionPaperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionPapers to delete
     */
    where?: QuestionPaperWhereInput
  }

  /**
   * QuestionPaper.questions
   */
  export type QuestionPaper$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * QuestionPaper.gradings
   */
  export type QuestionPaper$gradingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    where?: GradingWhereInput
    orderBy?: GradingOrderByWithRelationInput | GradingOrderByWithRelationInput[]
    cursor?: GradingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[]
  }

  /**
   * QuestionPaper without action
   */
  export type QuestionPaperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    maxScore: number | null
    positionX: number | null
    positionY: number | null
  }

  export type QuestionSumAggregateOutputType = {
    maxScore: number | null
    positionX: number | null
    positionY: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    questionPaperId: string | null
    questionNumber: string | null
    questionText: string | null
    maxScore: number | null
    topic: string | null
    concept: string | null
    positionX: number | null
    positionY: number | null
    createdAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    questionPaperId: string | null
    questionNumber: string | null
    questionText: string | null
    maxScore: number | null
    topic: string | null
    concept: string | null
    positionX: number | null
    positionY: number | null
    createdAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    questionPaperId: number
    questionNumber: number
    questionText: number
    maxScore: number
    topic: number
    concept: number
    positionX: number
    positionY: number
    createdAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    maxScore?: true
    positionX?: true
    positionY?: true
  }

  export type QuestionSumAggregateInputType = {
    maxScore?: true
    positionX?: true
    positionY?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    questionPaperId?: true
    questionNumber?: true
    questionText?: true
    maxScore?: true
    topic?: true
    concept?: true
    positionX?: true
    positionY?: true
    createdAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    questionPaperId?: true
    questionNumber?: true
    questionText?: true
    maxScore?: true
    topic?: true
    concept?: true
    positionX?: true
    positionY?: true
    createdAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    questionPaperId?: true
    questionNumber?: true
    questionText?: true
    maxScore?: true
    topic?: true
    concept?: true
    positionX?: true
    positionY?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    questionPaperId: string
    questionNumber: string
    questionText: string
    maxScore: number | null
    topic: string | null
    concept: string | null
    positionX: number | null
    positionY: number | null
    createdAt: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionPaperId?: boolean
    questionNumber?: boolean
    questionText?: boolean
    maxScore?: boolean
    topic?: boolean
    concept?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    questionPaper?: boolean | QuestionPaperDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionPaperId?: boolean
    questionNumber?: boolean
    questionText?: boolean
    maxScore?: boolean
    topic?: boolean
    concept?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    questionPaper?: boolean | QuestionPaperDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    questionPaperId?: boolean
    questionNumber?: boolean
    questionText?: boolean
    maxScore?: boolean
    topic?: boolean
    concept?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
  }

  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionPaper?: boolean | QuestionPaperDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionPaper?: boolean | QuestionPaperDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      questionPaper: Prisma.$QuestionPaperPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionPaperId: string
      questionNumber: string
      questionText: string
      maxScore: number | null
      topic: string | null
      concept: string | null
      positionX: number | null
      positionY: number | null
      createdAt: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questionPaper<T extends QuestionPaperDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionPaperDefaultArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */ 
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly questionPaperId: FieldRef<"Question", 'String'>
    readonly questionNumber: FieldRef<"Question", 'String'>
    readonly questionText: FieldRef<"Question", 'String'>
    readonly maxScore: FieldRef<"Question", 'Float'>
    readonly topic: FieldRef<"Question", 'String'>
    readonly concept: FieldRef<"Question", 'String'>
    readonly positionX: FieldRef<"Question", 'Float'>
    readonly positionY: FieldRef<"Question", 'Float'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    grade: string | null
    school: string | null
    languagePreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    grade: string | null
    school: string | null
    languagePreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    grade: number
    school: number
    languagePreference: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    grade?: true
    school?: true
    languagePreference?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    grade?: true
    school?: true
    languagePreference?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    grade?: true
    school?: true
    languagePreference?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    passwordHash: string
    grade: string | null
    school: string | null
    languagePreference: string
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    grade?: boolean
    school?: boolean
    languagePreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    gradings?: boolean | User$gradingsArgs<ExtArgs>
    doubts?: boolean | User$doubtsArgs<ExtArgs>
    worksheets?: boolean | User$worksheetsArgs<ExtArgs>
    doubtRatings?: boolean | User$doubtRatingsArgs<ExtArgs>
    revisionSessions?: boolean | User$revisionSessionsArgs<ExtArgs>
    weakTopics?: boolean | User$weakTopicsArgs<ExtArgs>
    groupStudySessions?: boolean | User$groupStudySessionsArgs<ExtArgs>
    handlingSkillProgress?: boolean | User$handlingSkillProgressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    grade?: boolean
    school?: boolean
    languagePreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    grade?: boolean
    school?: boolean
    languagePreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gradings?: boolean | User$gradingsArgs<ExtArgs>
    doubts?: boolean | User$doubtsArgs<ExtArgs>
    worksheets?: boolean | User$worksheetsArgs<ExtArgs>
    doubtRatings?: boolean | User$doubtRatingsArgs<ExtArgs>
    revisionSessions?: boolean | User$revisionSessionsArgs<ExtArgs>
    weakTopics?: boolean | User$weakTopicsArgs<ExtArgs>
    groupStudySessions?: boolean | User$groupStudySessionsArgs<ExtArgs>
    handlingSkillProgress?: boolean | User$handlingSkillProgressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      gradings: Prisma.$GradingPayload<ExtArgs>[]
      doubts: Prisma.$DoubtPayload<ExtArgs>[]
      worksheets: Prisma.$WorksheetPayload<ExtArgs>[]
      doubtRatings: Prisma.$DoubtRatingPayload<ExtArgs>[]
      revisionSessions: Prisma.$RevisionSessionPayload<ExtArgs>[]
      weakTopics: Prisma.$WeakTopicPayload<ExtArgs>[]
      groupStudySessions: Prisma.$GroupStudySessionPayload<ExtArgs>[]
      handlingSkillProgress: Prisma.$HandlingSkillProgressPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      passwordHash: string
      grade: string | null
      school: string | null
      languagePreference: string
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gradings<T extends User$gradingsArgs<ExtArgs> = {}>(args?: Subset<T, User$gradingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findMany"> | Null>
    doubts<T extends User$doubtsArgs<ExtArgs> = {}>(args?: Subset<T, User$doubtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findMany"> | Null>
    worksheets<T extends User$worksheetsArgs<ExtArgs> = {}>(args?: Subset<T, User$worksheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findMany"> | Null>
    doubtRatings<T extends User$doubtRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$doubtRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "findMany"> | Null>
    revisionSessions<T extends User$revisionSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$revisionSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "findMany"> | Null>
    weakTopics<T extends User$weakTopicsArgs<ExtArgs> = {}>(args?: Subset<T, User$weakTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "findMany"> | Null>
    groupStudySessions<T extends User$groupStudySessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupStudySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "findMany"> | Null>
    handlingSkillProgress<T extends User$handlingSkillProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$handlingSkillProgressArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly grade: FieldRef<"User", 'String'>
    readonly school: FieldRef<"User", 'String'>
    readonly languagePreference: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.gradings
   */
  export type User$gradingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    where?: GradingWhereInput
    orderBy?: GradingOrderByWithRelationInput | GradingOrderByWithRelationInput[]
    cursor?: GradingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[]
  }

  /**
   * User.doubts
   */
  export type User$doubtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    where?: DoubtWhereInput
    orderBy?: DoubtOrderByWithRelationInput | DoubtOrderByWithRelationInput[]
    cursor?: DoubtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoubtScalarFieldEnum | DoubtScalarFieldEnum[]
  }

  /**
   * User.worksheets
   */
  export type User$worksheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    where?: WorksheetWhereInput
    orderBy?: WorksheetOrderByWithRelationInput | WorksheetOrderByWithRelationInput[]
    cursor?: WorksheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorksheetScalarFieldEnum | WorksheetScalarFieldEnum[]
  }

  /**
   * User.doubtRatings
   */
  export type User$doubtRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    where?: DoubtRatingWhereInput
    orderBy?: DoubtRatingOrderByWithRelationInput | DoubtRatingOrderByWithRelationInput[]
    cursor?: DoubtRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoubtRatingScalarFieldEnum | DoubtRatingScalarFieldEnum[]
  }

  /**
   * User.revisionSessions
   */
  export type User$revisionSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    where?: RevisionSessionWhereInput
    orderBy?: RevisionSessionOrderByWithRelationInput | RevisionSessionOrderByWithRelationInput[]
    cursor?: RevisionSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevisionSessionScalarFieldEnum | RevisionSessionScalarFieldEnum[]
  }

  /**
   * User.weakTopics
   */
  export type User$weakTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    where?: WeakTopicWhereInput
    orderBy?: WeakTopicOrderByWithRelationInput | WeakTopicOrderByWithRelationInput[]
    cursor?: WeakTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeakTopicScalarFieldEnum | WeakTopicScalarFieldEnum[]
  }

  /**
   * User.groupStudySessions
   */
  export type User$groupStudySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    where?: GroupStudySessionWhereInput
    orderBy?: GroupStudySessionOrderByWithRelationInput | GroupStudySessionOrderByWithRelationInput[]
    cursor?: GroupStudySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupStudySessionScalarFieldEnum | GroupStudySessionScalarFieldEnum[]
  }

  /**
   * User.handlingSkillProgress
   */
  export type User$handlingSkillProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    where?: HandlingSkillProgressWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Grading
   */

  export type AggregateGrading = {
    _count: GradingCountAggregateOutputType | null
    _avg: GradingAvgAggregateOutputType | null
    _sum: GradingSumAggregateOutputType | null
    _min: GradingMinAggregateOutputType | null
    _max: GradingMaxAggregateOutputType | null
  }

  export type GradingAvgAggregateOutputType = {
    totalPages: number | null
    totalQuestions: number | null
    answeredQuestions: number | null
  }

  export type GradingSumAggregateOutputType = {
    totalPages: number | null
    totalQuestions: number | null
    answeredQuestions: number | null
  }

  export type GradingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    questionPaperId: string | null
    answerSheetUrl: string | null
    totalPages: number | null
    subject: string | null
    language: string | null
    gradeLevel: string | null
    totalScore: string | null
    feedback: string | null
    matchingMode: string | null
    totalQuestions: number | null
    answeredQuestions: number | null
    annotations: string | null
    imageDimensions: string | null
    createdAt: Date | null
  }

  export type GradingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    questionPaperId: string | null
    answerSheetUrl: string | null
    totalPages: number | null
    subject: string | null
    language: string | null
    gradeLevel: string | null
    totalScore: string | null
    feedback: string | null
    matchingMode: string | null
    totalQuestions: number | null
    answeredQuestions: number | null
    annotations: string | null
    imageDimensions: string | null
    createdAt: Date | null
  }

  export type GradingCountAggregateOutputType = {
    id: number
    userId: number
    questionPaperId: number
    answerSheetUrl: number
    totalPages: number
    subject: number
    language: number
    gradeLevel: number
    totalScore: number
    feedback: number
    matchingMode: number
    totalQuestions: number
    answeredQuestions: number
    annotations: number
    imageDimensions: number
    createdAt: number
    _all: number
  }


  export type GradingAvgAggregateInputType = {
    totalPages?: true
    totalQuestions?: true
    answeredQuestions?: true
  }

  export type GradingSumAggregateInputType = {
    totalPages?: true
    totalQuestions?: true
    answeredQuestions?: true
  }

  export type GradingMinAggregateInputType = {
    id?: true
    userId?: true
    questionPaperId?: true
    answerSheetUrl?: true
    totalPages?: true
    subject?: true
    language?: true
    gradeLevel?: true
    totalScore?: true
    feedback?: true
    matchingMode?: true
    totalQuestions?: true
    answeredQuestions?: true
    annotations?: true
    imageDimensions?: true
    createdAt?: true
  }

  export type GradingMaxAggregateInputType = {
    id?: true
    userId?: true
    questionPaperId?: true
    answerSheetUrl?: true
    totalPages?: true
    subject?: true
    language?: true
    gradeLevel?: true
    totalScore?: true
    feedback?: true
    matchingMode?: true
    totalQuestions?: true
    answeredQuestions?: true
    annotations?: true
    imageDimensions?: true
    createdAt?: true
  }

  export type GradingCountAggregateInputType = {
    id?: true
    userId?: true
    questionPaperId?: true
    answerSheetUrl?: true
    totalPages?: true
    subject?: true
    language?: true
    gradeLevel?: true
    totalScore?: true
    feedback?: true
    matchingMode?: true
    totalQuestions?: true
    answeredQuestions?: true
    annotations?: true
    imageDimensions?: true
    createdAt?: true
    _all?: true
  }

  export type GradingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grading to aggregate.
     */
    where?: GradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gradings to fetch.
     */
    orderBy?: GradingOrderByWithRelationInput | GradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gradings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gradings
    **/
    _count?: true | GradingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradingMaxAggregateInputType
  }

  export type GetGradingAggregateType<T extends GradingAggregateArgs> = {
        [P in keyof T & keyof AggregateGrading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrading[P]>
      : GetScalarType<T[P], AggregateGrading[P]>
  }




  export type GradingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradingWhereInput
    orderBy?: GradingOrderByWithAggregationInput | GradingOrderByWithAggregationInput[]
    by: GradingScalarFieldEnum[] | GradingScalarFieldEnum
    having?: GradingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradingCountAggregateInputType | true
    _avg?: GradingAvgAggregateInputType
    _sum?: GradingSumAggregateInputType
    _min?: GradingMinAggregateInputType
    _max?: GradingMaxAggregateInputType
  }

  export type GradingGroupByOutputType = {
    id: string
    userId: string | null
    questionPaperId: string | null
    answerSheetUrl: string
    totalPages: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode: string | null
    totalQuestions: number | null
    answeredQuestions: number | null
    annotations: string | null
    imageDimensions: string | null
    createdAt: Date
    _count: GradingCountAggregateOutputType | null
    _avg: GradingAvgAggregateOutputType | null
    _sum: GradingSumAggregateOutputType | null
    _min: GradingMinAggregateOutputType | null
    _max: GradingMaxAggregateOutputType | null
  }

  type GetGradingGroupByPayload<T extends GradingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradingGroupByOutputType[P]>
            : GetScalarType<T[P], GradingGroupByOutputType[P]>
        }
      >
    >


  export type GradingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionPaperId?: boolean
    answerSheetUrl?: boolean
    totalPages?: boolean
    subject?: boolean
    language?: boolean
    gradeLevel?: boolean
    totalScore?: boolean
    feedback?: boolean
    matchingMode?: boolean
    totalQuestions?: boolean
    answeredQuestions?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    createdAt?: boolean
    user?: boolean | Grading$userArgs<ExtArgs>
    questionPaper?: boolean | Grading$questionPaperArgs<ExtArgs>
    pages?: boolean | Grading$pagesArgs<ExtArgs>
    answers?: boolean | Grading$answersArgs<ExtArgs>
    _count?: boolean | GradingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grading"]>

  export type GradingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionPaperId?: boolean
    answerSheetUrl?: boolean
    totalPages?: boolean
    subject?: boolean
    language?: boolean
    gradeLevel?: boolean
    totalScore?: boolean
    feedback?: boolean
    matchingMode?: boolean
    totalQuestions?: boolean
    answeredQuestions?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    createdAt?: boolean
    user?: boolean | Grading$userArgs<ExtArgs>
    questionPaper?: boolean | Grading$questionPaperArgs<ExtArgs>
  }, ExtArgs["result"]["grading"]>

  export type GradingSelectScalar = {
    id?: boolean
    userId?: boolean
    questionPaperId?: boolean
    answerSheetUrl?: boolean
    totalPages?: boolean
    subject?: boolean
    language?: boolean
    gradeLevel?: boolean
    totalScore?: boolean
    feedback?: boolean
    matchingMode?: boolean
    totalQuestions?: boolean
    answeredQuestions?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    createdAt?: boolean
  }

  export type GradingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Grading$userArgs<ExtArgs>
    questionPaper?: boolean | Grading$questionPaperArgs<ExtArgs>
    pages?: boolean | Grading$pagesArgs<ExtArgs>
    answers?: boolean | Grading$answersArgs<ExtArgs>
    _count?: boolean | GradingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Grading$userArgs<ExtArgs>
    questionPaper?: boolean | Grading$questionPaperArgs<ExtArgs>
  }

  export type $GradingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grading"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      questionPaper: Prisma.$QuestionPaperPayload<ExtArgs> | null
      pages: Prisma.$GradingPagePayload<ExtArgs>[]
      answers: Prisma.$AnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      questionPaperId: string | null
      answerSheetUrl: string
      totalPages: number
      subject: string
      language: string
      gradeLevel: string
      totalScore: string
      feedback: string
      matchingMode: string | null
      totalQuestions: number | null
      answeredQuestions: number | null
      annotations: string | null
      imageDimensions: string | null
      createdAt: Date
    }, ExtArgs["result"]["grading"]>
    composites: {}
  }

  type GradingGetPayload<S extends boolean | null | undefined | GradingDefaultArgs> = $Result.GetResult<Prisma.$GradingPayload, S>

  type GradingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GradingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GradingCountAggregateInputType | true
    }

  export interface GradingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grading'], meta: { name: 'Grading' } }
    /**
     * Find zero or one Grading that matches the filter.
     * @param {GradingFindUniqueArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradingFindUniqueArgs>(args: SelectSubset<T, GradingFindUniqueArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grading that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GradingFindUniqueOrThrowArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradingFindUniqueOrThrowArgs>(args: SelectSubset<T, GradingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingFindFirstArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradingFindFirstArgs>(args?: SelectSubset<T, GradingFindFirstArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingFindFirstOrThrowArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradingFindFirstOrThrowArgs>(args?: SelectSubset<T, GradingFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gradings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gradings
     * const gradings = await prisma.grading.findMany()
     * 
     * // Get first 10 Gradings
     * const gradings = await prisma.grading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradingWithIdOnly = await prisma.grading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradingFindManyArgs>(args?: SelectSubset<T, GradingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grading.
     * @param {GradingCreateArgs} args - Arguments to create a Grading.
     * @example
     * // Create one Grading
     * const Grading = await prisma.grading.create({
     *   data: {
     *     // ... data to create a Grading
     *   }
     * })
     * 
     */
    create<T extends GradingCreateArgs>(args: SelectSubset<T, GradingCreateArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gradings.
     * @param {GradingCreateManyArgs} args - Arguments to create many Gradings.
     * @example
     * // Create many Gradings
     * const grading = await prisma.grading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradingCreateManyArgs>(args?: SelectSubset<T, GradingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gradings and returns the data saved in the database.
     * @param {GradingCreateManyAndReturnArgs} args - Arguments to create many Gradings.
     * @example
     * // Create many Gradings
     * const grading = await prisma.grading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gradings and only return the `id`
     * const gradingWithIdOnly = await prisma.grading.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradingCreateManyAndReturnArgs>(args?: SelectSubset<T, GradingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Grading.
     * @param {GradingDeleteArgs} args - Arguments to delete one Grading.
     * @example
     * // Delete one Grading
     * const Grading = await prisma.grading.delete({
     *   where: {
     *     // ... filter to delete one Grading
     *   }
     * })
     * 
     */
    delete<T extends GradingDeleteArgs>(args: SelectSubset<T, GradingDeleteArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grading.
     * @param {GradingUpdateArgs} args - Arguments to update one Grading.
     * @example
     * // Update one Grading
     * const grading = await prisma.grading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradingUpdateArgs>(args: SelectSubset<T, GradingUpdateArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gradings.
     * @param {GradingDeleteManyArgs} args - Arguments to filter Gradings to delete.
     * @example
     * // Delete a few Gradings
     * const { count } = await prisma.grading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradingDeleteManyArgs>(args?: SelectSubset<T, GradingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gradings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gradings
     * const grading = await prisma.grading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradingUpdateManyArgs>(args: SelectSubset<T, GradingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grading.
     * @param {GradingUpsertArgs} args - Arguments to update or create a Grading.
     * @example
     * // Update or create a Grading
     * const grading = await prisma.grading.upsert({
     *   create: {
     *     // ... data to create a Grading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grading we want to update
     *   }
     * })
     */
    upsert<T extends GradingUpsertArgs>(args: SelectSubset<T, GradingUpsertArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gradings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingCountArgs} args - Arguments to filter Gradings to count.
     * @example
     * // Count the number of Gradings
     * const count = await prisma.grading.count({
     *   where: {
     *     // ... the filter for the Gradings we want to count
     *   }
     * })
    **/
    count<T extends GradingCountArgs>(
      args?: Subset<T, GradingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradingAggregateArgs>(args: Subset<T, GradingAggregateArgs>): Prisma.PrismaPromise<GetGradingAggregateType<T>>

    /**
     * Group by Grading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradingGroupByArgs['orderBy'] }
        : { orderBy?: GradingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grading model
   */
  readonly fields: GradingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Grading$userArgs<ExtArgs> = {}>(args?: Subset<T, Grading$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    questionPaper<T extends Grading$questionPaperArgs<ExtArgs> = {}>(args?: Subset<T, Grading$questionPaperArgs<ExtArgs>>): Prisma__QuestionPaperClient<$Result.GetResult<Prisma.$QuestionPaperPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pages<T extends Grading$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Grading$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "findMany"> | Null>
    answers<T extends Grading$answersArgs<ExtArgs> = {}>(args?: Subset<T, Grading$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grading model
   */ 
  interface GradingFieldRefs {
    readonly id: FieldRef<"Grading", 'String'>
    readonly userId: FieldRef<"Grading", 'String'>
    readonly questionPaperId: FieldRef<"Grading", 'String'>
    readonly answerSheetUrl: FieldRef<"Grading", 'String'>
    readonly totalPages: FieldRef<"Grading", 'Int'>
    readonly subject: FieldRef<"Grading", 'String'>
    readonly language: FieldRef<"Grading", 'String'>
    readonly gradeLevel: FieldRef<"Grading", 'String'>
    readonly totalScore: FieldRef<"Grading", 'String'>
    readonly feedback: FieldRef<"Grading", 'String'>
    readonly matchingMode: FieldRef<"Grading", 'String'>
    readonly totalQuestions: FieldRef<"Grading", 'Int'>
    readonly answeredQuestions: FieldRef<"Grading", 'Int'>
    readonly annotations: FieldRef<"Grading", 'String'>
    readonly imageDimensions: FieldRef<"Grading", 'String'>
    readonly createdAt: FieldRef<"Grading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grading findUnique
   */
  export type GradingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * Filter, which Grading to fetch.
     */
    where: GradingWhereUniqueInput
  }

  /**
   * Grading findUniqueOrThrow
   */
  export type GradingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * Filter, which Grading to fetch.
     */
    where: GradingWhereUniqueInput
  }

  /**
   * Grading findFirst
   */
  export type GradingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * Filter, which Grading to fetch.
     */
    where?: GradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gradings to fetch.
     */
    orderBy?: GradingOrderByWithRelationInput | GradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gradings.
     */
    cursor?: GradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gradings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gradings.
     */
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[]
  }

  /**
   * Grading findFirstOrThrow
   */
  export type GradingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * Filter, which Grading to fetch.
     */
    where?: GradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gradings to fetch.
     */
    orderBy?: GradingOrderByWithRelationInput | GradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gradings.
     */
    cursor?: GradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gradings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gradings.
     */
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[]
  }

  /**
   * Grading findMany
   */
  export type GradingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * Filter, which Gradings to fetch.
     */
    where?: GradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gradings to fetch.
     */
    orderBy?: GradingOrderByWithRelationInput | GradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gradings.
     */
    cursor?: GradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gradings.
     */
    skip?: number
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[]
  }

  /**
   * Grading create
   */
  export type GradingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * The data needed to create a Grading.
     */
    data: XOR<GradingCreateInput, GradingUncheckedCreateInput>
  }

  /**
   * Grading createMany
   */
  export type GradingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gradings.
     */
    data: GradingCreateManyInput | GradingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grading createManyAndReturn
   */
  export type GradingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Gradings.
     */
    data: GradingCreateManyInput | GradingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grading update
   */
  export type GradingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * The data needed to update a Grading.
     */
    data: XOR<GradingUpdateInput, GradingUncheckedUpdateInput>
    /**
     * Choose, which Grading to update.
     */
    where: GradingWhereUniqueInput
  }

  /**
   * Grading updateMany
   */
  export type GradingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gradings.
     */
    data: XOR<GradingUpdateManyMutationInput, GradingUncheckedUpdateManyInput>
    /**
     * Filter which Gradings to update
     */
    where?: GradingWhereInput
  }

  /**
   * Grading upsert
   */
  export type GradingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * The filter to search for the Grading to update in case it exists.
     */
    where: GradingWhereUniqueInput
    /**
     * In case the Grading found by the `where` argument doesn't exist, create a new Grading with this data.
     */
    create: XOR<GradingCreateInput, GradingUncheckedCreateInput>
    /**
     * In case the Grading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradingUpdateInput, GradingUncheckedUpdateInput>
  }

  /**
   * Grading delete
   */
  export type GradingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
    /**
     * Filter which Grading to delete.
     */
    where: GradingWhereUniqueInput
  }

  /**
   * Grading deleteMany
   */
  export type GradingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gradings to delete
     */
    where?: GradingWhereInput
  }

  /**
   * Grading.user
   */
  export type Grading$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Grading.questionPaper
   */
  export type Grading$questionPaperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPaper
     */
    select?: QuestionPaperSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPaperInclude<ExtArgs> | null
    where?: QuestionPaperWhereInput
  }

  /**
   * Grading.pages
   */
  export type Grading$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    where?: GradingPageWhereInput
    orderBy?: GradingPageOrderByWithRelationInput | GradingPageOrderByWithRelationInput[]
    cursor?: GradingPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradingPageScalarFieldEnum | GradingPageScalarFieldEnum[]
  }

  /**
   * Grading.answers
   */
  export type Grading$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Grading without action
   */
  export type GradingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null
  }


  /**
   * Model GradingPage
   */

  export type AggregateGradingPage = {
    _count: GradingPageCountAggregateOutputType | null
    _avg: GradingPageAvgAggregateOutputType | null
    _sum: GradingPageSumAggregateOutputType | null
    _min: GradingPageMinAggregateOutputType | null
    _max: GradingPageMaxAggregateOutputType | null
  }

  export type GradingPageAvgAggregateOutputType = {
    pageNumber: number | null
  }

  export type GradingPageSumAggregateOutputType = {
    pageNumber: number | null
  }

  export type GradingPageMinAggregateOutputType = {
    id: string | null
    gradingId: string | null
    pageNumber: number | null
    imageUrl: string | null
    annotations: string | null
    imageDimensions: string | null
    createdAt: Date | null
  }

  export type GradingPageMaxAggregateOutputType = {
    id: string | null
    gradingId: string | null
    pageNumber: number | null
    imageUrl: string | null
    annotations: string | null
    imageDimensions: string | null
    createdAt: Date | null
  }

  export type GradingPageCountAggregateOutputType = {
    id: number
    gradingId: number
    pageNumber: number
    imageUrl: number
    annotations: number
    imageDimensions: number
    createdAt: number
    _all: number
  }


  export type GradingPageAvgAggregateInputType = {
    pageNumber?: true
  }

  export type GradingPageSumAggregateInputType = {
    pageNumber?: true
  }

  export type GradingPageMinAggregateInputType = {
    id?: true
    gradingId?: true
    pageNumber?: true
    imageUrl?: true
    annotations?: true
    imageDimensions?: true
    createdAt?: true
  }

  export type GradingPageMaxAggregateInputType = {
    id?: true
    gradingId?: true
    pageNumber?: true
    imageUrl?: true
    annotations?: true
    imageDimensions?: true
    createdAt?: true
  }

  export type GradingPageCountAggregateInputType = {
    id?: true
    gradingId?: true
    pageNumber?: true
    imageUrl?: true
    annotations?: true
    imageDimensions?: true
    createdAt?: true
    _all?: true
  }

  export type GradingPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradingPage to aggregate.
     */
    where?: GradingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingPages to fetch.
     */
    orderBy?: GradingPageOrderByWithRelationInput | GradingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GradingPages
    **/
    _count?: true | GradingPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradingPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradingPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradingPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradingPageMaxAggregateInputType
  }

  export type GetGradingPageAggregateType<T extends GradingPageAggregateArgs> = {
        [P in keyof T & keyof AggregateGradingPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradingPage[P]>
      : GetScalarType<T[P], AggregateGradingPage[P]>
  }




  export type GradingPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradingPageWhereInput
    orderBy?: GradingPageOrderByWithAggregationInput | GradingPageOrderByWithAggregationInput[]
    by: GradingPageScalarFieldEnum[] | GradingPageScalarFieldEnum
    having?: GradingPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradingPageCountAggregateInputType | true
    _avg?: GradingPageAvgAggregateInputType
    _sum?: GradingPageSumAggregateInputType
    _min?: GradingPageMinAggregateInputType
    _max?: GradingPageMaxAggregateInputType
  }

  export type GradingPageGroupByOutputType = {
    id: string
    gradingId: string
    pageNumber: number
    imageUrl: string
    annotations: string | null
    imageDimensions: string | null
    createdAt: Date
    _count: GradingPageCountAggregateOutputType | null
    _avg: GradingPageAvgAggregateOutputType | null
    _sum: GradingPageSumAggregateOutputType | null
    _min: GradingPageMinAggregateOutputType | null
    _max: GradingPageMaxAggregateOutputType | null
  }

  type GetGradingPageGroupByPayload<T extends GradingPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradingPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradingPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradingPageGroupByOutputType[P]>
            : GetScalarType<T[P], GradingPageGroupByOutputType[P]>
        }
      >
    >


  export type GradingPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradingId?: boolean
    pageNumber?: boolean
    imageUrl?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    createdAt?: boolean
    grading?: boolean | GradingDefaultArgs<ExtArgs>
    pageAnswers?: boolean | GradingPage$pageAnswersArgs<ExtArgs>
    _count?: boolean | GradingPageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradingPage"]>

  export type GradingPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradingId?: boolean
    pageNumber?: boolean
    imageUrl?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    createdAt?: boolean
    grading?: boolean | GradingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradingPage"]>

  export type GradingPageSelectScalar = {
    id?: boolean
    gradingId?: boolean
    pageNumber?: boolean
    imageUrl?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    createdAt?: boolean
  }

  export type GradingPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grading?: boolean | GradingDefaultArgs<ExtArgs>
    pageAnswers?: boolean | GradingPage$pageAnswersArgs<ExtArgs>
    _count?: boolean | GradingPageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradingPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grading?: boolean | GradingDefaultArgs<ExtArgs>
  }

  export type $GradingPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GradingPage"
    objects: {
      grading: Prisma.$GradingPayload<ExtArgs>
      pageAnswers: Prisma.$PageAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gradingId: string
      pageNumber: number
      imageUrl: string
      annotations: string | null
      imageDimensions: string | null
      createdAt: Date
    }, ExtArgs["result"]["gradingPage"]>
    composites: {}
  }

  type GradingPageGetPayload<S extends boolean | null | undefined | GradingPageDefaultArgs> = $Result.GetResult<Prisma.$GradingPagePayload, S>

  type GradingPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GradingPageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GradingPageCountAggregateInputType | true
    }

  export interface GradingPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GradingPage'], meta: { name: 'GradingPage' } }
    /**
     * Find zero or one GradingPage that matches the filter.
     * @param {GradingPageFindUniqueArgs} args - Arguments to find a GradingPage
     * @example
     * // Get one GradingPage
     * const gradingPage = await prisma.gradingPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradingPageFindUniqueArgs>(args: SelectSubset<T, GradingPageFindUniqueArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GradingPage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GradingPageFindUniqueOrThrowArgs} args - Arguments to find a GradingPage
     * @example
     * // Get one GradingPage
     * const gradingPage = await prisma.gradingPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradingPageFindUniqueOrThrowArgs>(args: SelectSubset<T, GradingPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GradingPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingPageFindFirstArgs} args - Arguments to find a GradingPage
     * @example
     * // Get one GradingPage
     * const gradingPage = await prisma.gradingPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradingPageFindFirstArgs>(args?: SelectSubset<T, GradingPageFindFirstArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GradingPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingPageFindFirstOrThrowArgs} args - Arguments to find a GradingPage
     * @example
     * // Get one GradingPage
     * const gradingPage = await prisma.gradingPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradingPageFindFirstOrThrowArgs>(args?: SelectSubset<T, GradingPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GradingPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GradingPages
     * const gradingPages = await prisma.gradingPage.findMany()
     * 
     * // Get first 10 GradingPages
     * const gradingPages = await prisma.gradingPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradingPageWithIdOnly = await prisma.gradingPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradingPageFindManyArgs>(args?: SelectSubset<T, GradingPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GradingPage.
     * @param {GradingPageCreateArgs} args - Arguments to create a GradingPage.
     * @example
     * // Create one GradingPage
     * const GradingPage = await prisma.gradingPage.create({
     *   data: {
     *     // ... data to create a GradingPage
     *   }
     * })
     * 
     */
    create<T extends GradingPageCreateArgs>(args: SelectSubset<T, GradingPageCreateArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GradingPages.
     * @param {GradingPageCreateManyArgs} args - Arguments to create many GradingPages.
     * @example
     * // Create many GradingPages
     * const gradingPage = await prisma.gradingPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradingPageCreateManyArgs>(args?: SelectSubset<T, GradingPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GradingPages and returns the data saved in the database.
     * @param {GradingPageCreateManyAndReturnArgs} args - Arguments to create many GradingPages.
     * @example
     * // Create many GradingPages
     * const gradingPage = await prisma.gradingPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GradingPages and only return the `id`
     * const gradingPageWithIdOnly = await prisma.gradingPage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradingPageCreateManyAndReturnArgs>(args?: SelectSubset<T, GradingPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GradingPage.
     * @param {GradingPageDeleteArgs} args - Arguments to delete one GradingPage.
     * @example
     * // Delete one GradingPage
     * const GradingPage = await prisma.gradingPage.delete({
     *   where: {
     *     // ... filter to delete one GradingPage
     *   }
     * })
     * 
     */
    delete<T extends GradingPageDeleteArgs>(args: SelectSubset<T, GradingPageDeleteArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GradingPage.
     * @param {GradingPageUpdateArgs} args - Arguments to update one GradingPage.
     * @example
     * // Update one GradingPage
     * const gradingPage = await prisma.gradingPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradingPageUpdateArgs>(args: SelectSubset<T, GradingPageUpdateArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GradingPages.
     * @param {GradingPageDeleteManyArgs} args - Arguments to filter GradingPages to delete.
     * @example
     * // Delete a few GradingPages
     * const { count } = await prisma.gradingPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradingPageDeleteManyArgs>(args?: SelectSubset<T, GradingPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradingPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GradingPages
     * const gradingPage = await prisma.gradingPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradingPageUpdateManyArgs>(args: SelectSubset<T, GradingPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GradingPage.
     * @param {GradingPageUpsertArgs} args - Arguments to update or create a GradingPage.
     * @example
     * // Update or create a GradingPage
     * const gradingPage = await prisma.gradingPage.upsert({
     *   create: {
     *     // ... data to create a GradingPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GradingPage we want to update
     *   }
     * })
     */
    upsert<T extends GradingPageUpsertArgs>(args: SelectSubset<T, GradingPageUpsertArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GradingPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingPageCountArgs} args - Arguments to filter GradingPages to count.
     * @example
     * // Count the number of GradingPages
     * const count = await prisma.gradingPage.count({
     *   where: {
     *     // ... the filter for the GradingPages we want to count
     *   }
     * })
    **/
    count<T extends GradingPageCountArgs>(
      args?: Subset<T, GradingPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradingPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GradingPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradingPageAggregateArgs>(args: Subset<T, GradingPageAggregateArgs>): Prisma.PrismaPromise<GetGradingPageAggregateType<T>>

    /**
     * Group by GradingPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradingPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradingPageGroupByArgs['orderBy'] }
        : { orderBy?: GradingPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradingPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradingPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GradingPage model
   */
  readonly fields: GradingPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GradingPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradingPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grading<T extends GradingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradingDefaultArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pageAnswers<T extends GradingPage$pageAnswersArgs<ExtArgs> = {}>(args?: Subset<T, GradingPage$pageAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GradingPage model
   */ 
  interface GradingPageFieldRefs {
    readonly id: FieldRef<"GradingPage", 'String'>
    readonly gradingId: FieldRef<"GradingPage", 'String'>
    readonly pageNumber: FieldRef<"GradingPage", 'Int'>
    readonly imageUrl: FieldRef<"GradingPage", 'String'>
    readonly annotations: FieldRef<"GradingPage", 'String'>
    readonly imageDimensions: FieldRef<"GradingPage", 'String'>
    readonly createdAt: FieldRef<"GradingPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GradingPage findUnique
   */
  export type GradingPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * Filter, which GradingPage to fetch.
     */
    where: GradingPageWhereUniqueInput
  }

  /**
   * GradingPage findUniqueOrThrow
   */
  export type GradingPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * Filter, which GradingPage to fetch.
     */
    where: GradingPageWhereUniqueInput
  }

  /**
   * GradingPage findFirst
   */
  export type GradingPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * Filter, which GradingPage to fetch.
     */
    where?: GradingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingPages to fetch.
     */
    orderBy?: GradingPageOrderByWithRelationInput | GradingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradingPages.
     */
    cursor?: GradingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradingPages.
     */
    distinct?: GradingPageScalarFieldEnum | GradingPageScalarFieldEnum[]
  }

  /**
   * GradingPage findFirstOrThrow
   */
  export type GradingPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * Filter, which GradingPage to fetch.
     */
    where?: GradingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingPages to fetch.
     */
    orderBy?: GradingPageOrderByWithRelationInput | GradingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradingPages.
     */
    cursor?: GradingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradingPages.
     */
    distinct?: GradingPageScalarFieldEnum | GradingPageScalarFieldEnum[]
  }

  /**
   * GradingPage findMany
   */
  export type GradingPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * Filter, which GradingPages to fetch.
     */
    where?: GradingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradingPages to fetch.
     */
    orderBy?: GradingPageOrderByWithRelationInput | GradingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GradingPages.
     */
    cursor?: GradingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradingPages.
     */
    skip?: number
    distinct?: GradingPageScalarFieldEnum | GradingPageScalarFieldEnum[]
  }

  /**
   * GradingPage create
   */
  export type GradingPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * The data needed to create a GradingPage.
     */
    data: XOR<GradingPageCreateInput, GradingPageUncheckedCreateInput>
  }

  /**
   * GradingPage createMany
   */
  export type GradingPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GradingPages.
     */
    data: GradingPageCreateManyInput | GradingPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GradingPage createManyAndReturn
   */
  export type GradingPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GradingPages.
     */
    data: GradingPageCreateManyInput | GradingPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradingPage update
   */
  export type GradingPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * The data needed to update a GradingPage.
     */
    data: XOR<GradingPageUpdateInput, GradingPageUncheckedUpdateInput>
    /**
     * Choose, which GradingPage to update.
     */
    where: GradingPageWhereUniqueInput
  }

  /**
   * GradingPage updateMany
   */
  export type GradingPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GradingPages.
     */
    data: XOR<GradingPageUpdateManyMutationInput, GradingPageUncheckedUpdateManyInput>
    /**
     * Filter which GradingPages to update
     */
    where?: GradingPageWhereInput
  }

  /**
   * GradingPage upsert
   */
  export type GradingPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * The filter to search for the GradingPage to update in case it exists.
     */
    where: GradingPageWhereUniqueInput
    /**
     * In case the GradingPage found by the `where` argument doesn't exist, create a new GradingPage with this data.
     */
    create: XOR<GradingPageCreateInput, GradingPageUncheckedCreateInput>
    /**
     * In case the GradingPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradingPageUpdateInput, GradingPageUncheckedUpdateInput>
  }

  /**
   * GradingPage delete
   */
  export type GradingPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
    /**
     * Filter which GradingPage to delete.
     */
    where: GradingPageWhereUniqueInput
  }

  /**
   * GradingPage deleteMany
   */
  export type GradingPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradingPages to delete
     */
    where?: GradingPageWhereInput
  }

  /**
   * GradingPage.pageAnswers
   */
  export type GradingPage$pageAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    where?: PageAnswerWhereInput
    orderBy?: PageAnswerOrderByWithRelationInput | PageAnswerOrderByWithRelationInput[]
    cursor?: PageAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageAnswerScalarFieldEnum | PageAnswerScalarFieldEnum[]
  }

  /**
   * GradingPage without action
   */
  export type GradingPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradingPage
     */
    select?: GradingPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingPageInclude<ExtArgs> | null
  }


  /**
   * Model PageAnswer
   */

  export type AggregatePageAnswer = {
    _count: PageAnswerCountAggregateOutputType | null
    _avg: PageAnswerAvgAggregateOutputType | null
    _sum: PageAnswerSumAggregateOutputType | null
    _min: PageAnswerMinAggregateOutputType | null
    _max: PageAnswerMaxAggregateOutputType | null
  }

  export type PageAnswerAvgAggregateOutputType = {
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    continuedFrom: number | null
    continuedTo: number | null
  }

  export type PageAnswerSumAggregateOutputType = {
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    continuedFrom: number | null
    continuedTo: number | null
  }

  export type PageAnswerMinAggregateOutputType = {
    id: string | null
    pageId: string | null
    questionNumber: string | null
    studentAnswer: string | null
    correct: boolean | null
    score: string | null
    remarks: string | null
    matched: boolean | null
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    continuedFrom: number | null
    continuedTo: number | null
    createdAt: Date | null
  }

  export type PageAnswerMaxAggregateOutputType = {
    id: string | null
    pageId: string | null
    questionNumber: string | null
    studentAnswer: string | null
    correct: boolean | null
    score: string | null
    remarks: string | null
    matched: boolean | null
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    continuedFrom: number | null
    continuedTo: number | null
    createdAt: Date | null
  }

  export type PageAnswerCountAggregateOutputType = {
    id: number
    pageId: number
    questionNumber: number
    studentAnswer: number
    correct: number
    score: number
    remarks: number
    matched: number
    matchConfidence: number
    positionX: number
    positionY: number
    continuedFrom: number
    continuedTo: number
    createdAt: number
    _all: number
  }


  export type PageAnswerAvgAggregateInputType = {
    matchConfidence?: true
    positionX?: true
    positionY?: true
    continuedFrom?: true
    continuedTo?: true
  }

  export type PageAnswerSumAggregateInputType = {
    matchConfidence?: true
    positionX?: true
    positionY?: true
    continuedFrom?: true
    continuedTo?: true
  }

  export type PageAnswerMinAggregateInputType = {
    id?: true
    pageId?: true
    questionNumber?: true
    studentAnswer?: true
    correct?: true
    score?: true
    remarks?: true
    matched?: true
    matchConfidence?: true
    positionX?: true
    positionY?: true
    continuedFrom?: true
    continuedTo?: true
    createdAt?: true
  }

  export type PageAnswerMaxAggregateInputType = {
    id?: true
    pageId?: true
    questionNumber?: true
    studentAnswer?: true
    correct?: true
    score?: true
    remarks?: true
    matched?: true
    matchConfidence?: true
    positionX?: true
    positionY?: true
    continuedFrom?: true
    continuedTo?: true
    createdAt?: true
  }

  export type PageAnswerCountAggregateInputType = {
    id?: true
    pageId?: true
    questionNumber?: true
    studentAnswer?: true
    correct?: true
    score?: true
    remarks?: true
    matched?: true
    matchConfidence?: true
    positionX?: true
    positionY?: true
    continuedFrom?: true
    continuedTo?: true
    createdAt?: true
    _all?: true
  }

  export type PageAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageAnswer to aggregate.
     */
    where?: PageAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageAnswers to fetch.
     */
    orderBy?: PageAnswerOrderByWithRelationInput | PageAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageAnswers
    **/
    _count?: true | PageAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageAnswerMaxAggregateInputType
  }

  export type GetPageAnswerAggregateType<T extends PageAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregatePageAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageAnswer[P]>
      : GetScalarType<T[P], AggregatePageAnswer[P]>
  }




  export type PageAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageAnswerWhereInput
    orderBy?: PageAnswerOrderByWithAggregationInput | PageAnswerOrderByWithAggregationInput[]
    by: PageAnswerScalarFieldEnum[] | PageAnswerScalarFieldEnum
    having?: PageAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageAnswerCountAggregateInputType | true
    _avg?: PageAnswerAvgAggregateInputType
    _sum?: PageAnswerSumAggregateInputType
    _min?: PageAnswerMinAggregateInputType
    _max?: PageAnswerMaxAggregateInputType
  }

  export type PageAnswerGroupByOutputType = {
    id: string
    pageId: string
    questionNumber: string
    studentAnswer: string | null
    correct: boolean
    score: string
    remarks: string
    matched: boolean
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    continuedFrom: number | null
    continuedTo: number | null
    createdAt: Date
    _count: PageAnswerCountAggregateOutputType | null
    _avg: PageAnswerAvgAggregateOutputType | null
    _sum: PageAnswerSumAggregateOutputType | null
    _min: PageAnswerMinAggregateOutputType | null
    _max: PageAnswerMaxAggregateOutputType | null
  }

  type GetPageAnswerGroupByPayload<T extends PageAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], PageAnswerGroupByOutputType[P]>
        }
      >
    >


  export type PageAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    questionNumber?: boolean
    studentAnswer?: boolean
    correct?: boolean
    score?: boolean
    remarks?: boolean
    matched?: boolean
    matchConfidence?: boolean
    positionX?: boolean
    positionY?: boolean
    continuedFrom?: boolean
    continuedTo?: boolean
    createdAt?: boolean
    page?: boolean | GradingPageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageAnswer"]>

  export type PageAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    questionNumber?: boolean
    studentAnswer?: boolean
    correct?: boolean
    score?: boolean
    remarks?: boolean
    matched?: boolean
    matchConfidence?: boolean
    positionX?: boolean
    positionY?: boolean
    continuedFrom?: boolean
    continuedTo?: boolean
    createdAt?: boolean
    page?: boolean | GradingPageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageAnswer"]>

  export type PageAnswerSelectScalar = {
    id?: boolean
    pageId?: boolean
    questionNumber?: boolean
    studentAnswer?: boolean
    correct?: boolean
    score?: boolean
    remarks?: boolean
    matched?: boolean
    matchConfidence?: boolean
    positionX?: boolean
    positionY?: boolean
    continuedFrom?: boolean
    continuedTo?: boolean
    createdAt?: boolean
  }

  export type PageAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | GradingPageDefaultArgs<ExtArgs>
  }
  export type PageAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | GradingPageDefaultArgs<ExtArgs>
  }

  export type $PageAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageAnswer"
    objects: {
      page: Prisma.$GradingPagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageId: string
      questionNumber: string
      studentAnswer: string | null
      correct: boolean
      score: string
      remarks: string
      matched: boolean
      matchConfidence: number | null
      positionX: number | null
      positionY: number | null
      continuedFrom: number | null
      continuedTo: number | null
      createdAt: Date
    }, ExtArgs["result"]["pageAnswer"]>
    composites: {}
  }

  type PageAnswerGetPayload<S extends boolean | null | undefined | PageAnswerDefaultArgs> = $Result.GetResult<Prisma.$PageAnswerPayload, S>

  type PageAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PageAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PageAnswerCountAggregateInputType | true
    }

  export interface PageAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageAnswer'], meta: { name: 'PageAnswer' } }
    /**
     * Find zero or one PageAnswer that matches the filter.
     * @param {PageAnswerFindUniqueArgs} args - Arguments to find a PageAnswer
     * @example
     * // Get one PageAnswer
     * const pageAnswer = await prisma.pageAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageAnswerFindUniqueArgs>(args: SelectSubset<T, PageAnswerFindUniqueArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PageAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PageAnswerFindUniqueOrThrowArgs} args - Arguments to find a PageAnswer
     * @example
     * // Get one PageAnswer
     * const pageAnswer = await prisma.pageAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, PageAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PageAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAnswerFindFirstArgs} args - Arguments to find a PageAnswer
     * @example
     * // Get one PageAnswer
     * const pageAnswer = await prisma.pageAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageAnswerFindFirstArgs>(args?: SelectSubset<T, PageAnswerFindFirstArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PageAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAnswerFindFirstOrThrowArgs} args - Arguments to find a PageAnswer
     * @example
     * // Get one PageAnswer
     * const pageAnswer = await prisma.pageAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, PageAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PageAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageAnswers
     * const pageAnswers = await prisma.pageAnswer.findMany()
     * 
     * // Get first 10 PageAnswers
     * const pageAnswers = await prisma.pageAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageAnswerWithIdOnly = await prisma.pageAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageAnswerFindManyArgs>(args?: SelectSubset<T, PageAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PageAnswer.
     * @param {PageAnswerCreateArgs} args - Arguments to create a PageAnswer.
     * @example
     * // Create one PageAnswer
     * const PageAnswer = await prisma.pageAnswer.create({
     *   data: {
     *     // ... data to create a PageAnswer
     *   }
     * })
     * 
     */
    create<T extends PageAnswerCreateArgs>(args: SelectSubset<T, PageAnswerCreateArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PageAnswers.
     * @param {PageAnswerCreateManyArgs} args - Arguments to create many PageAnswers.
     * @example
     * // Create many PageAnswers
     * const pageAnswer = await prisma.pageAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageAnswerCreateManyArgs>(args?: SelectSubset<T, PageAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageAnswers and returns the data saved in the database.
     * @param {PageAnswerCreateManyAndReturnArgs} args - Arguments to create many PageAnswers.
     * @example
     * // Create many PageAnswers
     * const pageAnswer = await prisma.pageAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageAnswers and only return the `id`
     * const pageAnswerWithIdOnly = await prisma.pageAnswer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, PageAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PageAnswer.
     * @param {PageAnswerDeleteArgs} args - Arguments to delete one PageAnswer.
     * @example
     * // Delete one PageAnswer
     * const PageAnswer = await prisma.pageAnswer.delete({
     *   where: {
     *     // ... filter to delete one PageAnswer
     *   }
     * })
     * 
     */
    delete<T extends PageAnswerDeleteArgs>(args: SelectSubset<T, PageAnswerDeleteArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PageAnswer.
     * @param {PageAnswerUpdateArgs} args - Arguments to update one PageAnswer.
     * @example
     * // Update one PageAnswer
     * const pageAnswer = await prisma.pageAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageAnswerUpdateArgs>(args: SelectSubset<T, PageAnswerUpdateArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PageAnswers.
     * @param {PageAnswerDeleteManyArgs} args - Arguments to filter PageAnswers to delete.
     * @example
     * // Delete a few PageAnswers
     * const { count } = await prisma.pageAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageAnswerDeleteManyArgs>(args?: SelectSubset<T, PageAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageAnswers
     * const pageAnswer = await prisma.pageAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageAnswerUpdateManyArgs>(args: SelectSubset<T, PageAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PageAnswer.
     * @param {PageAnswerUpsertArgs} args - Arguments to update or create a PageAnswer.
     * @example
     * // Update or create a PageAnswer
     * const pageAnswer = await prisma.pageAnswer.upsert({
     *   create: {
     *     // ... data to create a PageAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageAnswer we want to update
     *   }
     * })
     */
    upsert<T extends PageAnswerUpsertArgs>(args: SelectSubset<T, PageAnswerUpsertArgs<ExtArgs>>): Prisma__PageAnswerClient<$Result.GetResult<Prisma.$PageAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PageAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAnswerCountArgs} args - Arguments to filter PageAnswers to count.
     * @example
     * // Count the number of PageAnswers
     * const count = await prisma.pageAnswer.count({
     *   where: {
     *     // ... the filter for the PageAnswers we want to count
     *   }
     * })
    **/
    count<T extends PageAnswerCountArgs>(
      args?: Subset<T, PageAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAnswerAggregateArgs>(args: Subset<T, PageAnswerAggregateArgs>): Prisma.PrismaPromise<GetPageAnswerAggregateType<T>>

    /**
     * Group by PageAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageAnswerGroupByArgs['orderBy'] }
        : { orderBy?: PageAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageAnswer model
   */
  readonly fields: PageAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends GradingPageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradingPageDefaultArgs<ExtArgs>>): Prisma__GradingPageClient<$Result.GetResult<Prisma.$GradingPagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageAnswer model
   */ 
  interface PageAnswerFieldRefs {
    readonly id: FieldRef<"PageAnswer", 'String'>
    readonly pageId: FieldRef<"PageAnswer", 'String'>
    readonly questionNumber: FieldRef<"PageAnswer", 'String'>
    readonly studentAnswer: FieldRef<"PageAnswer", 'String'>
    readonly correct: FieldRef<"PageAnswer", 'Boolean'>
    readonly score: FieldRef<"PageAnswer", 'String'>
    readonly remarks: FieldRef<"PageAnswer", 'String'>
    readonly matched: FieldRef<"PageAnswer", 'Boolean'>
    readonly matchConfidence: FieldRef<"PageAnswer", 'Float'>
    readonly positionX: FieldRef<"PageAnswer", 'Float'>
    readonly positionY: FieldRef<"PageAnswer", 'Float'>
    readonly continuedFrom: FieldRef<"PageAnswer", 'Int'>
    readonly continuedTo: FieldRef<"PageAnswer", 'Int'>
    readonly createdAt: FieldRef<"PageAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageAnswer findUnique
   */
  export type PageAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PageAnswer to fetch.
     */
    where: PageAnswerWhereUniqueInput
  }

  /**
   * PageAnswer findUniqueOrThrow
   */
  export type PageAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PageAnswer to fetch.
     */
    where: PageAnswerWhereUniqueInput
  }

  /**
   * PageAnswer findFirst
   */
  export type PageAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PageAnswer to fetch.
     */
    where?: PageAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageAnswers to fetch.
     */
    orderBy?: PageAnswerOrderByWithRelationInput | PageAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageAnswers.
     */
    cursor?: PageAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageAnswers.
     */
    distinct?: PageAnswerScalarFieldEnum | PageAnswerScalarFieldEnum[]
  }

  /**
   * PageAnswer findFirstOrThrow
   */
  export type PageAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PageAnswer to fetch.
     */
    where?: PageAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageAnswers to fetch.
     */
    orderBy?: PageAnswerOrderByWithRelationInput | PageAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageAnswers.
     */
    cursor?: PageAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageAnswers.
     */
    distinct?: PageAnswerScalarFieldEnum | PageAnswerScalarFieldEnum[]
  }

  /**
   * PageAnswer findMany
   */
  export type PageAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * Filter, which PageAnswers to fetch.
     */
    where?: PageAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageAnswers to fetch.
     */
    orderBy?: PageAnswerOrderByWithRelationInput | PageAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageAnswers.
     */
    cursor?: PageAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageAnswers.
     */
    skip?: number
    distinct?: PageAnswerScalarFieldEnum | PageAnswerScalarFieldEnum[]
  }

  /**
   * PageAnswer create
   */
  export type PageAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a PageAnswer.
     */
    data: XOR<PageAnswerCreateInput, PageAnswerUncheckedCreateInput>
  }

  /**
   * PageAnswer createMany
   */
  export type PageAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageAnswers.
     */
    data: PageAnswerCreateManyInput | PageAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageAnswer createManyAndReturn
   */
  export type PageAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PageAnswers.
     */
    data: PageAnswerCreateManyInput | PageAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageAnswer update
   */
  export type PageAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a PageAnswer.
     */
    data: XOR<PageAnswerUpdateInput, PageAnswerUncheckedUpdateInput>
    /**
     * Choose, which PageAnswer to update.
     */
    where: PageAnswerWhereUniqueInput
  }

  /**
   * PageAnswer updateMany
   */
  export type PageAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageAnswers.
     */
    data: XOR<PageAnswerUpdateManyMutationInput, PageAnswerUncheckedUpdateManyInput>
    /**
     * Filter which PageAnswers to update
     */
    where?: PageAnswerWhereInput
  }

  /**
   * PageAnswer upsert
   */
  export type PageAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the PageAnswer to update in case it exists.
     */
    where: PageAnswerWhereUniqueInput
    /**
     * In case the PageAnswer found by the `where` argument doesn't exist, create a new PageAnswer with this data.
     */
    create: XOR<PageAnswerCreateInput, PageAnswerUncheckedCreateInput>
    /**
     * In case the PageAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageAnswerUpdateInput, PageAnswerUncheckedUpdateInput>
  }

  /**
   * PageAnswer delete
   */
  export type PageAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
    /**
     * Filter which PageAnswer to delete.
     */
    where: PageAnswerWhereUniqueInput
  }

  /**
   * PageAnswer deleteMany
   */
  export type PageAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageAnswers to delete
     */
    where?: PageAnswerWhereInput
  }

  /**
   * PageAnswer without action
   */
  export type PageAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageAnswer
     */
    select?: PageAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Answer
   */

  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerAvgAggregateOutputType = {
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
  }

  export type AnswerSumAggregateOutputType = {
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
  }

  export type AnswerMinAggregateOutputType = {
    id: string | null
    gradingId: string | null
    questionNumber: string | null
    studentAnswer: string | null
    correct: boolean | null
    score: string | null
    remarks: string | null
    matched: boolean | null
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    createdAt: Date | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: string | null
    gradingId: string | null
    questionNumber: string | null
    studentAnswer: string | null
    correct: boolean | null
    score: string | null
    remarks: string | null
    matched: boolean | null
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    createdAt: Date | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    gradingId: number
    questionNumber: number
    studentAnswer: number
    correct: number
    score: number
    remarks: number
    matched: number
    matchConfidence: number
    positionX: number
    positionY: number
    createdAt: number
    _all: number
  }


  export type AnswerAvgAggregateInputType = {
    matchConfidence?: true
    positionX?: true
    positionY?: true
  }

  export type AnswerSumAggregateInputType = {
    matchConfidence?: true
    positionX?: true
    positionY?: true
  }

  export type AnswerMinAggregateInputType = {
    id?: true
    gradingId?: true
    questionNumber?: true
    studentAnswer?: true
    correct?: true
    score?: true
    remarks?: true
    matched?: true
    matchConfidence?: true
    positionX?: true
    positionY?: true
    createdAt?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    gradingId?: true
    questionNumber?: true
    studentAnswer?: true
    correct?: true
    score?: true
    remarks?: true
    matched?: true
    matchConfidence?: true
    positionX?: true
    positionY?: true
    createdAt?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    gradingId?: true
    questionNumber?: true
    studentAnswer?: true
    correct?: true
    score?: true
    remarks?: true
    matched?: true
    matchConfidence?: true
    positionX?: true
    positionY?: true
    createdAt?: true
    _all?: true
  }

  export type AnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer to aggregate.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithAggregationInput | AnswerOrderByWithAggregationInput[]
    by: AnswerScalarFieldEnum[] | AnswerScalarFieldEnum
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _avg?: AnswerAvgAggregateInputType
    _sum?: AnswerSumAggregateInputType
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }

  export type AnswerGroupByOutputType = {
    id: string
    gradingId: string
    questionNumber: string
    studentAnswer: string | null
    correct: boolean
    score: string
    remarks: string
    matched: boolean
    matchConfidence: number | null
    positionX: number | null
    positionY: number | null
    createdAt: Date
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradingId?: boolean
    questionNumber?: boolean
    studentAnswer?: boolean
    correct?: boolean
    score?: boolean
    remarks?: boolean
    matched?: boolean
    matchConfidence?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    grading?: boolean | GradingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradingId?: boolean
    questionNumber?: boolean
    studentAnswer?: boolean
    correct?: boolean
    score?: boolean
    remarks?: boolean
    matched?: boolean
    matchConfidence?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    grading?: boolean | GradingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectScalar = {
    id?: boolean
    gradingId?: boolean
    questionNumber?: boolean
    studentAnswer?: boolean
    correct?: boolean
    score?: boolean
    remarks?: boolean
    matched?: boolean
    matchConfidence?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
  }

  export type AnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grading?: boolean | GradingDefaultArgs<ExtArgs>
  }
  export type AnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grading?: boolean | GradingDefaultArgs<ExtArgs>
  }

  export type $AnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answer"
    objects: {
      grading: Prisma.$GradingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gradingId: string
      questionNumber: string
      studentAnswer: string | null
      correct: boolean
      score: string
      remarks: string
      matched: boolean
      matchConfidence: number | null
      positionX: number | null
      positionY: number | null
      createdAt: Date
    }, ExtArgs["result"]["answer"]>
    composites: {}
  }

  type AnswerGetPayload<S extends boolean | null | undefined | AnswerDefaultArgs> = $Result.GetResult<Prisma.$AnswerPayload, S>

  type AnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnswerCountAggregateInputType | true
    }

  export interface AnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answer'], meta: { name: 'Answer' } }
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerFindUniqueArgs>(args: SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Answer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerFindFirstArgs>(args?: SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Answer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswerFindManyArgs>(args?: SelectSubset<T, AnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
     */
    create<T extends AnswerCreateArgs>(args: SelectSubset<T, AnswerCreateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Answers.
     * @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswerCreateManyArgs>(args?: SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answers and returns the data saved in the database.
     * @param {AnswerCreateManyAndReturnArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answers and only return the `id`
     * const answerWithIdOnly = await prisma.answer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, AnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
     */
    delete<T extends AnswerDeleteArgs>(args: SelectSubset<T, AnswerDeleteArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswerUpdateArgs>(args: SelectSubset<T, AnswerUpdateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswerDeleteManyArgs>(args?: SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswerUpdateManyArgs>(args: SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
     */
    upsert<T extends AnswerUpsertArgs>(args: SelectSubset<T, AnswerUpsertArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): Prisma.PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answer model
   */
  readonly fields: AnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grading<T extends GradingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradingDefaultArgs<ExtArgs>>): Prisma__GradingClient<$Result.GetResult<Prisma.$GradingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answer model
   */ 
  interface AnswerFieldRefs {
    readonly id: FieldRef<"Answer", 'String'>
    readonly gradingId: FieldRef<"Answer", 'String'>
    readonly questionNumber: FieldRef<"Answer", 'String'>
    readonly studentAnswer: FieldRef<"Answer", 'String'>
    readonly correct: FieldRef<"Answer", 'Boolean'>
    readonly score: FieldRef<"Answer", 'String'>
    readonly remarks: FieldRef<"Answer", 'String'>
    readonly matched: FieldRef<"Answer", 'Boolean'>
    readonly matchConfidence: FieldRef<"Answer", 'Float'>
    readonly positionX: FieldRef<"Answer", 'Float'>
    readonly positionY: FieldRef<"Answer", 'Float'>
    readonly createdAt: FieldRef<"Answer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer create
   */
  export type AnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a Answer.
     */
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }

  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answer createManyAndReturn
   */
  export type AnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer update
   */
  export type AnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a Answer.
     */
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
  }

  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the Answer to update in case it exists.
     */
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     */
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }

  /**
   * Answer delete
   */
  export type AnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter which Answer to delete.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswerWhereInput
  }

  /**
   * Answer without action
   */
  export type AnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
  }


  /**
   * Model Doubt
   */

  export type AggregateDoubt = {
    _count: DoubtCountAggregateOutputType | null
    _avg: DoubtAvgAggregateOutputType | null
    _sum: DoubtSumAggregateOutputType | null
    _min: DoubtMinAggregateOutputType | null
    _max: DoubtMaxAggregateOutputType | null
  }

  export type DoubtAvgAggregateOutputType = {
    questionNumber: number | null
    messageCount: number | null
  }

  export type DoubtSumAggregateOutputType = {
    questionNumber: number | null
    messageCount: number | null
  }

  export type DoubtMinAggregateOutputType = {
    id: string | null
    userId: string | null
    questionImage: string | null
    questionText: string | null
    subject: string | null
    language: string | null
    explanation: string | null
    annotations: string | null
    imageDimensions: string | null
    conversationId: string | null
    worksheetId: string | null
    questionNumber: number | null
    isInRevision: boolean | null
    addedToRevisionAt: Date | null
    isFavorite: boolean | null
    messageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoubtMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    questionImage: string | null
    questionText: string | null
    subject: string | null
    language: string | null
    explanation: string | null
    annotations: string | null
    imageDimensions: string | null
    conversationId: string | null
    worksheetId: string | null
    questionNumber: number | null
    isInRevision: boolean | null
    addedToRevisionAt: Date | null
    isFavorite: boolean | null
    messageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoubtCountAggregateOutputType = {
    id: number
    userId: number
    questionImage: number
    questionText: number
    subject: number
    language: number
    explanation: number
    annotations: number
    imageDimensions: number
    conversationId: number
    worksheetId: number
    questionNumber: number
    isInRevision: number
    addedToRevisionAt: number
    isFavorite: number
    messageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DoubtAvgAggregateInputType = {
    questionNumber?: true
    messageCount?: true
  }

  export type DoubtSumAggregateInputType = {
    questionNumber?: true
    messageCount?: true
  }

  export type DoubtMinAggregateInputType = {
    id?: true
    userId?: true
    questionImage?: true
    questionText?: true
    subject?: true
    language?: true
    explanation?: true
    annotations?: true
    imageDimensions?: true
    conversationId?: true
    worksheetId?: true
    questionNumber?: true
    isInRevision?: true
    addedToRevisionAt?: true
    isFavorite?: true
    messageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoubtMaxAggregateInputType = {
    id?: true
    userId?: true
    questionImage?: true
    questionText?: true
    subject?: true
    language?: true
    explanation?: true
    annotations?: true
    imageDimensions?: true
    conversationId?: true
    worksheetId?: true
    questionNumber?: true
    isInRevision?: true
    addedToRevisionAt?: true
    isFavorite?: true
    messageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoubtCountAggregateInputType = {
    id?: true
    userId?: true
    questionImage?: true
    questionText?: true
    subject?: true
    language?: true
    explanation?: true
    annotations?: true
    imageDimensions?: true
    conversationId?: true
    worksheetId?: true
    questionNumber?: true
    isInRevision?: true
    addedToRevisionAt?: true
    isFavorite?: true
    messageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DoubtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doubt to aggregate.
     */
    where?: DoubtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doubts to fetch.
     */
    orderBy?: DoubtOrderByWithRelationInput | DoubtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoubtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doubts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doubts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doubts
    **/
    _count?: true | DoubtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoubtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoubtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoubtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoubtMaxAggregateInputType
  }

  export type GetDoubtAggregateType<T extends DoubtAggregateArgs> = {
        [P in keyof T & keyof AggregateDoubt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoubt[P]>
      : GetScalarType<T[P], AggregateDoubt[P]>
  }




  export type DoubtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoubtWhereInput
    orderBy?: DoubtOrderByWithAggregationInput | DoubtOrderByWithAggregationInput[]
    by: DoubtScalarFieldEnum[] | DoubtScalarFieldEnum
    having?: DoubtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoubtCountAggregateInputType | true
    _avg?: DoubtAvgAggregateInputType
    _sum?: DoubtSumAggregateInputType
    _min?: DoubtMinAggregateInputType
    _max?: DoubtMaxAggregateInputType
  }

  export type DoubtGroupByOutputType = {
    id: string
    userId: string | null
    questionImage: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations: string | null
    imageDimensions: string | null
    conversationId: string
    worksheetId: string | null
    questionNumber: number | null
    isInRevision: boolean
    addedToRevisionAt: Date | null
    isFavorite: boolean
    messageCount: number
    createdAt: Date
    updatedAt: Date
    _count: DoubtCountAggregateOutputType | null
    _avg: DoubtAvgAggregateOutputType | null
    _sum: DoubtSumAggregateOutputType | null
    _min: DoubtMinAggregateOutputType | null
    _max: DoubtMaxAggregateOutputType | null
  }

  type GetDoubtGroupByPayload<T extends DoubtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoubtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoubtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoubtGroupByOutputType[P]>
            : GetScalarType<T[P], DoubtGroupByOutputType[P]>
        }
      >
    >


  export type DoubtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionImage?: boolean
    questionText?: boolean
    subject?: boolean
    language?: boolean
    explanation?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    conversationId?: boolean
    worksheetId?: boolean
    questionNumber?: boolean
    isInRevision?: boolean
    addedToRevisionAt?: boolean
    isFavorite?: boolean
    messageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Doubt$userArgs<ExtArgs>
    messages?: boolean | Doubt$messagesArgs<ExtArgs>
    worksheet?: boolean | Doubt$worksheetArgs<ExtArgs>
    worksheetQuestions?: boolean | Doubt$worksheetQuestionsArgs<ExtArgs>
    rating?: boolean | Doubt$ratingArgs<ExtArgs>
    _count?: boolean | DoubtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doubt"]>

  export type DoubtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionImage?: boolean
    questionText?: boolean
    subject?: boolean
    language?: boolean
    explanation?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    conversationId?: boolean
    worksheetId?: boolean
    questionNumber?: boolean
    isInRevision?: boolean
    addedToRevisionAt?: boolean
    isFavorite?: boolean
    messageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Doubt$userArgs<ExtArgs>
    worksheet?: boolean | Doubt$worksheetArgs<ExtArgs>
  }, ExtArgs["result"]["doubt"]>

  export type DoubtSelectScalar = {
    id?: boolean
    userId?: boolean
    questionImage?: boolean
    questionText?: boolean
    subject?: boolean
    language?: boolean
    explanation?: boolean
    annotations?: boolean
    imageDimensions?: boolean
    conversationId?: boolean
    worksheetId?: boolean
    questionNumber?: boolean
    isInRevision?: boolean
    addedToRevisionAt?: boolean
    isFavorite?: boolean
    messageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DoubtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Doubt$userArgs<ExtArgs>
    messages?: boolean | Doubt$messagesArgs<ExtArgs>
    worksheet?: boolean | Doubt$worksheetArgs<ExtArgs>
    worksheetQuestions?: boolean | Doubt$worksheetQuestionsArgs<ExtArgs>
    rating?: boolean | Doubt$ratingArgs<ExtArgs>
    _count?: boolean | DoubtCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoubtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Doubt$userArgs<ExtArgs>
    worksheet?: boolean | Doubt$worksheetArgs<ExtArgs>
  }

  export type $DoubtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doubt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$DoubtMessagePayload<ExtArgs>[]
      worksheet: Prisma.$WorksheetPayload<ExtArgs> | null
      worksheetQuestions: Prisma.$WorksheetQuestionPayload<ExtArgs>[]
      rating: Prisma.$DoubtRatingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      questionImage: string | null
      questionText: string
      subject: string
      language: string
      explanation: string
      annotations: string | null
      imageDimensions: string | null
      conversationId: string
      worksheetId: string | null
      questionNumber: number | null
      isInRevision: boolean
      addedToRevisionAt: Date | null
      isFavorite: boolean
      messageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["doubt"]>
    composites: {}
  }

  type DoubtGetPayload<S extends boolean | null | undefined | DoubtDefaultArgs> = $Result.GetResult<Prisma.$DoubtPayload, S>

  type DoubtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoubtFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoubtCountAggregateInputType | true
    }

  export interface DoubtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doubt'], meta: { name: 'Doubt' } }
    /**
     * Find zero or one Doubt that matches the filter.
     * @param {DoubtFindUniqueArgs} args - Arguments to find a Doubt
     * @example
     * // Get one Doubt
     * const doubt = await prisma.doubt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoubtFindUniqueArgs>(args: SelectSubset<T, DoubtFindUniqueArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Doubt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoubtFindUniqueOrThrowArgs} args - Arguments to find a Doubt
     * @example
     * // Get one Doubt
     * const doubt = await prisma.doubt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoubtFindUniqueOrThrowArgs>(args: SelectSubset<T, DoubtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Doubt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtFindFirstArgs} args - Arguments to find a Doubt
     * @example
     * // Get one Doubt
     * const doubt = await prisma.doubt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoubtFindFirstArgs>(args?: SelectSubset<T, DoubtFindFirstArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Doubt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtFindFirstOrThrowArgs} args - Arguments to find a Doubt
     * @example
     * // Get one Doubt
     * const doubt = await prisma.doubt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoubtFindFirstOrThrowArgs>(args?: SelectSubset<T, DoubtFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Doubts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doubts
     * const doubts = await prisma.doubt.findMany()
     * 
     * // Get first 10 Doubts
     * const doubts = await prisma.doubt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doubtWithIdOnly = await prisma.doubt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoubtFindManyArgs>(args?: SelectSubset<T, DoubtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Doubt.
     * @param {DoubtCreateArgs} args - Arguments to create a Doubt.
     * @example
     * // Create one Doubt
     * const Doubt = await prisma.doubt.create({
     *   data: {
     *     // ... data to create a Doubt
     *   }
     * })
     * 
     */
    create<T extends DoubtCreateArgs>(args: SelectSubset<T, DoubtCreateArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Doubts.
     * @param {DoubtCreateManyArgs} args - Arguments to create many Doubts.
     * @example
     * // Create many Doubts
     * const doubt = await prisma.doubt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoubtCreateManyArgs>(args?: SelectSubset<T, DoubtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doubts and returns the data saved in the database.
     * @param {DoubtCreateManyAndReturnArgs} args - Arguments to create many Doubts.
     * @example
     * // Create many Doubts
     * const doubt = await prisma.doubt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doubts and only return the `id`
     * const doubtWithIdOnly = await prisma.doubt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoubtCreateManyAndReturnArgs>(args?: SelectSubset<T, DoubtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Doubt.
     * @param {DoubtDeleteArgs} args - Arguments to delete one Doubt.
     * @example
     * // Delete one Doubt
     * const Doubt = await prisma.doubt.delete({
     *   where: {
     *     // ... filter to delete one Doubt
     *   }
     * })
     * 
     */
    delete<T extends DoubtDeleteArgs>(args: SelectSubset<T, DoubtDeleteArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Doubt.
     * @param {DoubtUpdateArgs} args - Arguments to update one Doubt.
     * @example
     * // Update one Doubt
     * const doubt = await prisma.doubt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoubtUpdateArgs>(args: SelectSubset<T, DoubtUpdateArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Doubts.
     * @param {DoubtDeleteManyArgs} args - Arguments to filter Doubts to delete.
     * @example
     * // Delete a few Doubts
     * const { count } = await prisma.doubt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoubtDeleteManyArgs>(args?: SelectSubset<T, DoubtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doubts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doubts
     * const doubt = await prisma.doubt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoubtUpdateManyArgs>(args: SelectSubset<T, DoubtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doubt.
     * @param {DoubtUpsertArgs} args - Arguments to update or create a Doubt.
     * @example
     * // Update or create a Doubt
     * const doubt = await prisma.doubt.upsert({
     *   create: {
     *     // ... data to create a Doubt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doubt we want to update
     *   }
     * })
     */
    upsert<T extends DoubtUpsertArgs>(args: SelectSubset<T, DoubtUpsertArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Doubts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtCountArgs} args - Arguments to filter Doubts to count.
     * @example
     * // Count the number of Doubts
     * const count = await prisma.doubt.count({
     *   where: {
     *     // ... the filter for the Doubts we want to count
     *   }
     * })
    **/
    count<T extends DoubtCountArgs>(
      args?: Subset<T, DoubtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoubtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doubt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoubtAggregateArgs>(args: Subset<T, DoubtAggregateArgs>): Prisma.PrismaPromise<GetDoubtAggregateType<T>>

    /**
     * Group by Doubt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoubtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoubtGroupByArgs['orderBy'] }
        : { orderBy?: DoubtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoubtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoubtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doubt model
   */
  readonly fields: DoubtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doubt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoubtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Doubt$userArgs<ExtArgs> = {}>(args?: Subset<T, Doubt$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messages<T extends Doubt$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Doubt$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "findMany"> | Null>
    worksheet<T extends Doubt$worksheetArgs<ExtArgs> = {}>(args?: Subset<T, Doubt$worksheetArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    worksheetQuestions<T extends Doubt$worksheetQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Doubt$worksheetQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    rating<T extends Doubt$ratingArgs<ExtArgs> = {}>(args?: Subset<T, Doubt$ratingArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doubt model
   */ 
  interface DoubtFieldRefs {
    readonly id: FieldRef<"Doubt", 'String'>
    readonly userId: FieldRef<"Doubt", 'String'>
    readonly questionImage: FieldRef<"Doubt", 'String'>
    readonly questionText: FieldRef<"Doubt", 'String'>
    readonly subject: FieldRef<"Doubt", 'String'>
    readonly language: FieldRef<"Doubt", 'String'>
    readonly explanation: FieldRef<"Doubt", 'String'>
    readonly annotations: FieldRef<"Doubt", 'String'>
    readonly imageDimensions: FieldRef<"Doubt", 'String'>
    readonly conversationId: FieldRef<"Doubt", 'String'>
    readonly worksheetId: FieldRef<"Doubt", 'String'>
    readonly questionNumber: FieldRef<"Doubt", 'Int'>
    readonly isInRevision: FieldRef<"Doubt", 'Boolean'>
    readonly addedToRevisionAt: FieldRef<"Doubt", 'DateTime'>
    readonly isFavorite: FieldRef<"Doubt", 'Boolean'>
    readonly messageCount: FieldRef<"Doubt", 'Int'>
    readonly createdAt: FieldRef<"Doubt", 'DateTime'>
    readonly updatedAt: FieldRef<"Doubt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Doubt findUnique
   */
  export type DoubtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * Filter, which Doubt to fetch.
     */
    where: DoubtWhereUniqueInput
  }

  /**
   * Doubt findUniqueOrThrow
   */
  export type DoubtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * Filter, which Doubt to fetch.
     */
    where: DoubtWhereUniqueInput
  }

  /**
   * Doubt findFirst
   */
  export type DoubtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * Filter, which Doubt to fetch.
     */
    where?: DoubtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doubts to fetch.
     */
    orderBy?: DoubtOrderByWithRelationInput | DoubtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doubts.
     */
    cursor?: DoubtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doubts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doubts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doubts.
     */
    distinct?: DoubtScalarFieldEnum | DoubtScalarFieldEnum[]
  }

  /**
   * Doubt findFirstOrThrow
   */
  export type DoubtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * Filter, which Doubt to fetch.
     */
    where?: DoubtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doubts to fetch.
     */
    orderBy?: DoubtOrderByWithRelationInput | DoubtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doubts.
     */
    cursor?: DoubtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doubts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doubts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doubts.
     */
    distinct?: DoubtScalarFieldEnum | DoubtScalarFieldEnum[]
  }

  /**
   * Doubt findMany
   */
  export type DoubtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * Filter, which Doubts to fetch.
     */
    where?: DoubtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doubts to fetch.
     */
    orderBy?: DoubtOrderByWithRelationInput | DoubtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doubts.
     */
    cursor?: DoubtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doubts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doubts.
     */
    skip?: number
    distinct?: DoubtScalarFieldEnum | DoubtScalarFieldEnum[]
  }

  /**
   * Doubt create
   */
  export type DoubtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * The data needed to create a Doubt.
     */
    data: XOR<DoubtCreateInput, DoubtUncheckedCreateInput>
  }

  /**
   * Doubt createMany
   */
  export type DoubtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doubts.
     */
    data: DoubtCreateManyInput | DoubtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doubt createManyAndReturn
   */
  export type DoubtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Doubts.
     */
    data: DoubtCreateManyInput | DoubtCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doubt update
   */
  export type DoubtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * The data needed to update a Doubt.
     */
    data: XOR<DoubtUpdateInput, DoubtUncheckedUpdateInput>
    /**
     * Choose, which Doubt to update.
     */
    where: DoubtWhereUniqueInput
  }

  /**
   * Doubt updateMany
   */
  export type DoubtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doubts.
     */
    data: XOR<DoubtUpdateManyMutationInput, DoubtUncheckedUpdateManyInput>
    /**
     * Filter which Doubts to update
     */
    where?: DoubtWhereInput
  }

  /**
   * Doubt upsert
   */
  export type DoubtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * The filter to search for the Doubt to update in case it exists.
     */
    where: DoubtWhereUniqueInput
    /**
     * In case the Doubt found by the `where` argument doesn't exist, create a new Doubt with this data.
     */
    create: XOR<DoubtCreateInput, DoubtUncheckedCreateInput>
    /**
     * In case the Doubt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoubtUpdateInput, DoubtUncheckedUpdateInput>
  }

  /**
   * Doubt delete
   */
  export type DoubtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    /**
     * Filter which Doubt to delete.
     */
    where: DoubtWhereUniqueInput
  }

  /**
   * Doubt deleteMany
   */
  export type DoubtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doubts to delete
     */
    where?: DoubtWhereInput
  }

  /**
   * Doubt.user
   */
  export type Doubt$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Doubt.messages
   */
  export type Doubt$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    where?: DoubtMessageWhereInput
    orderBy?: DoubtMessageOrderByWithRelationInput | DoubtMessageOrderByWithRelationInput[]
    cursor?: DoubtMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoubtMessageScalarFieldEnum | DoubtMessageScalarFieldEnum[]
  }

  /**
   * Doubt.worksheet
   */
  export type Doubt$worksheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    where?: WorksheetWhereInput
  }

  /**
   * Doubt.worksheetQuestions
   */
  export type Doubt$worksheetQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    where?: WorksheetQuestionWhereInput
    orderBy?: WorksheetQuestionOrderByWithRelationInput | WorksheetQuestionOrderByWithRelationInput[]
    cursor?: WorksheetQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorksheetQuestionScalarFieldEnum | WorksheetQuestionScalarFieldEnum[]
  }

  /**
   * Doubt.rating
   */
  export type Doubt$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    where?: DoubtRatingWhereInput
  }

  /**
   * Doubt without action
   */
  export type DoubtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
  }


  /**
   * Model DoubtMessage
   */

  export type AggregateDoubtMessage = {
    _count: DoubtMessageCountAggregateOutputType | null
    _min: DoubtMessageMinAggregateOutputType | null
    _max: DoubtMessageMaxAggregateOutputType | null
  }

  export type DoubtMessageMinAggregateOutputType = {
    id: string | null
    doubtId: string | null
    role: string | null
    content: string | null
    audioUrl: string | null
    createdAt: Date | null
  }

  export type DoubtMessageMaxAggregateOutputType = {
    id: string | null
    doubtId: string | null
    role: string | null
    content: string | null
    audioUrl: string | null
    createdAt: Date | null
  }

  export type DoubtMessageCountAggregateOutputType = {
    id: number
    doubtId: number
    role: number
    content: number
    audioUrl: number
    createdAt: number
    _all: number
  }


  export type DoubtMessageMinAggregateInputType = {
    id?: true
    doubtId?: true
    role?: true
    content?: true
    audioUrl?: true
    createdAt?: true
  }

  export type DoubtMessageMaxAggregateInputType = {
    id?: true
    doubtId?: true
    role?: true
    content?: true
    audioUrl?: true
    createdAt?: true
  }

  export type DoubtMessageCountAggregateInputType = {
    id?: true
    doubtId?: true
    role?: true
    content?: true
    audioUrl?: true
    createdAt?: true
    _all?: true
  }

  export type DoubtMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoubtMessage to aggregate.
     */
    where?: DoubtMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtMessages to fetch.
     */
    orderBy?: DoubtMessageOrderByWithRelationInput | DoubtMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoubtMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoubtMessages
    **/
    _count?: true | DoubtMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoubtMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoubtMessageMaxAggregateInputType
  }

  export type GetDoubtMessageAggregateType<T extends DoubtMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDoubtMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoubtMessage[P]>
      : GetScalarType<T[P], AggregateDoubtMessage[P]>
  }




  export type DoubtMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoubtMessageWhereInput
    orderBy?: DoubtMessageOrderByWithAggregationInput | DoubtMessageOrderByWithAggregationInput[]
    by: DoubtMessageScalarFieldEnum[] | DoubtMessageScalarFieldEnum
    having?: DoubtMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoubtMessageCountAggregateInputType | true
    _min?: DoubtMessageMinAggregateInputType
    _max?: DoubtMessageMaxAggregateInputType
  }

  export type DoubtMessageGroupByOutputType = {
    id: string
    doubtId: string
    role: string
    content: string
    audioUrl: string | null
    createdAt: Date
    _count: DoubtMessageCountAggregateOutputType | null
    _min: DoubtMessageMinAggregateOutputType | null
    _max: DoubtMessageMaxAggregateOutputType | null
  }

  type GetDoubtMessageGroupByPayload<T extends DoubtMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoubtMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoubtMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoubtMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DoubtMessageGroupByOutputType[P]>
        }
      >
    >


  export type DoubtMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doubtId?: boolean
    role?: boolean
    content?: boolean
    audioUrl?: boolean
    createdAt?: boolean
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doubtMessage"]>

  export type DoubtMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doubtId?: boolean
    role?: boolean
    content?: boolean
    audioUrl?: boolean
    createdAt?: boolean
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doubtMessage"]>

  export type DoubtMessageSelectScalar = {
    id?: boolean
    doubtId?: boolean
    role?: boolean
    content?: boolean
    audioUrl?: boolean
    createdAt?: boolean
  }

  export type DoubtMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
  }
  export type DoubtMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
  }

  export type $DoubtMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoubtMessage"
    objects: {
      doubt: Prisma.$DoubtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doubtId: string
      role: string
      content: string
      audioUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["doubtMessage"]>
    composites: {}
  }

  type DoubtMessageGetPayload<S extends boolean | null | undefined | DoubtMessageDefaultArgs> = $Result.GetResult<Prisma.$DoubtMessagePayload, S>

  type DoubtMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoubtMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoubtMessageCountAggregateInputType | true
    }

  export interface DoubtMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoubtMessage'], meta: { name: 'DoubtMessage' } }
    /**
     * Find zero or one DoubtMessage that matches the filter.
     * @param {DoubtMessageFindUniqueArgs} args - Arguments to find a DoubtMessage
     * @example
     * // Get one DoubtMessage
     * const doubtMessage = await prisma.doubtMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoubtMessageFindUniqueArgs>(args: SelectSubset<T, DoubtMessageFindUniqueArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoubtMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoubtMessageFindUniqueOrThrowArgs} args - Arguments to find a DoubtMessage
     * @example
     * // Get one DoubtMessage
     * const doubtMessage = await prisma.doubtMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoubtMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DoubtMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoubtMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtMessageFindFirstArgs} args - Arguments to find a DoubtMessage
     * @example
     * // Get one DoubtMessage
     * const doubtMessage = await prisma.doubtMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoubtMessageFindFirstArgs>(args?: SelectSubset<T, DoubtMessageFindFirstArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoubtMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtMessageFindFirstOrThrowArgs} args - Arguments to find a DoubtMessage
     * @example
     * // Get one DoubtMessage
     * const doubtMessage = await prisma.doubtMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoubtMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DoubtMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoubtMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoubtMessages
     * const doubtMessages = await prisma.doubtMessage.findMany()
     * 
     * // Get first 10 DoubtMessages
     * const doubtMessages = await prisma.doubtMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doubtMessageWithIdOnly = await prisma.doubtMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoubtMessageFindManyArgs>(args?: SelectSubset<T, DoubtMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoubtMessage.
     * @param {DoubtMessageCreateArgs} args - Arguments to create a DoubtMessage.
     * @example
     * // Create one DoubtMessage
     * const DoubtMessage = await prisma.doubtMessage.create({
     *   data: {
     *     // ... data to create a DoubtMessage
     *   }
     * })
     * 
     */
    create<T extends DoubtMessageCreateArgs>(args: SelectSubset<T, DoubtMessageCreateArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoubtMessages.
     * @param {DoubtMessageCreateManyArgs} args - Arguments to create many DoubtMessages.
     * @example
     * // Create many DoubtMessages
     * const doubtMessage = await prisma.doubtMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoubtMessageCreateManyArgs>(args?: SelectSubset<T, DoubtMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoubtMessages and returns the data saved in the database.
     * @param {DoubtMessageCreateManyAndReturnArgs} args - Arguments to create many DoubtMessages.
     * @example
     * // Create many DoubtMessages
     * const doubtMessage = await prisma.doubtMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoubtMessages and only return the `id`
     * const doubtMessageWithIdOnly = await prisma.doubtMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoubtMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DoubtMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoubtMessage.
     * @param {DoubtMessageDeleteArgs} args - Arguments to delete one DoubtMessage.
     * @example
     * // Delete one DoubtMessage
     * const DoubtMessage = await prisma.doubtMessage.delete({
     *   where: {
     *     // ... filter to delete one DoubtMessage
     *   }
     * })
     * 
     */
    delete<T extends DoubtMessageDeleteArgs>(args: SelectSubset<T, DoubtMessageDeleteArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoubtMessage.
     * @param {DoubtMessageUpdateArgs} args - Arguments to update one DoubtMessage.
     * @example
     * // Update one DoubtMessage
     * const doubtMessage = await prisma.doubtMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoubtMessageUpdateArgs>(args: SelectSubset<T, DoubtMessageUpdateArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoubtMessages.
     * @param {DoubtMessageDeleteManyArgs} args - Arguments to filter DoubtMessages to delete.
     * @example
     * // Delete a few DoubtMessages
     * const { count } = await prisma.doubtMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoubtMessageDeleteManyArgs>(args?: SelectSubset<T, DoubtMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoubtMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoubtMessages
     * const doubtMessage = await prisma.doubtMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoubtMessageUpdateManyArgs>(args: SelectSubset<T, DoubtMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoubtMessage.
     * @param {DoubtMessageUpsertArgs} args - Arguments to update or create a DoubtMessage.
     * @example
     * // Update or create a DoubtMessage
     * const doubtMessage = await prisma.doubtMessage.upsert({
     *   create: {
     *     // ... data to create a DoubtMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoubtMessage we want to update
     *   }
     * })
     */
    upsert<T extends DoubtMessageUpsertArgs>(args: SelectSubset<T, DoubtMessageUpsertArgs<ExtArgs>>): Prisma__DoubtMessageClient<$Result.GetResult<Prisma.$DoubtMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoubtMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtMessageCountArgs} args - Arguments to filter DoubtMessages to count.
     * @example
     * // Count the number of DoubtMessages
     * const count = await prisma.doubtMessage.count({
     *   where: {
     *     // ... the filter for the DoubtMessages we want to count
     *   }
     * })
    **/
    count<T extends DoubtMessageCountArgs>(
      args?: Subset<T, DoubtMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoubtMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoubtMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoubtMessageAggregateArgs>(args: Subset<T, DoubtMessageAggregateArgs>): Prisma.PrismaPromise<GetDoubtMessageAggregateType<T>>

    /**
     * Group by DoubtMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoubtMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoubtMessageGroupByArgs['orderBy'] }
        : { orderBy?: DoubtMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoubtMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoubtMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoubtMessage model
   */
  readonly fields: DoubtMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoubtMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoubtMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doubt<T extends DoubtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoubtDefaultArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoubtMessage model
   */ 
  interface DoubtMessageFieldRefs {
    readonly id: FieldRef<"DoubtMessage", 'String'>
    readonly doubtId: FieldRef<"DoubtMessage", 'String'>
    readonly role: FieldRef<"DoubtMessage", 'String'>
    readonly content: FieldRef<"DoubtMessage", 'String'>
    readonly audioUrl: FieldRef<"DoubtMessage", 'String'>
    readonly createdAt: FieldRef<"DoubtMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DoubtMessage findUnique
   */
  export type DoubtMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * Filter, which DoubtMessage to fetch.
     */
    where: DoubtMessageWhereUniqueInput
  }

  /**
   * DoubtMessage findUniqueOrThrow
   */
  export type DoubtMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * Filter, which DoubtMessage to fetch.
     */
    where: DoubtMessageWhereUniqueInput
  }

  /**
   * DoubtMessage findFirst
   */
  export type DoubtMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * Filter, which DoubtMessage to fetch.
     */
    where?: DoubtMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtMessages to fetch.
     */
    orderBy?: DoubtMessageOrderByWithRelationInput | DoubtMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoubtMessages.
     */
    cursor?: DoubtMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoubtMessages.
     */
    distinct?: DoubtMessageScalarFieldEnum | DoubtMessageScalarFieldEnum[]
  }

  /**
   * DoubtMessage findFirstOrThrow
   */
  export type DoubtMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * Filter, which DoubtMessage to fetch.
     */
    where?: DoubtMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtMessages to fetch.
     */
    orderBy?: DoubtMessageOrderByWithRelationInput | DoubtMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoubtMessages.
     */
    cursor?: DoubtMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoubtMessages.
     */
    distinct?: DoubtMessageScalarFieldEnum | DoubtMessageScalarFieldEnum[]
  }

  /**
   * DoubtMessage findMany
   */
  export type DoubtMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * Filter, which DoubtMessages to fetch.
     */
    where?: DoubtMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtMessages to fetch.
     */
    orderBy?: DoubtMessageOrderByWithRelationInput | DoubtMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoubtMessages.
     */
    cursor?: DoubtMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtMessages.
     */
    skip?: number
    distinct?: DoubtMessageScalarFieldEnum | DoubtMessageScalarFieldEnum[]
  }

  /**
   * DoubtMessage create
   */
  export type DoubtMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DoubtMessage.
     */
    data: XOR<DoubtMessageCreateInput, DoubtMessageUncheckedCreateInput>
  }

  /**
   * DoubtMessage createMany
   */
  export type DoubtMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoubtMessages.
     */
    data: DoubtMessageCreateManyInput | DoubtMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoubtMessage createManyAndReturn
   */
  export type DoubtMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoubtMessages.
     */
    data: DoubtMessageCreateManyInput | DoubtMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoubtMessage update
   */
  export type DoubtMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DoubtMessage.
     */
    data: XOR<DoubtMessageUpdateInput, DoubtMessageUncheckedUpdateInput>
    /**
     * Choose, which DoubtMessage to update.
     */
    where: DoubtMessageWhereUniqueInput
  }

  /**
   * DoubtMessage updateMany
   */
  export type DoubtMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoubtMessages.
     */
    data: XOR<DoubtMessageUpdateManyMutationInput, DoubtMessageUncheckedUpdateManyInput>
    /**
     * Filter which DoubtMessages to update
     */
    where?: DoubtMessageWhereInput
  }

  /**
   * DoubtMessage upsert
   */
  export type DoubtMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DoubtMessage to update in case it exists.
     */
    where: DoubtMessageWhereUniqueInput
    /**
     * In case the DoubtMessage found by the `where` argument doesn't exist, create a new DoubtMessage with this data.
     */
    create: XOR<DoubtMessageCreateInput, DoubtMessageUncheckedCreateInput>
    /**
     * In case the DoubtMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoubtMessageUpdateInput, DoubtMessageUncheckedUpdateInput>
  }

  /**
   * DoubtMessage delete
   */
  export type DoubtMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
    /**
     * Filter which DoubtMessage to delete.
     */
    where: DoubtMessageWhereUniqueInput
  }

  /**
   * DoubtMessage deleteMany
   */
  export type DoubtMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoubtMessages to delete
     */
    where?: DoubtMessageWhereInput
  }

  /**
   * DoubtMessage without action
   */
  export type DoubtMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtMessage
     */
    select?: DoubtMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtMessageInclude<ExtArgs> | null
  }


  /**
   * Model Worksheet
   */

  export type AggregateWorksheet = {
    _count: WorksheetCountAggregateOutputType | null
    _avg: WorksheetAvgAggregateOutputType | null
    _sum: WorksheetSumAggregateOutputType | null
    _min: WorksheetMinAggregateOutputType | null
    _max: WorksheetMaxAggregateOutputType | null
  }

  export type WorksheetAvgAggregateOutputType = {
    totalQuestions: number | null
    currentQuestion: number | null
  }

  export type WorksheetSumAggregateOutputType = {
    totalQuestions: number | null
    currentQuestion: number | null
  }

  export type WorksheetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    imageHash: string | null
    totalQuestions: number | null
    currentQuestion: number | null
    sessionId: string | null
    expiresAt: Date | null
    title: string | null
    subject: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorksheetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    imageHash: string | null
    totalQuestions: number | null
    currentQuestion: number | null
    sessionId: string | null
    expiresAt: Date | null
    title: string | null
    subject: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorksheetCountAggregateOutputType = {
    id: number
    userId: number
    imageUrl: number
    imageHash: number
    totalQuestions: number
    currentQuestion: number
    sessionId: number
    expiresAt: number
    title: number
    subject: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorksheetAvgAggregateInputType = {
    totalQuestions?: true
    currentQuestion?: true
  }

  export type WorksheetSumAggregateInputType = {
    totalQuestions?: true
    currentQuestion?: true
  }

  export type WorksheetMinAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    imageHash?: true
    totalQuestions?: true
    currentQuestion?: true
    sessionId?: true
    expiresAt?: true
    title?: true
    subject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorksheetMaxAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    imageHash?: true
    totalQuestions?: true
    currentQuestion?: true
    sessionId?: true
    expiresAt?: true
    title?: true
    subject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorksheetCountAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    imageHash?: true
    totalQuestions?: true
    currentQuestion?: true
    sessionId?: true
    expiresAt?: true
    title?: true
    subject?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorksheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worksheet to aggregate.
     */
    where?: WorksheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worksheets to fetch.
     */
    orderBy?: WorksheetOrderByWithRelationInput | WorksheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorksheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worksheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worksheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Worksheets
    **/
    _count?: true | WorksheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorksheetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorksheetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorksheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorksheetMaxAggregateInputType
  }

  export type GetWorksheetAggregateType<T extends WorksheetAggregateArgs> = {
        [P in keyof T & keyof AggregateWorksheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorksheet[P]>
      : GetScalarType<T[P], AggregateWorksheet[P]>
  }




  export type WorksheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorksheetWhereInput
    orderBy?: WorksheetOrderByWithAggregationInput | WorksheetOrderByWithAggregationInput[]
    by: WorksheetScalarFieldEnum[] | WorksheetScalarFieldEnum
    having?: WorksheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorksheetCountAggregateInputType | true
    _avg?: WorksheetAvgAggregateInputType
    _sum?: WorksheetSumAggregateInputType
    _min?: WorksheetMinAggregateInputType
    _max?: WorksheetMaxAggregateInputType
  }

  export type WorksheetGroupByOutputType = {
    id: string
    userId: string | null
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion: number
    sessionId: string
    expiresAt: Date
    title: string | null
    subject: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorksheetCountAggregateOutputType | null
    _avg: WorksheetAvgAggregateOutputType | null
    _sum: WorksheetSumAggregateOutputType | null
    _min: WorksheetMinAggregateOutputType | null
    _max: WorksheetMaxAggregateOutputType | null
  }

  type GetWorksheetGroupByPayload<T extends WorksheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorksheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorksheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorksheetGroupByOutputType[P]>
            : GetScalarType<T[P], WorksheetGroupByOutputType[P]>
        }
      >
    >


  export type WorksheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    imageHash?: boolean
    totalQuestions?: boolean
    currentQuestion?: boolean
    sessionId?: boolean
    expiresAt?: boolean
    title?: boolean
    subject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Worksheet$userArgs<ExtArgs>
    questions?: boolean | Worksheet$questionsArgs<ExtArgs>
    doubts?: boolean | Worksheet$doubtsArgs<ExtArgs>
    _count?: boolean | WorksheetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worksheet"]>

  export type WorksheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    imageHash?: boolean
    totalQuestions?: boolean
    currentQuestion?: boolean
    sessionId?: boolean
    expiresAt?: boolean
    title?: boolean
    subject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Worksheet$userArgs<ExtArgs>
  }, ExtArgs["result"]["worksheet"]>

  export type WorksheetSelectScalar = {
    id?: boolean
    userId?: boolean
    imageUrl?: boolean
    imageHash?: boolean
    totalQuestions?: boolean
    currentQuestion?: boolean
    sessionId?: boolean
    expiresAt?: boolean
    title?: boolean
    subject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorksheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Worksheet$userArgs<ExtArgs>
    questions?: boolean | Worksheet$questionsArgs<ExtArgs>
    doubts?: boolean | Worksheet$doubtsArgs<ExtArgs>
    _count?: boolean | WorksheetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorksheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Worksheet$userArgs<ExtArgs>
  }

  export type $WorksheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worksheet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      questions: Prisma.$WorksheetQuestionPayload<ExtArgs>[]
      doubts: Prisma.$DoubtPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      imageUrl: string
      imageHash: string
      totalQuestions: number
      currentQuestion: number
      sessionId: string
      expiresAt: Date
      title: string | null
      subject: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["worksheet"]>
    composites: {}
  }

  type WorksheetGetPayload<S extends boolean | null | undefined | WorksheetDefaultArgs> = $Result.GetResult<Prisma.$WorksheetPayload, S>

  type WorksheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorksheetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorksheetCountAggregateInputType | true
    }

  export interface WorksheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worksheet'], meta: { name: 'Worksheet' } }
    /**
     * Find zero or one Worksheet that matches the filter.
     * @param {WorksheetFindUniqueArgs} args - Arguments to find a Worksheet
     * @example
     * // Get one Worksheet
     * const worksheet = await prisma.worksheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorksheetFindUniqueArgs>(args: SelectSubset<T, WorksheetFindUniqueArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Worksheet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorksheetFindUniqueOrThrowArgs} args - Arguments to find a Worksheet
     * @example
     * // Get one Worksheet
     * const worksheet = await prisma.worksheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorksheetFindUniqueOrThrowArgs>(args: SelectSubset<T, WorksheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Worksheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetFindFirstArgs} args - Arguments to find a Worksheet
     * @example
     * // Get one Worksheet
     * const worksheet = await prisma.worksheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorksheetFindFirstArgs>(args?: SelectSubset<T, WorksheetFindFirstArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Worksheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetFindFirstOrThrowArgs} args - Arguments to find a Worksheet
     * @example
     * // Get one Worksheet
     * const worksheet = await prisma.worksheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorksheetFindFirstOrThrowArgs>(args?: SelectSubset<T, WorksheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Worksheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Worksheets
     * const worksheets = await prisma.worksheet.findMany()
     * 
     * // Get first 10 Worksheets
     * const worksheets = await prisma.worksheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const worksheetWithIdOnly = await prisma.worksheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorksheetFindManyArgs>(args?: SelectSubset<T, WorksheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Worksheet.
     * @param {WorksheetCreateArgs} args - Arguments to create a Worksheet.
     * @example
     * // Create one Worksheet
     * const Worksheet = await prisma.worksheet.create({
     *   data: {
     *     // ... data to create a Worksheet
     *   }
     * })
     * 
     */
    create<T extends WorksheetCreateArgs>(args: SelectSubset<T, WorksheetCreateArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Worksheets.
     * @param {WorksheetCreateManyArgs} args - Arguments to create many Worksheets.
     * @example
     * // Create many Worksheets
     * const worksheet = await prisma.worksheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorksheetCreateManyArgs>(args?: SelectSubset<T, WorksheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Worksheets and returns the data saved in the database.
     * @param {WorksheetCreateManyAndReturnArgs} args - Arguments to create many Worksheets.
     * @example
     * // Create many Worksheets
     * const worksheet = await prisma.worksheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Worksheets and only return the `id`
     * const worksheetWithIdOnly = await prisma.worksheet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorksheetCreateManyAndReturnArgs>(args?: SelectSubset<T, WorksheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Worksheet.
     * @param {WorksheetDeleteArgs} args - Arguments to delete one Worksheet.
     * @example
     * // Delete one Worksheet
     * const Worksheet = await prisma.worksheet.delete({
     *   where: {
     *     // ... filter to delete one Worksheet
     *   }
     * })
     * 
     */
    delete<T extends WorksheetDeleteArgs>(args: SelectSubset<T, WorksheetDeleteArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Worksheet.
     * @param {WorksheetUpdateArgs} args - Arguments to update one Worksheet.
     * @example
     * // Update one Worksheet
     * const worksheet = await prisma.worksheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorksheetUpdateArgs>(args: SelectSubset<T, WorksheetUpdateArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Worksheets.
     * @param {WorksheetDeleteManyArgs} args - Arguments to filter Worksheets to delete.
     * @example
     * // Delete a few Worksheets
     * const { count } = await prisma.worksheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorksheetDeleteManyArgs>(args?: SelectSubset<T, WorksheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Worksheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Worksheets
     * const worksheet = await prisma.worksheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorksheetUpdateManyArgs>(args: SelectSubset<T, WorksheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worksheet.
     * @param {WorksheetUpsertArgs} args - Arguments to update or create a Worksheet.
     * @example
     * // Update or create a Worksheet
     * const worksheet = await prisma.worksheet.upsert({
     *   create: {
     *     // ... data to create a Worksheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worksheet we want to update
     *   }
     * })
     */
    upsert<T extends WorksheetUpsertArgs>(args: SelectSubset<T, WorksheetUpsertArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Worksheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetCountArgs} args - Arguments to filter Worksheets to count.
     * @example
     * // Count the number of Worksheets
     * const count = await prisma.worksheet.count({
     *   where: {
     *     // ... the filter for the Worksheets we want to count
     *   }
     * })
    **/
    count<T extends WorksheetCountArgs>(
      args?: Subset<T, WorksheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorksheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worksheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorksheetAggregateArgs>(args: Subset<T, WorksheetAggregateArgs>): Prisma.PrismaPromise<GetWorksheetAggregateType<T>>

    /**
     * Group by Worksheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorksheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorksheetGroupByArgs['orderBy'] }
        : { orderBy?: WorksheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorksheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorksheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worksheet model
   */
  readonly fields: WorksheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worksheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorksheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Worksheet$userArgs<ExtArgs> = {}>(args?: Subset<T, Worksheet$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    questions<T extends Worksheet$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Worksheet$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    doubts<T extends Worksheet$doubtsArgs<ExtArgs> = {}>(args?: Subset<T, Worksheet$doubtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worksheet model
   */ 
  interface WorksheetFieldRefs {
    readonly id: FieldRef<"Worksheet", 'String'>
    readonly userId: FieldRef<"Worksheet", 'String'>
    readonly imageUrl: FieldRef<"Worksheet", 'String'>
    readonly imageHash: FieldRef<"Worksheet", 'String'>
    readonly totalQuestions: FieldRef<"Worksheet", 'Int'>
    readonly currentQuestion: FieldRef<"Worksheet", 'Int'>
    readonly sessionId: FieldRef<"Worksheet", 'String'>
    readonly expiresAt: FieldRef<"Worksheet", 'DateTime'>
    readonly title: FieldRef<"Worksheet", 'String'>
    readonly subject: FieldRef<"Worksheet", 'String'>
    readonly createdAt: FieldRef<"Worksheet", 'DateTime'>
    readonly updatedAt: FieldRef<"Worksheet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Worksheet findUnique
   */
  export type WorksheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * Filter, which Worksheet to fetch.
     */
    where: WorksheetWhereUniqueInput
  }

  /**
   * Worksheet findUniqueOrThrow
   */
  export type WorksheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * Filter, which Worksheet to fetch.
     */
    where: WorksheetWhereUniqueInput
  }

  /**
   * Worksheet findFirst
   */
  export type WorksheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * Filter, which Worksheet to fetch.
     */
    where?: WorksheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worksheets to fetch.
     */
    orderBy?: WorksheetOrderByWithRelationInput | WorksheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Worksheets.
     */
    cursor?: WorksheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worksheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worksheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Worksheets.
     */
    distinct?: WorksheetScalarFieldEnum | WorksheetScalarFieldEnum[]
  }

  /**
   * Worksheet findFirstOrThrow
   */
  export type WorksheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * Filter, which Worksheet to fetch.
     */
    where?: WorksheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worksheets to fetch.
     */
    orderBy?: WorksheetOrderByWithRelationInput | WorksheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Worksheets.
     */
    cursor?: WorksheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worksheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worksheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Worksheets.
     */
    distinct?: WorksheetScalarFieldEnum | WorksheetScalarFieldEnum[]
  }

  /**
   * Worksheet findMany
   */
  export type WorksheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * Filter, which Worksheets to fetch.
     */
    where?: WorksheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worksheets to fetch.
     */
    orderBy?: WorksheetOrderByWithRelationInput | WorksheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Worksheets.
     */
    cursor?: WorksheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worksheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worksheets.
     */
    skip?: number
    distinct?: WorksheetScalarFieldEnum | WorksheetScalarFieldEnum[]
  }

  /**
   * Worksheet create
   */
  export type WorksheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * The data needed to create a Worksheet.
     */
    data: XOR<WorksheetCreateInput, WorksheetUncheckedCreateInput>
  }

  /**
   * Worksheet createMany
   */
  export type WorksheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Worksheets.
     */
    data: WorksheetCreateManyInput | WorksheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worksheet createManyAndReturn
   */
  export type WorksheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Worksheets.
     */
    data: WorksheetCreateManyInput | WorksheetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Worksheet update
   */
  export type WorksheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * The data needed to update a Worksheet.
     */
    data: XOR<WorksheetUpdateInput, WorksheetUncheckedUpdateInput>
    /**
     * Choose, which Worksheet to update.
     */
    where: WorksheetWhereUniqueInput
  }

  /**
   * Worksheet updateMany
   */
  export type WorksheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Worksheets.
     */
    data: XOR<WorksheetUpdateManyMutationInput, WorksheetUncheckedUpdateManyInput>
    /**
     * Filter which Worksheets to update
     */
    where?: WorksheetWhereInput
  }

  /**
   * Worksheet upsert
   */
  export type WorksheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * The filter to search for the Worksheet to update in case it exists.
     */
    where: WorksheetWhereUniqueInput
    /**
     * In case the Worksheet found by the `where` argument doesn't exist, create a new Worksheet with this data.
     */
    create: XOR<WorksheetCreateInput, WorksheetUncheckedCreateInput>
    /**
     * In case the Worksheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorksheetUpdateInput, WorksheetUncheckedUpdateInput>
  }

  /**
   * Worksheet delete
   */
  export type WorksheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
    /**
     * Filter which Worksheet to delete.
     */
    where: WorksheetWhereUniqueInput
  }

  /**
   * Worksheet deleteMany
   */
  export type WorksheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worksheets to delete
     */
    where?: WorksheetWhereInput
  }

  /**
   * Worksheet.user
   */
  export type Worksheet$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Worksheet.questions
   */
  export type Worksheet$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    where?: WorksheetQuestionWhereInput
    orderBy?: WorksheetQuestionOrderByWithRelationInput | WorksheetQuestionOrderByWithRelationInput[]
    cursor?: WorksheetQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorksheetQuestionScalarFieldEnum | WorksheetQuestionScalarFieldEnum[]
  }

  /**
   * Worksheet.doubts
   */
  export type Worksheet$doubtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    where?: DoubtWhereInput
    orderBy?: DoubtOrderByWithRelationInput | DoubtOrderByWithRelationInput[]
    cursor?: DoubtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoubtScalarFieldEnum | DoubtScalarFieldEnum[]
  }

  /**
   * Worksheet without action
   */
  export type WorksheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worksheet
     */
    select?: WorksheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetInclude<ExtArgs> | null
  }


  /**
   * Model WorksheetQuestion
   */

  export type AggregateWorksheetQuestion = {
    _count: WorksheetQuestionCountAggregateOutputType | null
    _avg: WorksheetQuestionAvgAggregateOutputType | null
    _sum: WorksheetQuestionSumAggregateOutputType | null
    _min: WorksheetQuestionMinAggregateOutputType | null
    _max: WorksheetQuestionMaxAggregateOutputType | null
  }

  export type WorksheetQuestionAvgAggregateOutputType = {
    questionNumber: number | null
  }

  export type WorksheetQuestionSumAggregateOutputType = {
    questionNumber: number | null
  }

  export type WorksheetQuestionMinAggregateOutputType = {
    id: string | null
    worksheetId: string | null
    questionNumber: number | null
    doubtId: string | null
    status: string | null
    cachedExplanation: string | null
    createdAt: Date | null
  }

  export type WorksheetQuestionMaxAggregateOutputType = {
    id: string | null
    worksheetId: string | null
    questionNumber: number | null
    doubtId: string | null
    status: string | null
    cachedExplanation: string | null
    createdAt: Date | null
  }

  export type WorksheetQuestionCountAggregateOutputType = {
    id: number
    worksheetId: number
    questionNumber: number
    doubtId: number
    status: number
    cachedExplanation: number
    createdAt: number
    _all: number
  }


  export type WorksheetQuestionAvgAggregateInputType = {
    questionNumber?: true
  }

  export type WorksheetQuestionSumAggregateInputType = {
    questionNumber?: true
  }

  export type WorksheetQuestionMinAggregateInputType = {
    id?: true
    worksheetId?: true
    questionNumber?: true
    doubtId?: true
    status?: true
    cachedExplanation?: true
    createdAt?: true
  }

  export type WorksheetQuestionMaxAggregateInputType = {
    id?: true
    worksheetId?: true
    questionNumber?: true
    doubtId?: true
    status?: true
    cachedExplanation?: true
    createdAt?: true
  }

  export type WorksheetQuestionCountAggregateInputType = {
    id?: true
    worksheetId?: true
    questionNumber?: true
    doubtId?: true
    status?: true
    cachedExplanation?: true
    createdAt?: true
    _all?: true
  }

  export type WorksheetQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorksheetQuestion to aggregate.
     */
    where?: WorksheetQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorksheetQuestions to fetch.
     */
    orderBy?: WorksheetQuestionOrderByWithRelationInput | WorksheetQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorksheetQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorksheetQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorksheetQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorksheetQuestions
    **/
    _count?: true | WorksheetQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorksheetQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorksheetQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorksheetQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorksheetQuestionMaxAggregateInputType
  }

  export type GetWorksheetQuestionAggregateType<T extends WorksheetQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorksheetQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorksheetQuestion[P]>
      : GetScalarType<T[P], AggregateWorksheetQuestion[P]>
  }




  export type WorksheetQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorksheetQuestionWhereInput
    orderBy?: WorksheetQuestionOrderByWithAggregationInput | WorksheetQuestionOrderByWithAggregationInput[]
    by: WorksheetQuestionScalarFieldEnum[] | WorksheetQuestionScalarFieldEnum
    having?: WorksheetQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorksheetQuestionCountAggregateInputType | true
    _avg?: WorksheetQuestionAvgAggregateInputType
    _sum?: WorksheetQuestionSumAggregateInputType
    _min?: WorksheetQuestionMinAggregateInputType
    _max?: WorksheetQuestionMaxAggregateInputType
  }

  export type WorksheetQuestionGroupByOutputType = {
    id: string
    worksheetId: string
    questionNumber: number
    doubtId: string | null
    status: string
    cachedExplanation: string | null
    createdAt: Date
    _count: WorksheetQuestionCountAggregateOutputType | null
    _avg: WorksheetQuestionAvgAggregateOutputType | null
    _sum: WorksheetQuestionSumAggregateOutputType | null
    _min: WorksheetQuestionMinAggregateOutputType | null
    _max: WorksheetQuestionMaxAggregateOutputType | null
  }

  type GetWorksheetQuestionGroupByPayload<T extends WorksheetQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorksheetQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorksheetQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorksheetQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], WorksheetQuestionGroupByOutputType[P]>
        }
      >
    >


  export type WorksheetQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    worksheetId?: boolean
    questionNumber?: boolean
    doubtId?: boolean
    status?: boolean
    cachedExplanation?: boolean
    createdAt?: boolean
    worksheet?: boolean | WorksheetDefaultArgs<ExtArgs>
    doubt?: boolean | WorksheetQuestion$doubtArgs<ExtArgs>
  }, ExtArgs["result"]["worksheetQuestion"]>

  export type WorksheetQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    worksheetId?: boolean
    questionNumber?: boolean
    doubtId?: boolean
    status?: boolean
    cachedExplanation?: boolean
    createdAt?: boolean
    worksheet?: boolean | WorksheetDefaultArgs<ExtArgs>
    doubt?: boolean | WorksheetQuestion$doubtArgs<ExtArgs>
  }, ExtArgs["result"]["worksheetQuestion"]>

  export type WorksheetQuestionSelectScalar = {
    id?: boolean
    worksheetId?: boolean
    questionNumber?: boolean
    doubtId?: boolean
    status?: boolean
    cachedExplanation?: boolean
    createdAt?: boolean
  }

  export type WorksheetQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worksheet?: boolean | WorksheetDefaultArgs<ExtArgs>
    doubt?: boolean | WorksheetQuestion$doubtArgs<ExtArgs>
  }
  export type WorksheetQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worksheet?: boolean | WorksheetDefaultArgs<ExtArgs>
    doubt?: boolean | WorksheetQuestion$doubtArgs<ExtArgs>
  }

  export type $WorksheetQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorksheetQuestion"
    objects: {
      worksheet: Prisma.$WorksheetPayload<ExtArgs>
      doubt: Prisma.$DoubtPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      worksheetId: string
      questionNumber: number
      doubtId: string | null
      status: string
      cachedExplanation: string | null
      createdAt: Date
    }, ExtArgs["result"]["worksheetQuestion"]>
    composites: {}
  }

  type WorksheetQuestionGetPayload<S extends boolean | null | undefined | WorksheetQuestionDefaultArgs> = $Result.GetResult<Prisma.$WorksheetQuestionPayload, S>

  type WorksheetQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorksheetQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorksheetQuestionCountAggregateInputType | true
    }

  export interface WorksheetQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorksheetQuestion'], meta: { name: 'WorksheetQuestion' } }
    /**
     * Find zero or one WorksheetQuestion that matches the filter.
     * @param {WorksheetQuestionFindUniqueArgs} args - Arguments to find a WorksheetQuestion
     * @example
     * // Get one WorksheetQuestion
     * const worksheetQuestion = await prisma.worksheetQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorksheetQuestionFindUniqueArgs>(args: SelectSubset<T, WorksheetQuestionFindUniqueArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorksheetQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorksheetQuestionFindUniqueOrThrowArgs} args - Arguments to find a WorksheetQuestion
     * @example
     * // Get one WorksheetQuestion
     * const worksheetQuestion = await prisma.worksheetQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorksheetQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorksheetQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorksheetQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetQuestionFindFirstArgs} args - Arguments to find a WorksheetQuestion
     * @example
     * // Get one WorksheetQuestion
     * const worksheetQuestion = await prisma.worksheetQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorksheetQuestionFindFirstArgs>(args?: SelectSubset<T, WorksheetQuestionFindFirstArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorksheetQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetQuestionFindFirstOrThrowArgs} args - Arguments to find a WorksheetQuestion
     * @example
     * // Get one WorksheetQuestion
     * const worksheetQuestion = await prisma.worksheetQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorksheetQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorksheetQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorksheetQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorksheetQuestions
     * const worksheetQuestions = await prisma.worksheetQuestion.findMany()
     * 
     * // Get first 10 WorksheetQuestions
     * const worksheetQuestions = await prisma.worksheetQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const worksheetQuestionWithIdOnly = await prisma.worksheetQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorksheetQuestionFindManyArgs>(args?: SelectSubset<T, WorksheetQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorksheetQuestion.
     * @param {WorksheetQuestionCreateArgs} args - Arguments to create a WorksheetQuestion.
     * @example
     * // Create one WorksheetQuestion
     * const WorksheetQuestion = await prisma.worksheetQuestion.create({
     *   data: {
     *     // ... data to create a WorksheetQuestion
     *   }
     * })
     * 
     */
    create<T extends WorksheetQuestionCreateArgs>(args: SelectSubset<T, WorksheetQuestionCreateArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorksheetQuestions.
     * @param {WorksheetQuestionCreateManyArgs} args - Arguments to create many WorksheetQuestions.
     * @example
     * // Create many WorksheetQuestions
     * const worksheetQuestion = await prisma.worksheetQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorksheetQuestionCreateManyArgs>(args?: SelectSubset<T, WorksheetQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorksheetQuestions and returns the data saved in the database.
     * @param {WorksheetQuestionCreateManyAndReturnArgs} args - Arguments to create many WorksheetQuestions.
     * @example
     * // Create many WorksheetQuestions
     * const worksheetQuestion = await prisma.worksheetQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorksheetQuestions and only return the `id`
     * const worksheetQuestionWithIdOnly = await prisma.worksheetQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorksheetQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorksheetQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorksheetQuestion.
     * @param {WorksheetQuestionDeleteArgs} args - Arguments to delete one WorksheetQuestion.
     * @example
     * // Delete one WorksheetQuestion
     * const WorksheetQuestion = await prisma.worksheetQuestion.delete({
     *   where: {
     *     // ... filter to delete one WorksheetQuestion
     *   }
     * })
     * 
     */
    delete<T extends WorksheetQuestionDeleteArgs>(args: SelectSubset<T, WorksheetQuestionDeleteArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorksheetQuestion.
     * @param {WorksheetQuestionUpdateArgs} args - Arguments to update one WorksheetQuestion.
     * @example
     * // Update one WorksheetQuestion
     * const worksheetQuestion = await prisma.worksheetQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorksheetQuestionUpdateArgs>(args: SelectSubset<T, WorksheetQuestionUpdateArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorksheetQuestions.
     * @param {WorksheetQuestionDeleteManyArgs} args - Arguments to filter WorksheetQuestions to delete.
     * @example
     * // Delete a few WorksheetQuestions
     * const { count } = await prisma.worksheetQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorksheetQuestionDeleteManyArgs>(args?: SelectSubset<T, WorksheetQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorksheetQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorksheetQuestions
     * const worksheetQuestion = await prisma.worksheetQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorksheetQuestionUpdateManyArgs>(args: SelectSubset<T, WorksheetQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorksheetQuestion.
     * @param {WorksheetQuestionUpsertArgs} args - Arguments to update or create a WorksheetQuestion.
     * @example
     * // Update or create a WorksheetQuestion
     * const worksheetQuestion = await prisma.worksheetQuestion.upsert({
     *   create: {
     *     // ... data to create a WorksheetQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorksheetQuestion we want to update
     *   }
     * })
     */
    upsert<T extends WorksheetQuestionUpsertArgs>(args: SelectSubset<T, WorksheetQuestionUpsertArgs<ExtArgs>>): Prisma__WorksheetQuestionClient<$Result.GetResult<Prisma.$WorksheetQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorksheetQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetQuestionCountArgs} args - Arguments to filter WorksheetQuestions to count.
     * @example
     * // Count the number of WorksheetQuestions
     * const count = await prisma.worksheetQuestion.count({
     *   where: {
     *     // ... the filter for the WorksheetQuestions we want to count
     *   }
     * })
    **/
    count<T extends WorksheetQuestionCountArgs>(
      args?: Subset<T, WorksheetQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorksheetQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorksheetQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorksheetQuestionAggregateArgs>(args: Subset<T, WorksheetQuestionAggregateArgs>): Prisma.PrismaPromise<GetWorksheetQuestionAggregateType<T>>

    /**
     * Group by WorksheetQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksheetQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorksheetQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorksheetQuestionGroupByArgs['orderBy'] }
        : { orderBy?: WorksheetQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorksheetQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorksheetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorksheetQuestion model
   */
  readonly fields: WorksheetQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorksheetQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorksheetQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    worksheet<T extends WorksheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorksheetDefaultArgs<ExtArgs>>): Prisma__WorksheetClient<$Result.GetResult<Prisma.$WorksheetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doubt<T extends WorksheetQuestion$doubtArgs<ExtArgs> = {}>(args?: Subset<T, WorksheetQuestion$doubtArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorksheetQuestion model
   */ 
  interface WorksheetQuestionFieldRefs {
    readonly id: FieldRef<"WorksheetQuestion", 'String'>
    readonly worksheetId: FieldRef<"WorksheetQuestion", 'String'>
    readonly questionNumber: FieldRef<"WorksheetQuestion", 'Int'>
    readonly doubtId: FieldRef<"WorksheetQuestion", 'String'>
    readonly status: FieldRef<"WorksheetQuestion", 'String'>
    readonly cachedExplanation: FieldRef<"WorksheetQuestion", 'String'>
    readonly createdAt: FieldRef<"WorksheetQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorksheetQuestion findUnique
   */
  export type WorksheetQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WorksheetQuestion to fetch.
     */
    where: WorksheetQuestionWhereUniqueInput
  }

  /**
   * WorksheetQuestion findUniqueOrThrow
   */
  export type WorksheetQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WorksheetQuestion to fetch.
     */
    where: WorksheetQuestionWhereUniqueInput
  }

  /**
   * WorksheetQuestion findFirst
   */
  export type WorksheetQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WorksheetQuestion to fetch.
     */
    where?: WorksheetQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorksheetQuestions to fetch.
     */
    orderBy?: WorksheetQuestionOrderByWithRelationInput | WorksheetQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorksheetQuestions.
     */
    cursor?: WorksheetQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorksheetQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorksheetQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorksheetQuestions.
     */
    distinct?: WorksheetQuestionScalarFieldEnum | WorksheetQuestionScalarFieldEnum[]
  }

  /**
   * WorksheetQuestion findFirstOrThrow
   */
  export type WorksheetQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WorksheetQuestion to fetch.
     */
    where?: WorksheetQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorksheetQuestions to fetch.
     */
    orderBy?: WorksheetQuestionOrderByWithRelationInput | WorksheetQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorksheetQuestions.
     */
    cursor?: WorksheetQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorksheetQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorksheetQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorksheetQuestions.
     */
    distinct?: WorksheetQuestionScalarFieldEnum | WorksheetQuestionScalarFieldEnum[]
  }

  /**
   * WorksheetQuestion findMany
   */
  export type WorksheetQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WorksheetQuestions to fetch.
     */
    where?: WorksheetQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorksheetQuestions to fetch.
     */
    orderBy?: WorksheetQuestionOrderByWithRelationInput | WorksheetQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorksheetQuestions.
     */
    cursor?: WorksheetQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorksheetQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorksheetQuestions.
     */
    skip?: number
    distinct?: WorksheetQuestionScalarFieldEnum | WorksheetQuestionScalarFieldEnum[]
  }

  /**
   * WorksheetQuestion create
   */
  export type WorksheetQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorksheetQuestion.
     */
    data: XOR<WorksheetQuestionCreateInput, WorksheetQuestionUncheckedCreateInput>
  }

  /**
   * WorksheetQuestion createMany
   */
  export type WorksheetQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorksheetQuestions.
     */
    data: WorksheetQuestionCreateManyInput | WorksheetQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorksheetQuestion createManyAndReturn
   */
  export type WorksheetQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorksheetQuestions.
     */
    data: WorksheetQuestionCreateManyInput | WorksheetQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorksheetQuestion update
   */
  export type WorksheetQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorksheetQuestion.
     */
    data: XOR<WorksheetQuestionUpdateInput, WorksheetQuestionUncheckedUpdateInput>
    /**
     * Choose, which WorksheetQuestion to update.
     */
    where: WorksheetQuestionWhereUniqueInput
  }

  /**
   * WorksheetQuestion updateMany
   */
  export type WorksheetQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorksheetQuestions.
     */
    data: XOR<WorksheetQuestionUpdateManyMutationInput, WorksheetQuestionUncheckedUpdateManyInput>
    /**
     * Filter which WorksheetQuestions to update
     */
    where?: WorksheetQuestionWhereInput
  }

  /**
   * WorksheetQuestion upsert
   */
  export type WorksheetQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorksheetQuestion to update in case it exists.
     */
    where: WorksheetQuestionWhereUniqueInput
    /**
     * In case the WorksheetQuestion found by the `where` argument doesn't exist, create a new WorksheetQuestion with this data.
     */
    create: XOR<WorksheetQuestionCreateInput, WorksheetQuestionUncheckedCreateInput>
    /**
     * In case the WorksheetQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorksheetQuestionUpdateInput, WorksheetQuestionUncheckedUpdateInput>
  }

  /**
   * WorksheetQuestion delete
   */
  export type WorksheetQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
    /**
     * Filter which WorksheetQuestion to delete.
     */
    where: WorksheetQuestionWhereUniqueInput
  }

  /**
   * WorksheetQuestion deleteMany
   */
  export type WorksheetQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorksheetQuestions to delete
     */
    where?: WorksheetQuestionWhereInput
  }

  /**
   * WorksheetQuestion.doubt
   */
  export type WorksheetQuestion$doubtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doubt
     */
    select?: DoubtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtInclude<ExtArgs> | null
    where?: DoubtWhereInput
  }

  /**
   * WorksheetQuestion without action
   */
  export type WorksheetQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorksheetQuestion
     */
    select?: WorksheetQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorksheetQuestionInclude<ExtArgs> | null
  }


  /**
   * Model DoubtRating
   */

  export type AggregateDoubtRating = {
    _count: DoubtRatingCountAggregateOutputType | null
    _avg: DoubtRatingAvgAggregateOutputType | null
    _sum: DoubtRatingSumAggregateOutputType | null
    _min: DoubtRatingMinAggregateOutputType | null
    _max: DoubtRatingMaxAggregateOutputType | null
  }

  export type DoubtRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type DoubtRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type DoubtRatingMinAggregateOutputType = {
    id: string | null
    doubtId: string | null
    userId: string | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoubtRatingMaxAggregateOutputType = {
    id: string | null
    doubtId: string | null
    userId: string | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoubtRatingCountAggregateOutputType = {
    id: number
    doubtId: number
    userId: number
    rating: number
    feedback: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DoubtRatingAvgAggregateInputType = {
    rating?: true
  }

  export type DoubtRatingSumAggregateInputType = {
    rating?: true
  }

  export type DoubtRatingMinAggregateInputType = {
    id?: true
    doubtId?: true
    userId?: true
    rating?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoubtRatingMaxAggregateInputType = {
    id?: true
    doubtId?: true
    userId?: true
    rating?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoubtRatingCountAggregateInputType = {
    id?: true
    doubtId?: true
    userId?: true
    rating?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DoubtRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoubtRating to aggregate.
     */
    where?: DoubtRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtRatings to fetch.
     */
    orderBy?: DoubtRatingOrderByWithRelationInput | DoubtRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoubtRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoubtRatings
    **/
    _count?: true | DoubtRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoubtRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoubtRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoubtRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoubtRatingMaxAggregateInputType
  }

  export type GetDoubtRatingAggregateType<T extends DoubtRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateDoubtRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoubtRating[P]>
      : GetScalarType<T[P], AggregateDoubtRating[P]>
  }




  export type DoubtRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoubtRatingWhereInput
    orderBy?: DoubtRatingOrderByWithAggregationInput | DoubtRatingOrderByWithAggregationInput[]
    by: DoubtRatingScalarFieldEnum[] | DoubtRatingScalarFieldEnum
    having?: DoubtRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoubtRatingCountAggregateInputType | true
    _avg?: DoubtRatingAvgAggregateInputType
    _sum?: DoubtRatingSumAggregateInputType
    _min?: DoubtRatingMinAggregateInputType
    _max?: DoubtRatingMaxAggregateInputType
  }

  export type DoubtRatingGroupByOutputType = {
    id: string
    doubtId: string
    userId: string
    rating: number
    feedback: string | null
    createdAt: Date
    updatedAt: Date
    _count: DoubtRatingCountAggregateOutputType | null
    _avg: DoubtRatingAvgAggregateOutputType | null
    _sum: DoubtRatingSumAggregateOutputType | null
    _min: DoubtRatingMinAggregateOutputType | null
    _max: DoubtRatingMaxAggregateOutputType | null
  }

  type GetDoubtRatingGroupByPayload<T extends DoubtRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoubtRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoubtRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoubtRatingGroupByOutputType[P]>
            : GetScalarType<T[P], DoubtRatingGroupByOutputType[P]>
        }
      >
    >


  export type DoubtRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doubtId?: boolean
    userId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doubtRating"]>

  export type DoubtRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doubtId?: boolean
    userId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doubtRating"]>

  export type DoubtRatingSelectScalar = {
    id?: boolean
    doubtId?: boolean
    userId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DoubtRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DoubtRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doubt?: boolean | DoubtDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DoubtRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoubtRating"
    objects: {
      doubt: Prisma.$DoubtPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doubtId: string
      userId: string
      rating: number
      feedback: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["doubtRating"]>
    composites: {}
  }

  type DoubtRatingGetPayload<S extends boolean | null | undefined | DoubtRatingDefaultArgs> = $Result.GetResult<Prisma.$DoubtRatingPayload, S>

  type DoubtRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoubtRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoubtRatingCountAggregateInputType | true
    }

  export interface DoubtRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoubtRating'], meta: { name: 'DoubtRating' } }
    /**
     * Find zero or one DoubtRating that matches the filter.
     * @param {DoubtRatingFindUniqueArgs} args - Arguments to find a DoubtRating
     * @example
     * // Get one DoubtRating
     * const doubtRating = await prisma.doubtRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoubtRatingFindUniqueArgs>(args: SelectSubset<T, DoubtRatingFindUniqueArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoubtRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoubtRatingFindUniqueOrThrowArgs} args - Arguments to find a DoubtRating
     * @example
     * // Get one DoubtRating
     * const doubtRating = await prisma.doubtRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoubtRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, DoubtRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoubtRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtRatingFindFirstArgs} args - Arguments to find a DoubtRating
     * @example
     * // Get one DoubtRating
     * const doubtRating = await prisma.doubtRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoubtRatingFindFirstArgs>(args?: SelectSubset<T, DoubtRatingFindFirstArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoubtRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtRatingFindFirstOrThrowArgs} args - Arguments to find a DoubtRating
     * @example
     * // Get one DoubtRating
     * const doubtRating = await prisma.doubtRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoubtRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, DoubtRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoubtRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoubtRatings
     * const doubtRatings = await prisma.doubtRating.findMany()
     * 
     * // Get first 10 DoubtRatings
     * const doubtRatings = await prisma.doubtRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doubtRatingWithIdOnly = await prisma.doubtRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoubtRatingFindManyArgs>(args?: SelectSubset<T, DoubtRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoubtRating.
     * @param {DoubtRatingCreateArgs} args - Arguments to create a DoubtRating.
     * @example
     * // Create one DoubtRating
     * const DoubtRating = await prisma.doubtRating.create({
     *   data: {
     *     // ... data to create a DoubtRating
     *   }
     * })
     * 
     */
    create<T extends DoubtRatingCreateArgs>(args: SelectSubset<T, DoubtRatingCreateArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoubtRatings.
     * @param {DoubtRatingCreateManyArgs} args - Arguments to create many DoubtRatings.
     * @example
     * // Create many DoubtRatings
     * const doubtRating = await prisma.doubtRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoubtRatingCreateManyArgs>(args?: SelectSubset<T, DoubtRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoubtRatings and returns the data saved in the database.
     * @param {DoubtRatingCreateManyAndReturnArgs} args - Arguments to create many DoubtRatings.
     * @example
     * // Create many DoubtRatings
     * const doubtRating = await prisma.doubtRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoubtRatings and only return the `id`
     * const doubtRatingWithIdOnly = await prisma.doubtRating.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoubtRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, DoubtRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoubtRating.
     * @param {DoubtRatingDeleteArgs} args - Arguments to delete one DoubtRating.
     * @example
     * // Delete one DoubtRating
     * const DoubtRating = await prisma.doubtRating.delete({
     *   where: {
     *     // ... filter to delete one DoubtRating
     *   }
     * })
     * 
     */
    delete<T extends DoubtRatingDeleteArgs>(args: SelectSubset<T, DoubtRatingDeleteArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoubtRating.
     * @param {DoubtRatingUpdateArgs} args - Arguments to update one DoubtRating.
     * @example
     * // Update one DoubtRating
     * const doubtRating = await prisma.doubtRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoubtRatingUpdateArgs>(args: SelectSubset<T, DoubtRatingUpdateArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoubtRatings.
     * @param {DoubtRatingDeleteManyArgs} args - Arguments to filter DoubtRatings to delete.
     * @example
     * // Delete a few DoubtRatings
     * const { count } = await prisma.doubtRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoubtRatingDeleteManyArgs>(args?: SelectSubset<T, DoubtRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoubtRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoubtRatings
     * const doubtRating = await prisma.doubtRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoubtRatingUpdateManyArgs>(args: SelectSubset<T, DoubtRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoubtRating.
     * @param {DoubtRatingUpsertArgs} args - Arguments to update or create a DoubtRating.
     * @example
     * // Update or create a DoubtRating
     * const doubtRating = await prisma.doubtRating.upsert({
     *   create: {
     *     // ... data to create a DoubtRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoubtRating we want to update
     *   }
     * })
     */
    upsert<T extends DoubtRatingUpsertArgs>(args: SelectSubset<T, DoubtRatingUpsertArgs<ExtArgs>>): Prisma__DoubtRatingClient<$Result.GetResult<Prisma.$DoubtRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoubtRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtRatingCountArgs} args - Arguments to filter DoubtRatings to count.
     * @example
     * // Count the number of DoubtRatings
     * const count = await prisma.doubtRating.count({
     *   where: {
     *     // ... the filter for the DoubtRatings we want to count
     *   }
     * })
    **/
    count<T extends DoubtRatingCountArgs>(
      args?: Subset<T, DoubtRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoubtRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoubtRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoubtRatingAggregateArgs>(args: Subset<T, DoubtRatingAggregateArgs>): Prisma.PrismaPromise<GetDoubtRatingAggregateType<T>>

    /**
     * Group by DoubtRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoubtRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoubtRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoubtRatingGroupByArgs['orderBy'] }
        : { orderBy?: DoubtRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoubtRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoubtRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoubtRating model
   */
  readonly fields: DoubtRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoubtRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoubtRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doubt<T extends DoubtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoubtDefaultArgs<ExtArgs>>): Prisma__DoubtClient<$Result.GetResult<Prisma.$DoubtPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoubtRating model
   */ 
  interface DoubtRatingFieldRefs {
    readonly id: FieldRef<"DoubtRating", 'String'>
    readonly doubtId: FieldRef<"DoubtRating", 'String'>
    readonly userId: FieldRef<"DoubtRating", 'String'>
    readonly rating: FieldRef<"DoubtRating", 'Int'>
    readonly feedback: FieldRef<"DoubtRating", 'String'>
    readonly createdAt: FieldRef<"DoubtRating", 'DateTime'>
    readonly updatedAt: FieldRef<"DoubtRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DoubtRating findUnique
   */
  export type DoubtRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * Filter, which DoubtRating to fetch.
     */
    where: DoubtRatingWhereUniqueInput
  }

  /**
   * DoubtRating findUniqueOrThrow
   */
  export type DoubtRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * Filter, which DoubtRating to fetch.
     */
    where: DoubtRatingWhereUniqueInput
  }

  /**
   * DoubtRating findFirst
   */
  export type DoubtRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * Filter, which DoubtRating to fetch.
     */
    where?: DoubtRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtRatings to fetch.
     */
    orderBy?: DoubtRatingOrderByWithRelationInput | DoubtRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoubtRatings.
     */
    cursor?: DoubtRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoubtRatings.
     */
    distinct?: DoubtRatingScalarFieldEnum | DoubtRatingScalarFieldEnum[]
  }

  /**
   * DoubtRating findFirstOrThrow
   */
  export type DoubtRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * Filter, which DoubtRating to fetch.
     */
    where?: DoubtRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtRatings to fetch.
     */
    orderBy?: DoubtRatingOrderByWithRelationInput | DoubtRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoubtRatings.
     */
    cursor?: DoubtRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoubtRatings.
     */
    distinct?: DoubtRatingScalarFieldEnum | DoubtRatingScalarFieldEnum[]
  }

  /**
   * DoubtRating findMany
   */
  export type DoubtRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * Filter, which DoubtRatings to fetch.
     */
    where?: DoubtRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoubtRatings to fetch.
     */
    orderBy?: DoubtRatingOrderByWithRelationInput | DoubtRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoubtRatings.
     */
    cursor?: DoubtRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoubtRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoubtRatings.
     */
    skip?: number
    distinct?: DoubtRatingScalarFieldEnum | DoubtRatingScalarFieldEnum[]
  }

  /**
   * DoubtRating create
   */
  export type DoubtRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a DoubtRating.
     */
    data: XOR<DoubtRatingCreateInput, DoubtRatingUncheckedCreateInput>
  }

  /**
   * DoubtRating createMany
   */
  export type DoubtRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoubtRatings.
     */
    data: DoubtRatingCreateManyInput | DoubtRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoubtRating createManyAndReturn
   */
  export type DoubtRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoubtRatings.
     */
    data: DoubtRatingCreateManyInput | DoubtRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoubtRating update
   */
  export type DoubtRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a DoubtRating.
     */
    data: XOR<DoubtRatingUpdateInput, DoubtRatingUncheckedUpdateInput>
    /**
     * Choose, which DoubtRating to update.
     */
    where: DoubtRatingWhereUniqueInput
  }

  /**
   * DoubtRating updateMany
   */
  export type DoubtRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoubtRatings.
     */
    data: XOR<DoubtRatingUpdateManyMutationInput, DoubtRatingUncheckedUpdateManyInput>
    /**
     * Filter which DoubtRatings to update
     */
    where?: DoubtRatingWhereInput
  }

  /**
   * DoubtRating upsert
   */
  export type DoubtRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the DoubtRating to update in case it exists.
     */
    where: DoubtRatingWhereUniqueInput
    /**
     * In case the DoubtRating found by the `where` argument doesn't exist, create a new DoubtRating with this data.
     */
    create: XOR<DoubtRatingCreateInput, DoubtRatingUncheckedCreateInput>
    /**
     * In case the DoubtRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoubtRatingUpdateInput, DoubtRatingUncheckedUpdateInput>
  }

  /**
   * DoubtRating delete
   */
  export type DoubtRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
    /**
     * Filter which DoubtRating to delete.
     */
    where: DoubtRatingWhereUniqueInput
  }

  /**
   * DoubtRating deleteMany
   */
  export type DoubtRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoubtRatings to delete
     */
    where?: DoubtRatingWhereInput
  }

  /**
   * DoubtRating without action
   */
  export type DoubtRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoubtRating
     */
    select?: DoubtRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoubtRatingInclude<ExtArgs> | null
  }


  /**
   * Model RevisionSession
   */

  export type AggregateRevisionSession = {
    _count: RevisionSessionCountAggregateOutputType | null
    _avg: RevisionSessionAvgAggregateOutputType | null
    _sum: RevisionSessionSumAggregateOutputType | null
    _min: RevisionSessionMinAggregateOutputType | null
    _max: RevisionSessionMaxAggregateOutputType | null
  }

  export type RevisionSessionAvgAggregateOutputType = {
    score: number | null
  }

  export type RevisionSessionSumAggregateOutputType = {
    score: number | null
  }

  export type RevisionSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    subject: string | null
    startedAt: Date | null
    completedAt: Date | null
    score: number | null
    weakAreas: string | null
    phasesCompleted: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevisionSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    subject: string | null
    startedAt: Date | null
    completedAt: Date | null
    score: number | null
    weakAreas: string | null
    phasesCompleted: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevisionSessionCountAggregateOutputType = {
    id: number
    userId: number
    topic: number
    subject: number
    startedAt: number
    completedAt: number
    score: number
    weakAreas: number
    phasesCompleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RevisionSessionAvgAggregateInputType = {
    score?: true
  }

  export type RevisionSessionSumAggregateInputType = {
    score?: true
  }

  export type RevisionSessionMinAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    startedAt?: true
    completedAt?: true
    score?: true
    weakAreas?: true
    phasesCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevisionSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    startedAt?: true
    completedAt?: true
    score?: true
    weakAreas?: true
    phasesCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevisionSessionCountAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    startedAt?: true
    completedAt?: true
    score?: true
    weakAreas?: true
    phasesCompleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RevisionSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevisionSession to aggregate.
     */
    where?: RevisionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevisionSessions to fetch.
     */
    orderBy?: RevisionSessionOrderByWithRelationInput | RevisionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevisionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevisionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevisionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevisionSessions
    **/
    _count?: true | RevisionSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevisionSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevisionSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevisionSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevisionSessionMaxAggregateInputType
  }

  export type GetRevisionSessionAggregateType<T extends RevisionSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateRevisionSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevisionSession[P]>
      : GetScalarType<T[P], AggregateRevisionSession[P]>
  }




  export type RevisionSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevisionSessionWhereInput
    orderBy?: RevisionSessionOrderByWithAggregationInput | RevisionSessionOrderByWithAggregationInput[]
    by: RevisionSessionScalarFieldEnum[] | RevisionSessionScalarFieldEnum
    having?: RevisionSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevisionSessionCountAggregateInputType | true
    _avg?: RevisionSessionAvgAggregateInputType
    _sum?: RevisionSessionSumAggregateInputType
    _min?: RevisionSessionMinAggregateInputType
    _max?: RevisionSessionMaxAggregateInputType
  }

  export type RevisionSessionGroupByOutputType = {
    id: string
    userId: string | null
    topic: string
    subject: string
    startedAt: Date
    completedAt: Date | null
    score: number | null
    weakAreas: string | null
    phasesCompleted: string | null
    createdAt: Date
    updatedAt: Date
    _count: RevisionSessionCountAggregateOutputType | null
    _avg: RevisionSessionAvgAggregateOutputType | null
    _sum: RevisionSessionSumAggregateOutputType | null
    _min: RevisionSessionMinAggregateOutputType | null
    _max: RevisionSessionMaxAggregateOutputType | null
  }

  type GetRevisionSessionGroupByPayload<T extends RevisionSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevisionSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevisionSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevisionSessionGroupByOutputType[P]>
            : GetScalarType<T[P], RevisionSessionGroupByOutputType[P]>
        }
      >
    >


  export type RevisionSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    weakAreas?: boolean
    phasesCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | RevisionSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["revisionSession"]>

  export type RevisionSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    weakAreas?: boolean
    phasesCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | RevisionSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["revisionSession"]>

  export type RevisionSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    weakAreas?: boolean
    phasesCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RevisionSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RevisionSession$userArgs<ExtArgs>
  }
  export type RevisionSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RevisionSession$userArgs<ExtArgs>
  }

  export type $RevisionSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevisionSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      topic: string
      subject: string
      startedAt: Date
      completedAt: Date | null
      score: number | null
      weakAreas: string | null
      phasesCompleted: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["revisionSession"]>
    composites: {}
  }

  type RevisionSessionGetPayload<S extends boolean | null | undefined | RevisionSessionDefaultArgs> = $Result.GetResult<Prisma.$RevisionSessionPayload, S>

  type RevisionSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RevisionSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RevisionSessionCountAggregateInputType | true
    }

  export interface RevisionSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevisionSession'], meta: { name: 'RevisionSession' } }
    /**
     * Find zero or one RevisionSession that matches the filter.
     * @param {RevisionSessionFindUniqueArgs} args - Arguments to find a RevisionSession
     * @example
     * // Get one RevisionSession
     * const revisionSession = await prisma.revisionSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevisionSessionFindUniqueArgs>(args: SelectSubset<T, RevisionSessionFindUniqueArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RevisionSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RevisionSessionFindUniqueOrThrowArgs} args - Arguments to find a RevisionSession
     * @example
     * // Get one RevisionSession
     * const revisionSession = await prisma.revisionSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevisionSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, RevisionSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RevisionSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionSessionFindFirstArgs} args - Arguments to find a RevisionSession
     * @example
     * // Get one RevisionSession
     * const revisionSession = await prisma.revisionSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevisionSessionFindFirstArgs>(args?: SelectSubset<T, RevisionSessionFindFirstArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RevisionSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionSessionFindFirstOrThrowArgs} args - Arguments to find a RevisionSession
     * @example
     * // Get one RevisionSession
     * const revisionSession = await prisma.revisionSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevisionSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, RevisionSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RevisionSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevisionSessions
     * const revisionSessions = await prisma.revisionSession.findMany()
     * 
     * // Get first 10 RevisionSessions
     * const revisionSessions = await prisma.revisionSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revisionSessionWithIdOnly = await prisma.revisionSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevisionSessionFindManyArgs>(args?: SelectSubset<T, RevisionSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RevisionSession.
     * @param {RevisionSessionCreateArgs} args - Arguments to create a RevisionSession.
     * @example
     * // Create one RevisionSession
     * const RevisionSession = await prisma.revisionSession.create({
     *   data: {
     *     // ... data to create a RevisionSession
     *   }
     * })
     * 
     */
    create<T extends RevisionSessionCreateArgs>(args: SelectSubset<T, RevisionSessionCreateArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RevisionSessions.
     * @param {RevisionSessionCreateManyArgs} args - Arguments to create many RevisionSessions.
     * @example
     * // Create many RevisionSessions
     * const revisionSession = await prisma.revisionSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevisionSessionCreateManyArgs>(args?: SelectSubset<T, RevisionSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevisionSessions and returns the data saved in the database.
     * @param {RevisionSessionCreateManyAndReturnArgs} args - Arguments to create many RevisionSessions.
     * @example
     * // Create many RevisionSessions
     * const revisionSession = await prisma.revisionSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevisionSessions and only return the `id`
     * const revisionSessionWithIdOnly = await prisma.revisionSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevisionSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, RevisionSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RevisionSession.
     * @param {RevisionSessionDeleteArgs} args - Arguments to delete one RevisionSession.
     * @example
     * // Delete one RevisionSession
     * const RevisionSession = await prisma.revisionSession.delete({
     *   where: {
     *     // ... filter to delete one RevisionSession
     *   }
     * })
     * 
     */
    delete<T extends RevisionSessionDeleteArgs>(args: SelectSubset<T, RevisionSessionDeleteArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RevisionSession.
     * @param {RevisionSessionUpdateArgs} args - Arguments to update one RevisionSession.
     * @example
     * // Update one RevisionSession
     * const revisionSession = await prisma.revisionSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevisionSessionUpdateArgs>(args: SelectSubset<T, RevisionSessionUpdateArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RevisionSessions.
     * @param {RevisionSessionDeleteManyArgs} args - Arguments to filter RevisionSessions to delete.
     * @example
     * // Delete a few RevisionSessions
     * const { count } = await prisma.revisionSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevisionSessionDeleteManyArgs>(args?: SelectSubset<T, RevisionSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevisionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevisionSessions
     * const revisionSession = await prisma.revisionSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevisionSessionUpdateManyArgs>(args: SelectSubset<T, RevisionSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RevisionSession.
     * @param {RevisionSessionUpsertArgs} args - Arguments to update or create a RevisionSession.
     * @example
     * // Update or create a RevisionSession
     * const revisionSession = await prisma.revisionSession.upsert({
     *   create: {
     *     // ... data to create a RevisionSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevisionSession we want to update
     *   }
     * })
     */
    upsert<T extends RevisionSessionUpsertArgs>(args: SelectSubset<T, RevisionSessionUpsertArgs<ExtArgs>>): Prisma__RevisionSessionClient<$Result.GetResult<Prisma.$RevisionSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RevisionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionSessionCountArgs} args - Arguments to filter RevisionSessions to count.
     * @example
     * // Count the number of RevisionSessions
     * const count = await prisma.revisionSession.count({
     *   where: {
     *     // ... the filter for the RevisionSessions we want to count
     *   }
     * })
    **/
    count<T extends RevisionSessionCountArgs>(
      args?: Subset<T, RevisionSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevisionSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevisionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevisionSessionAggregateArgs>(args: Subset<T, RevisionSessionAggregateArgs>): Prisma.PrismaPromise<GetRevisionSessionAggregateType<T>>

    /**
     * Group by RevisionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevisionSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevisionSessionGroupByArgs['orderBy'] }
        : { orderBy?: RevisionSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevisionSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevisionSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevisionSession model
   */
  readonly fields: RevisionSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevisionSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevisionSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends RevisionSession$userArgs<ExtArgs> = {}>(args?: Subset<T, RevisionSession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevisionSession model
   */ 
  interface RevisionSessionFieldRefs {
    readonly id: FieldRef<"RevisionSession", 'String'>
    readonly userId: FieldRef<"RevisionSession", 'String'>
    readonly topic: FieldRef<"RevisionSession", 'String'>
    readonly subject: FieldRef<"RevisionSession", 'String'>
    readonly startedAt: FieldRef<"RevisionSession", 'DateTime'>
    readonly completedAt: FieldRef<"RevisionSession", 'DateTime'>
    readonly score: FieldRef<"RevisionSession", 'Int'>
    readonly weakAreas: FieldRef<"RevisionSession", 'String'>
    readonly phasesCompleted: FieldRef<"RevisionSession", 'String'>
    readonly createdAt: FieldRef<"RevisionSession", 'DateTime'>
    readonly updatedAt: FieldRef<"RevisionSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RevisionSession findUnique
   */
  export type RevisionSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * Filter, which RevisionSession to fetch.
     */
    where: RevisionSessionWhereUniqueInput
  }

  /**
   * RevisionSession findUniqueOrThrow
   */
  export type RevisionSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * Filter, which RevisionSession to fetch.
     */
    where: RevisionSessionWhereUniqueInput
  }

  /**
   * RevisionSession findFirst
   */
  export type RevisionSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * Filter, which RevisionSession to fetch.
     */
    where?: RevisionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevisionSessions to fetch.
     */
    orderBy?: RevisionSessionOrderByWithRelationInput | RevisionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevisionSessions.
     */
    cursor?: RevisionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevisionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevisionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevisionSessions.
     */
    distinct?: RevisionSessionScalarFieldEnum | RevisionSessionScalarFieldEnum[]
  }

  /**
   * RevisionSession findFirstOrThrow
   */
  export type RevisionSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * Filter, which RevisionSession to fetch.
     */
    where?: RevisionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevisionSessions to fetch.
     */
    orderBy?: RevisionSessionOrderByWithRelationInput | RevisionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevisionSessions.
     */
    cursor?: RevisionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevisionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevisionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevisionSessions.
     */
    distinct?: RevisionSessionScalarFieldEnum | RevisionSessionScalarFieldEnum[]
  }

  /**
   * RevisionSession findMany
   */
  export type RevisionSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * Filter, which RevisionSessions to fetch.
     */
    where?: RevisionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevisionSessions to fetch.
     */
    orderBy?: RevisionSessionOrderByWithRelationInput | RevisionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevisionSessions.
     */
    cursor?: RevisionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevisionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevisionSessions.
     */
    skip?: number
    distinct?: RevisionSessionScalarFieldEnum | RevisionSessionScalarFieldEnum[]
  }

  /**
   * RevisionSession create
   */
  export type RevisionSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a RevisionSession.
     */
    data: XOR<RevisionSessionCreateInput, RevisionSessionUncheckedCreateInput>
  }

  /**
   * RevisionSession createMany
   */
  export type RevisionSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevisionSessions.
     */
    data: RevisionSessionCreateManyInput | RevisionSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevisionSession createManyAndReturn
   */
  export type RevisionSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RevisionSessions.
     */
    data: RevisionSessionCreateManyInput | RevisionSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RevisionSession update
   */
  export type RevisionSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a RevisionSession.
     */
    data: XOR<RevisionSessionUpdateInput, RevisionSessionUncheckedUpdateInput>
    /**
     * Choose, which RevisionSession to update.
     */
    where: RevisionSessionWhereUniqueInput
  }

  /**
   * RevisionSession updateMany
   */
  export type RevisionSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevisionSessions.
     */
    data: XOR<RevisionSessionUpdateManyMutationInput, RevisionSessionUncheckedUpdateManyInput>
    /**
     * Filter which RevisionSessions to update
     */
    where?: RevisionSessionWhereInput
  }

  /**
   * RevisionSession upsert
   */
  export type RevisionSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the RevisionSession to update in case it exists.
     */
    where: RevisionSessionWhereUniqueInput
    /**
     * In case the RevisionSession found by the `where` argument doesn't exist, create a new RevisionSession with this data.
     */
    create: XOR<RevisionSessionCreateInput, RevisionSessionUncheckedCreateInput>
    /**
     * In case the RevisionSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevisionSessionUpdateInput, RevisionSessionUncheckedUpdateInput>
  }

  /**
   * RevisionSession delete
   */
  export type RevisionSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
    /**
     * Filter which RevisionSession to delete.
     */
    where: RevisionSessionWhereUniqueInput
  }

  /**
   * RevisionSession deleteMany
   */
  export type RevisionSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevisionSessions to delete
     */
    where?: RevisionSessionWhereInput
  }

  /**
   * RevisionSession.user
   */
  export type RevisionSession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RevisionSession without action
   */
  export type RevisionSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevisionSession
     */
    select?: RevisionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionSessionInclude<ExtArgs> | null
  }


  /**
   * Model WeakTopic
   */

  export type AggregateWeakTopic = {
    _count: WeakTopicCountAggregateOutputType | null
    _avg: WeakTopicAvgAggregateOutputType | null
    _sum: WeakTopicSumAggregateOutputType | null
    _min: WeakTopicMinAggregateOutputType | null
    _max: WeakTopicMaxAggregateOutputType | null
  }

  export type WeakTopicAvgAggregateOutputType = {
    occurrences: number | null
  }

  export type WeakTopicSumAggregateOutputType = {
    occurrences: number | null
  }

  export type WeakTopicMinAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    subject: string | null
    occurrences: number | null
    lastSeen: Date | null
    improved: boolean | null
    improvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeakTopicMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    subject: string | null
    occurrences: number | null
    lastSeen: Date | null
    improved: boolean | null
    improvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeakTopicCountAggregateOutputType = {
    id: number
    userId: number
    topic: number
    subject: number
    occurrences: number
    lastSeen: number
    improved: number
    improvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeakTopicAvgAggregateInputType = {
    occurrences?: true
  }

  export type WeakTopicSumAggregateInputType = {
    occurrences?: true
  }

  export type WeakTopicMinAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    occurrences?: true
    lastSeen?: true
    improved?: true
    improvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeakTopicMaxAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    occurrences?: true
    lastSeen?: true
    improved?: true
    improvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeakTopicCountAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    occurrences?: true
    lastSeen?: true
    improved?: true
    improvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeakTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeakTopic to aggregate.
     */
    where?: WeakTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeakTopics to fetch.
     */
    orderBy?: WeakTopicOrderByWithRelationInput | WeakTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeakTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeakTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeakTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeakTopics
    **/
    _count?: true | WeakTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeakTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeakTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeakTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeakTopicMaxAggregateInputType
  }

  export type GetWeakTopicAggregateType<T extends WeakTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateWeakTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeakTopic[P]>
      : GetScalarType<T[P], AggregateWeakTopic[P]>
  }




  export type WeakTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeakTopicWhereInput
    orderBy?: WeakTopicOrderByWithAggregationInput | WeakTopicOrderByWithAggregationInput[]
    by: WeakTopicScalarFieldEnum[] | WeakTopicScalarFieldEnum
    having?: WeakTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeakTopicCountAggregateInputType | true
    _avg?: WeakTopicAvgAggregateInputType
    _sum?: WeakTopicSumAggregateInputType
    _min?: WeakTopicMinAggregateInputType
    _max?: WeakTopicMaxAggregateInputType
  }

  export type WeakTopicGroupByOutputType = {
    id: string
    userId: string | null
    topic: string
    subject: string
    occurrences: number
    lastSeen: Date
    improved: boolean
    improvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WeakTopicCountAggregateOutputType | null
    _avg: WeakTopicAvgAggregateOutputType | null
    _sum: WeakTopicSumAggregateOutputType | null
    _min: WeakTopicMinAggregateOutputType | null
    _max: WeakTopicMaxAggregateOutputType | null
  }

  type GetWeakTopicGroupByPayload<T extends WeakTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeakTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeakTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeakTopicGroupByOutputType[P]>
            : GetScalarType<T[P], WeakTopicGroupByOutputType[P]>
        }
      >
    >


  export type WeakTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    occurrences?: boolean
    lastSeen?: boolean
    improved?: boolean
    improvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | WeakTopic$userArgs<ExtArgs>
  }, ExtArgs["result"]["weakTopic"]>

  export type WeakTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    occurrences?: boolean
    lastSeen?: boolean
    improved?: boolean
    improvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | WeakTopic$userArgs<ExtArgs>
  }, ExtArgs["result"]["weakTopic"]>

  export type WeakTopicSelectScalar = {
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    occurrences?: boolean
    lastSeen?: boolean
    improved?: boolean
    improvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeakTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | WeakTopic$userArgs<ExtArgs>
  }
  export type WeakTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | WeakTopic$userArgs<ExtArgs>
  }

  export type $WeakTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeakTopic"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      topic: string
      subject: string
      occurrences: number
      lastSeen: Date
      improved: boolean
      improvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weakTopic"]>
    composites: {}
  }

  type WeakTopicGetPayload<S extends boolean | null | undefined | WeakTopicDefaultArgs> = $Result.GetResult<Prisma.$WeakTopicPayload, S>

  type WeakTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeakTopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeakTopicCountAggregateInputType | true
    }

  export interface WeakTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeakTopic'], meta: { name: 'WeakTopic' } }
    /**
     * Find zero or one WeakTopic that matches the filter.
     * @param {WeakTopicFindUniqueArgs} args - Arguments to find a WeakTopic
     * @example
     * // Get one WeakTopic
     * const weakTopic = await prisma.weakTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeakTopicFindUniqueArgs>(args: SelectSubset<T, WeakTopicFindUniqueArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeakTopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeakTopicFindUniqueOrThrowArgs} args - Arguments to find a WeakTopic
     * @example
     * // Get one WeakTopic
     * const weakTopic = await prisma.weakTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeakTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, WeakTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeakTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeakTopicFindFirstArgs} args - Arguments to find a WeakTopic
     * @example
     * // Get one WeakTopic
     * const weakTopic = await prisma.weakTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeakTopicFindFirstArgs>(args?: SelectSubset<T, WeakTopicFindFirstArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeakTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeakTopicFindFirstOrThrowArgs} args - Arguments to find a WeakTopic
     * @example
     * // Get one WeakTopic
     * const weakTopic = await prisma.weakTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeakTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, WeakTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeakTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeakTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeakTopics
     * const weakTopics = await prisma.weakTopic.findMany()
     * 
     * // Get first 10 WeakTopics
     * const weakTopics = await prisma.weakTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weakTopicWithIdOnly = await prisma.weakTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeakTopicFindManyArgs>(args?: SelectSubset<T, WeakTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeakTopic.
     * @param {WeakTopicCreateArgs} args - Arguments to create a WeakTopic.
     * @example
     * // Create one WeakTopic
     * const WeakTopic = await prisma.weakTopic.create({
     *   data: {
     *     // ... data to create a WeakTopic
     *   }
     * })
     * 
     */
    create<T extends WeakTopicCreateArgs>(args: SelectSubset<T, WeakTopicCreateArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeakTopics.
     * @param {WeakTopicCreateManyArgs} args - Arguments to create many WeakTopics.
     * @example
     * // Create many WeakTopics
     * const weakTopic = await prisma.weakTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeakTopicCreateManyArgs>(args?: SelectSubset<T, WeakTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeakTopics and returns the data saved in the database.
     * @param {WeakTopicCreateManyAndReturnArgs} args - Arguments to create many WeakTopics.
     * @example
     * // Create many WeakTopics
     * const weakTopic = await prisma.weakTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeakTopics and only return the `id`
     * const weakTopicWithIdOnly = await prisma.weakTopic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeakTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, WeakTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeakTopic.
     * @param {WeakTopicDeleteArgs} args - Arguments to delete one WeakTopic.
     * @example
     * // Delete one WeakTopic
     * const WeakTopic = await prisma.weakTopic.delete({
     *   where: {
     *     // ... filter to delete one WeakTopic
     *   }
     * })
     * 
     */
    delete<T extends WeakTopicDeleteArgs>(args: SelectSubset<T, WeakTopicDeleteArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeakTopic.
     * @param {WeakTopicUpdateArgs} args - Arguments to update one WeakTopic.
     * @example
     * // Update one WeakTopic
     * const weakTopic = await prisma.weakTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeakTopicUpdateArgs>(args: SelectSubset<T, WeakTopicUpdateArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeakTopics.
     * @param {WeakTopicDeleteManyArgs} args - Arguments to filter WeakTopics to delete.
     * @example
     * // Delete a few WeakTopics
     * const { count } = await prisma.weakTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeakTopicDeleteManyArgs>(args?: SelectSubset<T, WeakTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeakTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeakTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeakTopics
     * const weakTopic = await prisma.weakTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeakTopicUpdateManyArgs>(args: SelectSubset<T, WeakTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeakTopic.
     * @param {WeakTopicUpsertArgs} args - Arguments to update or create a WeakTopic.
     * @example
     * // Update or create a WeakTopic
     * const weakTopic = await prisma.weakTopic.upsert({
     *   create: {
     *     // ... data to create a WeakTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeakTopic we want to update
     *   }
     * })
     */
    upsert<T extends WeakTopicUpsertArgs>(args: SelectSubset<T, WeakTopicUpsertArgs<ExtArgs>>): Prisma__WeakTopicClient<$Result.GetResult<Prisma.$WeakTopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeakTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeakTopicCountArgs} args - Arguments to filter WeakTopics to count.
     * @example
     * // Count the number of WeakTopics
     * const count = await prisma.weakTopic.count({
     *   where: {
     *     // ... the filter for the WeakTopics we want to count
     *   }
     * })
    **/
    count<T extends WeakTopicCountArgs>(
      args?: Subset<T, WeakTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeakTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeakTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeakTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeakTopicAggregateArgs>(args: Subset<T, WeakTopicAggregateArgs>): Prisma.PrismaPromise<GetWeakTopicAggregateType<T>>

    /**
     * Group by WeakTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeakTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeakTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeakTopicGroupByArgs['orderBy'] }
        : { orderBy?: WeakTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeakTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeakTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeakTopic model
   */
  readonly fields: WeakTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeakTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeakTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends WeakTopic$userArgs<ExtArgs> = {}>(args?: Subset<T, WeakTopic$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeakTopic model
   */ 
  interface WeakTopicFieldRefs {
    readonly id: FieldRef<"WeakTopic", 'String'>
    readonly userId: FieldRef<"WeakTopic", 'String'>
    readonly topic: FieldRef<"WeakTopic", 'String'>
    readonly subject: FieldRef<"WeakTopic", 'String'>
    readonly occurrences: FieldRef<"WeakTopic", 'Int'>
    readonly lastSeen: FieldRef<"WeakTopic", 'DateTime'>
    readonly improved: FieldRef<"WeakTopic", 'Boolean'>
    readonly improvedAt: FieldRef<"WeakTopic", 'DateTime'>
    readonly createdAt: FieldRef<"WeakTopic", 'DateTime'>
    readonly updatedAt: FieldRef<"WeakTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeakTopic findUnique
   */
  export type WeakTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * Filter, which WeakTopic to fetch.
     */
    where: WeakTopicWhereUniqueInput
  }

  /**
   * WeakTopic findUniqueOrThrow
   */
  export type WeakTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * Filter, which WeakTopic to fetch.
     */
    where: WeakTopicWhereUniqueInput
  }

  /**
   * WeakTopic findFirst
   */
  export type WeakTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * Filter, which WeakTopic to fetch.
     */
    where?: WeakTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeakTopics to fetch.
     */
    orderBy?: WeakTopicOrderByWithRelationInput | WeakTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeakTopics.
     */
    cursor?: WeakTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeakTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeakTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeakTopics.
     */
    distinct?: WeakTopicScalarFieldEnum | WeakTopicScalarFieldEnum[]
  }

  /**
   * WeakTopic findFirstOrThrow
   */
  export type WeakTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * Filter, which WeakTopic to fetch.
     */
    where?: WeakTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeakTopics to fetch.
     */
    orderBy?: WeakTopicOrderByWithRelationInput | WeakTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeakTopics.
     */
    cursor?: WeakTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeakTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeakTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeakTopics.
     */
    distinct?: WeakTopicScalarFieldEnum | WeakTopicScalarFieldEnum[]
  }

  /**
   * WeakTopic findMany
   */
  export type WeakTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * Filter, which WeakTopics to fetch.
     */
    where?: WeakTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeakTopics to fetch.
     */
    orderBy?: WeakTopicOrderByWithRelationInput | WeakTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeakTopics.
     */
    cursor?: WeakTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeakTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeakTopics.
     */
    skip?: number
    distinct?: WeakTopicScalarFieldEnum | WeakTopicScalarFieldEnum[]
  }

  /**
   * WeakTopic create
   */
  export type WeakTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a WeakTopic.
     */
    data: XOR<WeakTopicCreateInput, WeakTopicUncheckedCreateInput>
  }

  /**
   * WeakTopic createMany
   */
  export type WeakTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeakTopics.
     */
    data: WeakTopicCreateManyInput | WeakTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeakTopic createManyAndReturn
   */
  export type WeakTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeakTopics.
     */
    data: WeakTopicCreateManyInput | WeakTopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeakTopic update
   */
  export type WeakTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a WeakTopic.
     */
    data: XOR<WeakTopicUpdateInput, WeakTopicUncheckedUpdateInput>
    /**
     * Choose, which WeakTopic to update.
     */
    where: WeakTopicWhereUniqueInput
  }

  /**
   * WeakTopic updateMany
   */
  export type WeakTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeakTopics.
     */
    data: XOR<WeakTopicUpdateManyMutationInput, WeakTopicUncheckedUpdateManyInput>
    /**
     * Filter which WeakTopics to update
     */
    where?: WeakTopicWhereInput
  }

  /**
   * WeakTopic upsert
   */
  export type WeakTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the WeakTopic to update in case it exists.
     */
    where: WeakTopicWhereUniqueInput
    /**
     * In case the WeakTopic found by the `where` argument doesn't exist, create a new WeakTopic with this data.
     */
    create: XOR<WeakTopicCreateInput, WeakTopicUncheckedCreateInput>
    /**
     * In case the WeakTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeakTopicUpdateInput, WeakTopicUncheckedUpdateInput>
  }

  /**
   * WeakTopic delete
   */
  export type WeakTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
    /**
     * Filter which WeakTopic to delete.
     */
    where: WeakTopicWhereUniqueInput
  }

  /**
   * WeakTopic deleteMany
   */
  export type WeakTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeakTopics to delete
     */
    where?: WeakTopicWhereInput
  }

  /**
   * WeakTopic.user
   */
  export type WeakTopic$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WeakTopic without action
   */
  export type WeakTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeakTopic
     */
    select?: WeakTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeakTopicInclude<ExtArgs> | null
  }


  /**
   * Model GroupStudySession
   */

  export type AggregateGroupStudySession = {
    _count: GroupStudySessionCountAggregateOutputType | null
    _avg: GroupStudySessionAvgAggregateOutputType | null
    _sum: GroupStudySessionSumAggregateOutputType | null
    _min: GroupStudySessionMinAggregateOutputType | null
    _max: GroupStudySessionMaxAggregateOutputType | null
  }

  export type GroupStudySessionAvgAggregateOutputType = {
    handlingScore: number | null
    challengesCount: number | null
  }

  export type GroupStudySessionSumAggregateOutputType = {
    handlingScore: number | null
    challengesCount: number | null
  }

  export type GroupStudySessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    subject: string | null
    question: string | null
    classmate1Name: string | null
    classmate2Name: string | null
    studentAnswer: string | null
    classmate1Question: string | null
    classmate2Counter: string | null
    classmate1Response: string | null
    classmate2Response: string | null
    handlingScore: number | null
    strengths: string | null
    improvements: string | null
    challengesCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupStudySessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    subject: string | null
    question: string | null
    classmate1Name: string | null
    classmate2Name: string | null
    studentAnswer: string | null
    classmate1Question: string | null
    classmate2Counter: string | null
    classmate1Response: string | null
    classmate2Response: string | null
    handlingScore: number | null
    strengths: string | null
    improvements: string | null
    challengesCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupStudySessionCountAggregateOutputType = {
    id: number
    userId: number
    topic: number
    subject: number
    question: number
    classmate1Name: number
    classmate2Name: number
    studentAnswer: number
    classmate1Question: number
    classmate2Counter: number
    classmate1Response: number
    classmate2Response: number
    handlingScore: number
    strengths: number
    improvements: number
    challengesCount: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupStudySessionAvgAggregateInputType = {
    handlingScore?: true
    challengesCount?: true
  }

  export type GroupStudySessionSumAggregateInputType = {
    handlingScore?: true
    challengesCount?: true
  }

  export type GroupStudySessionMinAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    question?: true
    classmate1Name?: true
    classmate2Name?: true
    studentAnswer?: true
    classmate1Question?: true
    classmate2Counter?: true
    classmate1Response?: true
    classmate2Response?: true
    handlingScore?: true
    strengths?: true
    improvements?: true
    challengesCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupStudySessionMaxAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    question?: true
    classmate1Name?: true
    classmate2Name?: true
    studentAnswer?: true
    classmate1Question?: true
    classmate2Counter?: true
    classmate1Response?: true
    classmate2Response?: true
    handlingScore?: true
    strengths?: true
    improvements?: true
    challengesCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupStudySessionCountAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    subject?: true
    question?: true
    classmate1Name?: true
    classmate2Name?: true
    studentAnswer?: true
    classmate1Question?: true
    classmate2Counter?: true
    classmate1Response?: true
    classmate2Response?: true
    handlingScore?: true
    strengths?: true
    improvements?: true
    challengesCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupStudySessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupStudySession to aggregate.
     */
    where?: GroupStudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupStudySessions to fetch.
     */
    orderBy?: GroupStudySessionOrderByWithRelationInput | GroupStudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupStudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupStudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupStudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupStudySessions
    **/
    _count?: true | GroupStudySessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupStudySessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupStudySessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupStudySessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupStudySessionMaxAggregateInputType
  }

  export type GetGroupStudySessionAggregateType<T extends GroupStudySessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupStudySession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupStudySession[P]>
      : GetScalarType<T[P], AggregateGroupStudySession[P]>
  }




  export type GroupStudySessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupStudySessionWhereInput
    orderBy?: GroupStudySessionOrderByWithAggregationInput | GroupStudySessionOrderByWithAggregationInput[]
    by: GroupStudySessionScalarFieldEnum[] | GroupStudySessionScalarFieldEnum
    having?: GroupStudySessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupStudySessionCountAggregateInputType | true
    _avg?: GroupStudySessionAvgAggregateInputType
    _sum?: GroupStudySessionSumAggregateInputType
    _min?: GroupStudySessionMinAggregateInputType
    _max?: GroupStudySessionMaxAggregateInputType
  }

  export type GroupStudySessionGroupByOutputType = {
    id: string
    userId: string | null
    topic: string
    subject: string
    question: string | null
    classmate1Name: string
    classmate2Name: string
    studentAnswer: string
    classmate1Question: string | null
    classmate2Counter: string | null
    classmate1Response: string | null
    classmate2Response: string | null
    handlingScore: number | null
    strengths: string | null
    improvements: string | null
    challengesCount: number
    startedAt: Date
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GroupStudySessionCountAggregateOutputType | null
    _avg: GroupStudySessionAvgAggregateOutputType | null
    _sum: GroupStudySessionSumAggregateOutputType | null
    _min: GroupStudySessionMinAggregateOutputType | null
    _max: GroupStudySessionMaxAggregateOutputType | null
  }

  type GetGroupStudySessionGroupByPayload<T extends GroupStudySessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupStudySessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupStudySessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupStudySessionGroupByOutputType[P]>
            : GetScalarType<T[P], GroupStudySessionGroupByOutputType[P]>
        }
      >
    >


  export type GroupStudySessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    question?: boolean
    classmate1Name?: boolean
    classmate2Name?: boolean
    studentAnswer?: boolean
    classmate1Question?: boolean
    classmate2Counter?: boolean
    classmate1Response?: boolean
    classmate2Response?: boolean
    handlingScore?: boolean
    strengths?: boolean
    improvements?: boolean
    challengesCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | GroupStudySession$userArgs<ExtArgs>
  }, ExtArgs["result"]["groupStudySession"]>

  export type GroupStudySessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    question?: boolean
    classmate1Name?: boolean
    classmate2Name?: boolean
    studentAnswer?: boolean
    classmate1Question?: boolean
    classmate2Counter?: boolean
    classmate1Response?: boolean
    classmate2Response?: boolean
    handlingScore?: boolean
    strengths?: boolean
    improvements?: boolean
    challengesCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | GroupStudySession$userArgs<ExtArgs>
  }, ExtArgs["result"]["groupStudySession"]>

  export type GroupStudySessionSelectScalar = {
    id?: boolean
    userId?: boolean
    topic?: boolean
    subject?: boolean
    question?: boolean
    classmate1Name?: boolean
    classmate2Name?: boolean
    studentAnswer?: boolean
    classmate1Question?: boolean
    classmate2Counter?: boolean
    classmate1Response?: boolean
    classmate2Response?: boolean
    handlingScore?: boolean
    strengths?: boolean
    improvements?: boolean
    challengesCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupStudySessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GroupStudySession$userArgs<ExtArgs>
  }
  export type GroupStudySessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GroupStudySession$userArgs<ExtArgs>
  }

  export type $GroupStudySessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupStudySession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      topic: string
      subject: string
      question: string | null
      classmate1Name: string
      classmate2Name: string
      studentAnswer: string
      classmate1Question: string | null
      classmate2Counter: string | null
      classmate1Response: string | null
      classmate2Response: string | null
      handlingScore: number | null
      strengths: string | null
      improvements: string | null
      challengesCount: number
      startedAt: Date
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["groupStudySession"]>
    composites: {}
  }

  type GroupStudySessionGetPayload<S extends boolean | null | undefined | GroupStudySessionDefaultArgs> = $Result.GetResult<Prisma.$GroupStudySessionPayload, S>

  type GroupStudySessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupStudySessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupStudySessionCountAggregateInputType | true
    }

  export interface GroupStudySessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupStudySession'], meta: { name: 'GroupStudySession' } }
    /**
     * Find zero or one GroupStudySession that matches the filter.
     * @param {GroupStudySessionFindUniqueArgs} args - Arguments to find a GroupStudySession
     * @example
     * // Get one GroupStudySession
     * const groupStudySession = await prisma.groupStudySession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupStudySessionFindUniqueArgs>(args: SelectSubset<T, GroupStudySessionFindUniqueArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupStudySession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupStudySessionFindUniqueOrThrowArgs} args - Arguments to find a GroupStudySession
     * @example
     * // Get one GroupStudySession
     * const groupStudySession = await prisma.groupStudySession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupStudySessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupStudySessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupStudySession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupStudySessionFindFirstArgs} args - Arguments to find a GroupStudySession
     * @example
     * // Get one GroupStudySession
     * const groupStudySession = await prisma.groupStudySession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupStudySessionFindFirstArgs>(args?: SelectSubset<T, GroupStudySessionFindFirstArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupStudySession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupStudySessionFindFirstOrThrowArgs} args - Arguments to find a GroupStudySession
     * @example
     * // Get one GroupStudySession
     * const groupStudySession = await prisma.groupStudySession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupStudySessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupStudySessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupStudySessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupStudySessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupStudySessions
     * const groupStudySessions = await prisma.groupStudySession.findMany()
     * 
     * // Get first 10 GroupStudySessions
     * const groupStudySessions = await prisma.groupStudySession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupStudySessionWithIdOnly = await prisma.groupStudySession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupStudySessionFindManyArgs>(args?: SelectSubset<T, GroupStudySessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupStudySession.
     * @param {GroupStudySessionCreateArgs} args - Arguments to create a GroupStudySession.
     * @example
     * // Create one GroupStudySession
     * const GroupStudySession = await prisma.groupStudySession.create({
     *   data: {
     *     // ... data to create a GroupStudySession
     *   }
     * })
     * 
     */
    create<T extends GroupStudySessionCreateArgs>(args: SelectSubset<T, GroupStudySessionCreateArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupStudySessions.
     * @param {GroupStudySessionCreateManyArgs} args - Arguments to create many GroupStudySessions.
     * @example
     * // Create many GroupStudySessions
     * const groupStudySession = await prisma.groupStudySession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupStudySessionCreateManyArgs>(args?: SelectSubset<T, GroupStudySessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupStudySessions and returns the data saved in the database.
     * @param {GroupStudySessionCreateManyAndReturnArgs} args - Arguments to create many GroupStudySessions.
     * @example
     * // Create many GroupStudySessions
     * const groupStudySession = await prisma.groupStudySession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupStudySessions and only return the `id`
     * const groupStudySessionWithIdOnly = await prisma.groupStudySession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupStudySessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupStudySessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GroupStudySession.
     * @param {GroupStudySessionDeleteArgs} args - Arguments to delete one GroupStudySession.
     * @example
     * // Delete one GroupStudySession
     * const GroupStudySession = await prisma.groupStudySession.delete({
     *   where: {
     *     // ... filter to delete one GroupStudySession
     *   }
     * })
     * 
     */
    delete<T extends GroupStudySessionDeleteArgs>(args: SelectSubset<T, GroupStudySessionDeleteArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupStudySession.
     * @param {GroupStudySessionUpdateArgs} args - Arguments to update one GroupStudySession.
     * @example
     * // Update one GroupStudySession
     * const groupStudySession = await prisma.groupStudySession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupStudySessionUpdateArgs>(args: SelectSubset<T, GroupStudySessionUpdateArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupStudySessions.
     * @param {GroupStudySessionDeleteManyArgs} args - Arguments to filter GroupStudySessions to delete.
     * @example
     * // Delete a few GroupStudySessions
     * const { count } = await prisma.groupStudySession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupStudySessionDeleteManyArgs>(args?: SelectSubset<T, GroupStudySessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupStudySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupStudySessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupStudySessions
     * const groupStudySession = await prisma.groupStudySession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupStudySessionUpdateManyArgs>(args: SelectSubset<T, GroupStudySessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupStudySession.
     * @param {GroupStudySessionUpsertArgs} args - Arguments to update or create a GroupStudySession.
     * @example
     * // Update or create a GroupStudySession
     * const groupStudySession = await prisma.groupStudySession.upsert({
     *   create: {
     *     // ... data to create a GroupStudySession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupStudySession we want to update
     *   }
     * })
     */
    upsert<T extends GroupStudySessionUpsertArgs>(args: SelectSubset<T, GroupStudySessionUpsertArgs<ExtArgs>>): Prisma__GroupStudySessionClient<$Result.GetResult<Prisma.$GroupStudySessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupStudySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupStudySessionCountArgs} args - Arguments to filter GroupStudySessions to count.
     * @example
     * // Count the number of GroupStudySessions
     * const count = await prisma.groupStudySession.count({
     *   where: {
     *     // ... the filter for the GroupStudySessions we want to count
     *   }
     * })
    **/
    count<T extends GroupStudySessionCountArgs>(
      args?: Subset<T, GroupStudySessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupStudySessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupStudySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupStudySessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupStudySessionAggregateArgs>(args: Subset<T, GroupStudySessionAggregateArgs>): Prisma.PrismaPromise<GetGroupStudySessionAggregateType<T>>

    /**
     * Group by GroupStudySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupStudySessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupStudySessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupStudySessionGroupByArgs['orderBy'] }
        : { orderBy?: GroupStudySessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupStudySessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupStudySessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupStudySession model
   */
  readonly fields: GroupStudySessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupStudySession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupStudySessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends GroupStudySession$userArgs<ExtArgs> = {}>(args?: Subset<T, GroupStudySession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupStudySession model
   */ 
  interface GroupStudySessionFieldRefs {
    readonly id: FieldRef<"GroupStudySession", 'String'>
    readonly userId: FieldRef<"GroupStudySession", 'String'>
    readonly topic: FieldRef<"GroupStudySession", 'String'>
    readonly subject: FieldRef<"GroupStudySession", 'String'>
    readonly question: FieldRef<"GroupStudySession", 'String'>
    readonly classmate1Name: FieldRef<"GroupStudySession", 'String'>
    readonly classmate2Name: FieldRef<"GroupStudySession", 'String'>
    readonly studentAnswer: FieldRef<"GroupStudySession", 'String'>
    readonly classmate1Question: FieldRef<"GroupStudySession", 'String'>
    readonly classmate2Counter: FieldRef<"GroupStudySession", 'String'>
    readonly classmate1Response: FieldRef<"GroupStudySession", 'String'>
    readonly classmate2Response: FieldRef<"GroupStudySession", 'String'>
    readonly handlingScore: FieldRef<"GroupStudySession", 'Int'>
    readonly strengths: FieldRef<"GroupStudySession", 'String'>
    readonly improvements: FieldRef<"GroupStudySession", 'String'>
    readonly challengesCount: FieldRef<"GroupStudySession", 'Int'>
    readonly startedAt: FieldRef<"GroupStudySession", 'DateTime'>
    readonly completedAt: FieldRef<"GroupStudySession", 'DateTime'>
    readonly createdAt: FieldRef<"GroupStudySession", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupStudySession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupStudySession findUnique
   */
  export type GroupStudySessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupStudySession to fetch.
     */
    where: GroupStudySessionWhereUniqueInput
  }

  /**
   * GroupStudySession findUniqueOrThrow
   */
  export type GroupStudySessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupStudySession to fetch.
     */
    where: GroupStudySessionWhereUniqueInput
  }

  /**
   * GroupStudySession findFirst
   */
  export type GroupStudySessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupStudySession to fetch.
     */
    where?: GroupStudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupStudySessions to fetch.
     */
    orderBy?: GroupStudySessionOrderByWithRelationInput | GroupStudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupStudySessions.
     */
    cursor?: GroupStudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupStudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupStudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupStudySessions.
     */
    distinct?: GroupStudySessionScalarFieldEnum | GroupStudySessionScalarFieldEnum[]
  }

  /**
   * GroupStudySession findFirstOrThrow
   */
  export type GroupStudySessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupStudySession to fetch.
     */
    where?: GroupStudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupStudySessions to fetch.
     */
    orderBy?: GroupStudySessionOrderByWithRelationInput | GroupStudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupStudySessions.
     */
    cursor?: GroupStudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupStudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupStudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupStudySessions.
     */
    distinct?: GroupStudySessionScalarFieldEnum | GroupStudySessionScalarFieldEnum[]
  }

  /**
   * GroupStudySession findMany
   */
  export type GroupStudySessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupStudySessions to fetch.
     */
    where?: GroupStudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupStudySessions to fetch.
     */
    orderBy?: GroupStudySessionOrderByWithRelationInput | GroupStudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupStudySessions.
     */
    cursor?: GroupStudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupStudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupStudySessions.
     */
    skip?: number
    distinct?: GroupStudySessionScalarFieldEnum | GroupStudySessionScalarFieldEnum[]
  }

  /**
   * GroupStudySession create
   */
  export type GroupStudySessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupStudySession.
     */
    data: XOR<GroupStudySessionCreateInput, GroupStudySessionUncheckedCreateInput>
  }

  /**
   * GroupStudySession createMany
   */
  export type GroupStudySessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupStudySessions.
     */
    data: GroupStudySessionCreateManyInput | GroupStudySessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupStudySession createManyAndReturn
   */
  export type GroupStudySessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GroupStudySessions.
     */
    data: GroupStudySessionCreateManyInput | GroupStudySessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupStudySession update
   */
  export type GroupStudySessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupStudySession.
     */
    data: XOR<GroupStudySessionUpdateInput, GroupStudySessionUncheckedUpdateInput>
    /**
     * Choose, which GroupStudySession to update.
     */
    where: GroupStudySessionWhereUniqueInput
  }

  /**
   * GroupStudySession updateMany
   */
  export type GroupStudySessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupStudySessions.
     */
    data: XOR<GroupStudySessionUpdateManyMutationInput, GroupStudySessionUncheckedUpdateManyInput>
    /**
     * Filter which GroupStudySessions to update
     */
    where?: GroupStudySessionWhereInput
  }

  /**
   * GroupStudySession upsert
   */
  export type GroupStudySessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupStudySession to update in case it exists.
     */
    where: GroupStudySessionWhereUniqueInput
    /**
     * In case the GroupStudySession found by the `where` argument doesn't exist, create a new GroupStudySession with this data.
     */
    create: XOR<GroupStudySessionCreateInput, GroupStudySessionUncheckedCreateInput>
    /**
     * In case the GroupStudySession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupStudySessionUpdateInput, GroupStudySessionUncheckedUpdateInput>
  }

  /**
   * GroupStudySession delete
   */
  export type GroupStudySessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
    /**
     * Filter which GroupStudySession to delete.
     */
    where: GroupStudySessionWhereUniqueInput
  }

  /**
   * GroupStudySession deleteMany
   */
  export type GroupStudySessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupStudySessions to delete
     */
    where?: GroupStudySessionWhereInput
  }

  /**
   * GroupStudySession.user
   */
  export type GroupStudySession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GroupStudySession without action
   */
  export type GroupStudySessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupStudySession
     */
    select?: GroupStudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupStudySessionInclude<ExtArgs> | null
  }


  /**
   * Model HandlingSkillProgress
   */

  export type AggregateHandlingSkillProgress = {
    _count: HandlingSkillProgressCountAggregateOutputType | null
    _avg: HandlingSkillProgressAvgAggregateOutputType | null
    _sum: HandlingSkillProgressSumAggregateOutputType | null
    _min: HandlingSkillProgressMinAggregateOutputType | null
    _max: HandlingSkillProgressMaxAggregateOutputType | null
  }

  export type HandlingSkillProgressAvgAggregateOutputType = {
    avgScore: number | null
    sessionsCount: number | null
  }

  export type HandlingSkillProgressSumAggregateOutputType = {
    avgScore: number | null
    sessionsCount: number | null
  }

  export type HandlingSkillProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentLevel: string | null
    avgScore: number | null
    sessionsCount: number | null
    badges: string | null
    lastSession: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HandlingSkillProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentLevel: string | null
    avgScore: number | null
    sessionsCount: number | null
    badges: string | null
    lastSession: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HandlingSkillProgressCountAggregateOutputType = {
    id: number
    userId: number
    currentLevel: number
    avgScore: number
    sessionsCount: number
    badges: number
    lastSession: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HandlingSkillProgressAvgAggregateInputType = {
    avgScore?: true
    sessionsCount?: true
  }

  export type HandlingSkillProgressSumAggregateInputType = {
    avgScore?: true
    sessionsCount?: true
  }

  export type HandlingSkillProgressMinAggregateInputType = {
    id?: true
    userId?: true
    currentLevel?: true
    avgScore?: true
    sessionsCount?: true
    badges?: true
    lastSession?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HandlingSkillProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    currentLevel?: true
    avgScore?: true
    sessionsCount?: true
    badges?: true
    lastSession?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HandlingSkillProgressCountAggregateInputType = {
    id?: true
    userId?: true
    currentLevel?: true
    avgScore?: true
    sessionsCount?: true
    badges?: true
    lastSession?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HandlingSkillProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HandlingSkillProgress to aggregate.
     */
    where?: HandlingSkillProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandlingSkillProgresses to fetch.
     */
    orderBy?: HandlingSkillProgressOrderByWithRelationInput | HandlingSkillProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HandlingSkillProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandlingSkillProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandlingSkillProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HandlingSkillProgresses
    **/
    _count?: true | HandlingSkillProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HandlingSkillProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HandlingSkillProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HandlingSkillProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HandlingSkillProgressMaxAggregateInputType
  }

  export type GetHandlingSkillProgressAggregateType<T extends HandlingSkillProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateHandlingSkillProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHandlingSkillProgress[P]>
      : GetScalarType<T[P], AggregateHandlingSkillProgress[P]>
  }




  export type HandlingSkillProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HandlingSkillProgressWhereInput
    orderBy?: HandlingSkillProgressOrderByWithAggregationInput | HandlingSkillProgressOrderByWithAggregationInput[]
    by: HandlingSkillProgressScalarFieldEnum[] | HandlingSkillProgressScalarFieldEnum
    having?: HandlingSkillProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HandlingSkillProgressCountAggregateInputType | true
    _avg?: HandlingSkillProgressAvgAggregateInputType
    _sum?: HandlingSkillProgressSumAggregateInputType
    _min?: HandlingSkillProgressMinAggregateInputType
    _max?: HandlingSkillProgressMaxAggregateInputType
  }

  export type HandlingSkillProgressGroupByOutputType = {
    id: string
    userId: string
    currentLevel: string
    avgScore: number
    sessionsCount: number
    badges: string
    lastSession: Date
    createdAt: Date
    updatedAt: Date
    _count: HandlingSkillProgressCountAggregateOutputType | null
    _avg: HandlingSkillProgressAvgAggregateOutputType | null
    _sum: HandlingSkillProgressSumAggregateOutputType | null
    _min: HandlingSkillProgressMinAggregateOutputType | null
    _max: HandlingSkillProgressMaxAggregateOutputType | null
  }

  type GetHandlingSkillProgressGroupByPayload<T extends HandlingSkillProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HandlingSkillProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HandlingSkillProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HandlingSkillProgressGroupByOutputType[P]>
            : GetScalarType<T[P], HandlingSkillProgressGroupByOutputType[P]>
        }
      >
    >


  export type HandlingSkillProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLevel?: boolean
    avgScore?: boolean
    sessionsCount?: boolean
    badges?: boolean
    lastSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["handlingSkillProgress"]>

  export type HandlingSkillProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLevel?: boolean
    avgScore?: boolean
    sessionsCount?: boolean
    badges?: boolean
    lastSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["handlingSkillProgress"]>

  export type HandlingSkillProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    currentLevel?: boolean
    avgScore?: boolean
    sessionsCount?: boolean
    badges?: boolean
    lastSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HandlingSkillProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HandlingSkillProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HandlingSkillProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HandlingSkillProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentLevel: string
      avgScore: number
      sessionsCount: number
      badges: string
      lastSession: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["handlingSkillProgress"]>
    composites: {}
  }

  type HandlingSkillProgressGetPayload<S extends boolean | null | undefined | HandlingSkillProgressDefaultArgs> = $Result.GetResult<Prisma.$HandlingSkillProgressPayload, S>

  type HandlingSkillProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HandlingSkillProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HandlingSkillProgressCountAggregateInputType | true
    }

  export interface HandlingSkillProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HandlingSkillProgress'], meta: { name: 'HandlingSkillProgress' } }
    /**
     * Find zero or one HandlingSkillProgress that matches the filter.
     * @param {HandlingSkillProgressFindUniqueArgs} args - Arguments to find a HandlingSkillProgress
     * @example
     * // Get one HandlingSkillProgress
     * const handlingSkillProgress = await prisma.handlingSkillProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HandlingSkillProgressFindUniqueArgs>(args: SelectSubset<T, HandlingSkillProgressFindUniqueArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HandlingSkillProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HandlingSkillProgressFindUniqueOrThrowArgs} args - Arguments to find a HandlingSkillProgress
     * @example
     * // Get one HandlingSkillProgress
     * const handlingSkillProgress = await prisma.handlingSkillProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HandlingSkillProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, HandlingSkillProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HandlingSkillProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandlingSkillProgressFindFirstArgs} args - Arguments to find a HandlingSkillProgress
     * @example
     * // Get one HandlingSkillProgress
     * const handlingSkillProgress = await prisma.handlingSkillProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HandlingSkillProgressFindFirstArgs>(args?: SelectSubset<T, HandlingSkillProgressFindFirstArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HandlingSkillProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandlingSkillProgressFindFirstOrThrowArgs} args - Arguments to find a HandlingSkillProgress
     * @example
     * // Get one HandlingSkillProgress
     * const handlingSkillProgress = await prisma.handlingSkillProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HandlingSkillProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, HandlingSkillProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HandlingSkillProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandlingSkillProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HandlingSkillProgresses
     * const handlingSkillProgresses = await prisma.handlingSkillProgress.findMany()
     * 
     * // Get first 10 HandlingSkillProgresses
     * const handlingSkillProgresses = await prisma.handlingSkillProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const handlingSkillProgressWithIdOnly = await prisma.handlingSkillProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HandlingSkillProgressFindManyArgs>(args?: SelectSubset<T, HandlingSkillProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HandlingSkillProgress.
     * @param {HandlingSkillProgressCreateArgs} args - Arguments to create a HandlingSkillProgress.
     * @example
     * // Create one HandlingSkillProgress
     * const HandlingSkillProgress = await prisma.handlingSkillProgress.create({
     *   data: {
     *     // ... data to create a HandlingSkillProgress
     *   }
     * })
     * 
     */
    create<T extends HandlingSkillProgressCreateArgs>(args: SelectSubset<T, HandlingSkillProgressCreateArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HandlingSkillProgresses.
     * @param {HandlingSkillProgressCreateManyArgs} args - Arguments to create many HandlingSkillProgresses.
     * @example
     * // Create many HandlingSkillProgresses
     * const handlingSkillProgress = await prisma.handlingSkillProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HandlingSkillProgressCreateManyArgs>(args?: SelectSubset<T, HandlingSkillProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HandlingSkillProgresses and returns the data saved in the database.
     * @param {HandlingSkillProgressCreateManyAndReturnArgs} args - Arguments to create many HandlingSkillProgresses.
     * @example
     * // Create many HandlingSkillProgresses
     * const handlingSkillProgress = await prisma.handlingSkillProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HandlingSkillProgresses and only return the `id`
     * const handlingSkillProgressWithIdOnly = await prisma.handlingSkillProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HandlingSkillProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, HandlingSkillProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HandlingSkillProgress.
     * @param {HandlingSkillProgressDeleteArgs} args - Arguments to delete one HandlingSkillProgress.
     * @example
     * // Delete one HandlingSkillProgress
     * const HandlingSkillProgress = await prisma.handlingSkillProgress.delete({
     *   where: {
     *     // ... filter to delete one HandlingSkillProgress
     *   }
     * })
     * 
     */
    delete<T extends HandlingSkillProgressDeleteArgs>(args: SelectSubset<T, HandlingSkillProgressDeleteArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HandlingSkillProgress.
     * @param {HandlingSkillProgressUpdateArgs} args - Arguments to update one HandlingSkillProgress.
     * @example
     * // Update one HandlingSkillProgress
     * const handlingSkillProgress = await prisma.handlingSkillProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HandlingSkillProgressUpdateArgs>(args: SelectSubset<T, HandlingSkillProgressUpdateArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HandlingSkillProgresses.
     * @param {HandlingSkillProgressDeleteManyArgs} args - Arguments to filter HandlingSkillProgresses to delete.
     * @example
     * // Delete a few HandlingSkillProgresses
     * const { count } = await prisma.handlingSkillProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HandlingSkillProgressDeleteManyArgs>(args?: SelectSubset<T, HandlingSkillProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HandlingSkillProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandlingSkillProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HandlingSkillProgresses
     * const handlingSkillProgress = await prisma.handlingSkillProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HandlingSkillProgressUpdateManyArgs>(args: SelectSubset<T, HandlingSkillProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HandlingSkillProgress.
     * @param {HandlingSkillProgressUpsertArgs} args - Arguments to update or create a HandlingSkillProgress.
     * @example
     * // Update or create a HandlingSkillProgress
     * const handlingSkillProgress = await prisma.handlingSkillProgress.upsert({
     *   create: {
     *     // ... data to create a HandlingSkillProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HandlingSkillProgress we want to update
     *   }
     * })
     */
    upsert<T extends HandlingSkillProgressUpsertArgs>(args: SelectSubset<T, HandlingSkillProgressUpsertArgs<ExtArgs>>): Prisma__HandlingSkillProgressClient<$Result.GetResult<Prisma.$HandlingSkillProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HandlingSkillProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandlingSkillProgressCountArgs} args - Arguments to filter HandlingSkillProgresses to count.
     * @example
     * // Count the number of HandlingSkillProgresses
     * const count = await prisma.handlingSkillProgress.count({
     *   where: {
     *     // ... the filter for the HandlingSkillProgresses we want to count
     *   }
     * })
    **/
    count<T extends HandlingSkillProgressCountArgs>(
      args?: Subset<T, HandlingSkillProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HandlingSkillProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HandlingSkillProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandlingSkillProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HandlingSkillProgressAggregateArgs>(args: Subset<T, HandlingSkillProgressAggregateArgs>): Prisma.PrismaPromise<GetHandlingSkillProgressAggregateType<T>>

    /**
     * Group by HandlingSkillProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandlingSkillProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HandlingSkillProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HandlingSkillProgressGroupByArgs['orderBy'] }
        : { orderBy?: HandlingSkillProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HandlingSkillProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHandlingSkillProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HandlingSkillProgress model
   */
  readonly fields: HandlingSkillProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HandlingSkillProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HandlingSkillProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HandlingSkillProgress model
   */ 
  interface HandlingSkillProgressFieldRefs {
    readonly id: FieldRef<"HandlingSkillProgress", 'String'>
    readonly userId: FieldRef<"HandlingSkillProgress", 'String'>
    readonly currentLevel: FieldRef<"HandlingSkillProgress", 'String'>
    readonly avgScore: FieldRef<"HandlingSkillProgress", 'Float'>
    readonly sessionsCount: FieldRef<"HandlingSkillProgress", 'Int'>
    readonly badges: FieldRef<"HandlingSkillProgress", 'String'>
    readonly lastSession: FieldRef<"HandlingSkillProgress", 'DateTime'>
    readonly createdAt: FieldRef<"HandlingSkillProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"HandlingSkillProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HandlingSkillProgress findUnique
   */
  export type HandlingSkillProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * Filter, which HandlingSkillProgress to fetch.
     */
    where: HandlingSkillProgressWhereUniqueInput
  }

  /**
   * HandlingSkillProgress findUniqueOrThrow
   */
  export type HandlingSkillProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * Filter, which HandlingSkillProgress to fetch.
     */
    where: HandlingSkillProgressWhereUniqueInput
  }

  /**
   * HandlingSkillProgress findFirst
   */
  export type HandlingSkillProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * Filter, which HandlingSkillProgress to fetch.
     */
    where?: HandlingSkillProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandlingSkillProgresses to fetch.
     */
    orderBy?: HandlingSkillProgressOrderByWithRelationInput | HandlingSkillProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HandlingSkillProgresses.
     */
    cursor?: HandlingSkillProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandlingSkillProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandlingSkillProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HandlingSkillProgresses.
     */
    distinct?: HandlingSkillProgressScalarFieldEnum | HandlingSkillProgressScalarFieldEnum[]
  }

  /**
   * HandlingSkillProgress findFirstOrThrow
   */
  export type HandlingSkillProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * Filter, which HandlingSkillProgress to fetch.
     */
    where?: HandlingSkillProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandlingSkillProgresses to fetch.
     */
    orderBy?: HandlingSkillProgressOrderByWithRelationInput | HandlingSkillProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HandlingSkillProgresses.
     */
    cursor?: HandlingSkillProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandlingSkillProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandlingSkillProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HandlingSkillProgresses.
     */
    distinct?: HandlingSkillProgressScalarFieldEnum | HandlingSkillProgressScalarFieldEnum[]
  }

  /**
   * HandlingSkillProgress findMany
   */
  export type HandlingSkillProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * Filter, which HandlingSkillProgresses to fetch.
     */
    where?: HandlingSkillProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HandlingSkillProgresses to fetch.
     */
    orderBy?: HandlingSkillProgressOrderByWithRelationInput | HandlingSkillProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HandlingSkillProgresses.
     */
    cursor?: HandlingSkillProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HandlingSkillProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HandlingSkillProgresses.
     */
    skip?: number
    distinct?: HandlingSkillProgressScalarFieldEnum | HandlingSkillProgressScalarFieldEnum[]
  }

  /**
   * HandlingSkillProgress create
   */
  export type HandlingSkillProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a HandlingSkillProgress.
     */
    data: XOR<HandlingSkillProgressCreateInput, HandlingSkillProgressUncheckedCreateInput>
  }

  /**
   * HandlingSkillProgress createMany
   */
  export type HandlingSkillProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HandlingSkillProgresses.
     */
    data: HandlingSkillProgressCreateManyInput | HandlingSkillProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HandlingSkillProgress createManyAndReturn
   */
  export type HandlingSkillProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HandlingSkillProgresses.
     */
    data: HandlingSkillProgressCreateManyInput | HandlingSkillProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HandlingSkillProgress update
   */
  export type HandlingSkillProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a HandlingSkillProgress.
     */
    data: XOR<HandlingSkillProgressUpdateInput, HandlingSkillProgressUncheckedUpdateInput>
    /**
     * Choose, which HandlingSkillProgress to update.
     */
    where: HandlingSkillProgressWhereUniqueInput
  }

  /**
   * HandlingSkillProgress updateMany
   */
  export type HandlingSkillProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HandlingSkillProgresses.
     */
    data: XOR<HandlingSkillProgressUpdateManyMutationInput, HandlingSkillProgressUncheckedUpdateManyInput>
    /**
     * Filter which HandlingSkillProgresses to update
     */
    where?: HandlingSkillProgressWhereInput
  }

  /**
   * HandlingSkillProgress upsert
   */
  export type HandlingSkillProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the HandlingSkillProgress to update in case it exists.
     */
    where: HandlingSkillProgressWhereUniqueInput
    /**
     * In case the HandlingSkillProgress found by the `where` argument doesn't exist, create a new HandlingSkillProgress with this data.
     */
    create: XOR<HandlingSkillProgressCreateInput, HandlingSkillProgressUncheckedCreateInput>
    /**
     * In case the HandlingSkillProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HandlingSkillProgressUpdateInput, HandlingSkillProgressUncheckedUpdateInput>
  }

  /**
   * HandlingSkillProgress delete
   */
  export type HandlingSkillProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
    /**
     * Filter which HandlingSkillProgress to delete.
     */
    where: HandlingSkillProgressWhereUniqueInput
  }

  /**
   * HandlingSkillProgress deleteMany
   */
  export type HandlingSkillProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HandlingSkillProgresses to delete
     */
    where?: HandlingSkillProgressWhereInput
  }

  /**
   * HandlingSkillProgress without action
   */
  export type HandlingSkillProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HandlingSkillProgress
     */
    select?: HandlingSkillProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandlingSkillProgressInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const QuestionPaperScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subject: 'subject',
    gradeLevel: 'gradeLevel',
    language: 'language',
    imageUrl: 'imageUrl',
    imageHash: 'imageHash',
    totalQuestions: 'totalQuestions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    usageCount: 'usageCount'
  };

  export type QuestionPaperScalarFieldEnum = (typeof QuestionPaperScalarFieldEnum)[keyof typeof QuestionPaperScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    questionPaperId: 'questionPaperId',
    questionNumber: 'questionNumber',
    questionText: 'questionText',
    maxScore: 'maxScore',
    topic: 'topic',
    concept: 'concept',
    positionX: 'positionX',
    positionY: 'positionY',
    createdAt: 'createdAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    grade: 'grade',
    school: 'school',
    languagePreference: 'languagePreference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GradingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questionPaperId: 'questionPaperId',
    answerSheetUrl: 'answerSheetUrl',
    totalPages: 'totalPages',
    subject: 'subject',
    language: 'language',
    gradeLevel: 'gradeLevel',
    totalScore: 'totalScore',
    feedback: 'feedback',
    matchingMode: 'matchingMode',
    totalQuestions: 'totalQuestions',
    answeredQuestions: 'answeredQuestions',
    annotations: 'annotations',
    imageDimensions: 'imageDimensions',
    createdAt: 'createdAt'
  };

  export type GradingScalarFieldEnum = (typeof GradingScalarFieldEnum)[keyof typeof GradingScalarFieldEnum]


  export const GradingPageScalarFieldEnum: {
    id: 'id',
    gradingId: 'gradingId',
    pageNumber: 'pageNumber',
    imageUrl: 'imageUrl',
    annotations: 'annotations',
    imageDimensions: 'imageDimensions',
    createdAt: 'createdAt'
  };

  export type GradingPageScalarFieldEnum = (typeof GradingPageScalarFieldEnum)[keyof typeof GradingPageScalarFieldEnum]


  export const PageAnswerScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    questionNumber: 'questionNumber',
    studentAnswer: 'studentAnswer',
    correct: 'correct',
    score: 'score',
    remarks: 'remarks',
    matched: 'matched',
    matchConfidence: 'matchConfidence',
    positionX: 'positionX',
    positionY: 'positionY',
    continuedFrom: 'continuedFrom',
    continuedTo: 'continuedTo',
    createdAt: 'createdAt'
  };

  export type PageAnswerScalarFieldEnum = (typeof PageAnswerScalarFieldEnum)[keyof typeof PageAnswerScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    gradingId: 'gradingId',
    questionNumber: 'questionNumber',
    studentAnswer: 'studentAnswer',
    correct: 'correct',
    score: 'score',
    remarks: 'remarks',
    matched: 'matched',
    matchConfidence: 'matchConfidence',
    positionX: 'positionX',
    positionY: 'positionY',
    createdAt: 'createdAt'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const DoubtScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questionImage: 'questionImage',
    questionText: 'questionText',
    subject: 'subject',
    language: 'language',
    explanation: 'explanation',
    annotations: 'annotations',
    imageDimensions: 'imageDimensions',
    conversationId: 'conversationId',
    worksheetId: 'worksheetId',
    questionNumber: 'questionNumber',
    isInRevision: 'isInRevision',
    addedToRevisionAt: 'addedToRevisionAt',
    isFavorite: 'isFavorite',
    messageCount: 'messageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DoubtScalarFieldEnum = (typeof DoubtScalarFieldEnum)[keyof typeof DoubtScalarFieldEnum]


  export const DoubtMessageScalarFieldEnum: {
    id: 'id',
    doubtId: 'doubtId',
    role: 'role',
    content: 'content',
    audioUrl: 'audioUrl',
    createdAt: 'createdAt'
  };

  export type DoubtMessageScalarFieldEnum = (typeof DoubtMessageScalarFieldEnum)[keyof typeof DoubtMessageScalarFieldEnum]


  export const WorksheetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    imageUrl: 'imageUrl',
    imageHash: 'imageHash',
    totalQuestions: 'totalQuestions',
    currentQuestion: 'currentQuestion',
    sessionId: 'sessionId',
    expiresAt: 'expiresAt',
    title: 'title',
    subject: 'subject',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorksheetScalarFieldEnum = (typeof WorksheetScalarFieldEnum)[keyof typeof WorksheetScalarFieldEnum]


  export const WorksheetQuestionScalarFieldEnum: {
    id: 'id',
    worksheetId: 'worksheetId',
    questionNumber: 'questionNumber',
    doubtId: 'doubtId',
    status: 'status',
    cachedExplanation: 'cachedExplanation',
    createdAt: 'createdAt'
  };

  export type WorksheetQuestionScalarFieldEnum = (typeof WorksheetQuestionScalarFieldEnum)[keyof typeof WorksheetQuestionScalarFieldEnum]


  export const DoubtRatingScalarFieldEnum: {
    id: 'id',
    doubtId: 'doubtId',
    userId: 'userId',
    rating: 'rating',
    feedback: 'feedback',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DoubtRatingScalarFieldEnum = (typeof DoubtRatingScalarFieldEnum)[keyof typeof DoubtRatingScalarFieldEnum]


  export const RevisionSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topic: 'topic',
    subject: 'subject',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    score: 'score',
    weakAreas: 'weakAreas',
    phasesCompleted: 'phasesCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RevisionSessionScalarFieldEnum = (typeof RevisionSessionScalarFieldEnum)[keyof typeof RevisionSessionScalarFieldEnum]


  export const WeakTopicScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topic: 'topic',
    subject: 'subject',
    occurrences: 'occurrences',
    lastSeen: 'lastSeen',
    improved: 'improved',
    improvedAt: 'improvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeakTopicScalarFieldEnum = (typeof WeakTopicScalarFieldEnum)[keyof typeof WeakTopicScalarFieldEnum]


  export const GroupStudySessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topic: 'topic',
    subject: 'subject',
    question: 'question',
    classmate1Name: 'classmate1Name',
    classmate2Name: 'classmate2Name',
    studentAnswer: 'studentAnswer',
    classmate1Question: 'classmate1Question',
    classmate2Counter: 'classmate2Counter',
    classmate1Response: 'classmate1Response',
    classmate2Response: 'classmate2Response',
    handlingScore: 'handlingScore',
    strengths: 'strengths',
    improvements: 'improvements',
    challengesCount: 'challengesCount',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupStudySessionScalarFieldEnum = (typeof GroupStudySessionScalarFieldEnum)[keyof typeof GroupStudySessionScalarFieldEnum]


  export const HandlingSkillProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentLevel: 'currentLevel',
    avgScore: 'avgScore',
    sessionsCount: 'sessionsCount',
    badges: 'badges',
    lastSession: 'lastSession',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HandlingSkillProgressScalarFieldEnum = (typeof HandlingSkillProgressScalarFieldEnum)[keyof typeof HandlingSkillProgressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type QuestionPaperWhereInput = {
    AND?: QuestionPaperWhereInput | QuestionPaperWhereInput[]
    OR?: QuestionPaperWhereInput[]
    NOT?: QuestionPaperWhereInput | QuestionPaperWhereInput[]
    id?: StringFilter<"QuestionPaper"> | string
    title?: StringNullableFilter<"QuestionPaper"> | string | null
    subject?: StringFilter<"QuestionPaper"> | string
    gradeLevel?: StringFilter<"QuestionPaper"> | string
    language?: StringFilter<"QuestionPaper"> | string
    imageUrl?: StringFilter<"QuestionPaper"> | string
    imageHash?: StringFilter<"QuestionPaper"> | string
    totalQuestions?: IntFilter<"QuestionPaper"> | number
    createdAt?: DateTimeFilter<"QuestionPaper"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionPaper"> | Date | string
    usageCount?: IntFilter<"QuestionPaper"> | number
    questions?: QuestionListRelationFilter
    gradings?: GradingListRelationFilter
  }

  export type QuestionPaperOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    subject?: SortOrder
    gradeLevel?: SortOrder
    language?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usageCount?: SortOrder
    questions?: QuestionOrderByRelationAggregateInput
    gradings?: GradingOrderByRelationAggregateInput
  }

  export type QuestionPaperWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    imageHash?: string
    AND?: QuestionPaperWhereInput | QuestionPaperWhereInput[]
    OR?: QuestionPaperWhereInput[]
    NOT?: QuestionPaperWhereInput | QuestionPaperWhereInput[]
    title?: StringNullableFilter<"QuestionPaper"> | string | null
    subject?: StringFilter<"QuestionPaper"> | string
    gradeLevel?: StringFilter<"QuestionPaper"> | string
    language?: StringFilter<"QuestionPaper"> | string
    imageUrl?: StringFilter<"QuestionPaper"> | string
    totalQuestions?: IntFilter<"QuestionPaper"> | number
    createdAt?: DateTimeFilter<"QuestionPaper"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionPaper"> | Date | string
    usageCount?: IntFilter<"QuestionPaper"> | number
    questions?: QuestionListRelationFilter
    gradings?: GradingListRelationFilter
  }, "id" | "imageHash">

  export type QuestionPaperOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    subject?: SortOrder
    gradeLevel?: SortOrder
    language?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usageCount?: SortOrder
    _count?: QuestionPaperCountOrderByAggregateInput
    _avg?: QuestionPaperAvgOrderByAggregateInput
    _max?: QuestionPaperMaxOrderByAggregateInput
    _min?: QuestionPaperMinOrderByAggregateInput
    _sum?: QuestionPaperSumOrderByAggregateInput
  }

  export type QuestionPaperScalarWhereWithAggregatesInput = {
    AND?: QuestionPaperScalarWhereWithAggregatesInput | QuestionPaperScalarWhereWithAggregatesInput[]
    OR?: QuestionPaperScalarWhereWithAggregatesInput[]
    NOT?: QuestionPaperScalarWhereWithAggregatesInput | QuestionPaperScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionPaper"> | string
    title?: StringNullableWithAggregatesFilter<"QuestionPaper"> | string | null
    subject?: StringWithAggregatesFilter<"QuestionPaper"> | string
    gradeLevel?: StringWithAggregatesFilter<"QuestionPaper"> | string
    language?: StringWithAggregatesFilter<"QuestionPaper"> | string
    imageUrl?: StringWithAggregatesFilter<"QuestionPaper"> | string
    imageHash?: StringWithAggregatesFilter<"QuestionPaper"> | string
    totalQuestions?: IntWithAggregatesFilter<"QuestionPaper"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuestionPaper"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionPaper"> | Date | string
    usageCount?: IntWithAggregatesFilter<"QuestionPaper"> | number
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    questionPaperId?: StringFilter<"Question"> | string
    questionNumber?: StringFilter<"Question"> | string
    questionText?: StringFilter<"Question"> | string
    maxScore?: FloatNullableFilter<"Question"> | number | null
    topic?: StringNullableFilter<"Question"> | string | null
    concept?: StringNullableFilter<"Question"> | string | null
    positionX?: FloatNullableFilter<"Question"> | number | null
    positionY?: FloatNullableFilter<"Question"> | number | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    questionPaper?: XOR<QuestionPaperRelationFilter, QuestionPaperWhereInput>
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    questionPaperId?: SortOrder
    questionNumber?: SortOrder
    questionText?: SortOrder
    maxScore?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    concept?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    questionPaper?: QuestionPaperOrderByWithRelationInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    questionPaperId_questionNumber?: QuestionQuestionPaperIdQuestionNumberCompoundUniqueInput
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    questionPaperId?: StringFilter<"Question"> | string
    questionNumber?: StringFilter<"Question"> | string
    questionText?: StringFilter<"Question"> | string
    maxScore?: FloatNullableFilter<"Question"> | number | null
    topic?: StringNullableFilter<"Question"> | string | null
    concept?: StringNullableFilter<"Question"> | string | null
    positionX?: FloatNullableFilter<"Question"> | number | null
    positionY?: FloatNullableFilter<"Question"> | number | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    questionPaper?: XOR<QuestionPaperRelationFilter, QuestionPaperWhereInput>
  }, "id" | "questionPaperId_questionNumber">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    questionPaperId?: SortOrder
    questionNumber?: SortOrder
    questionText?: SortOrder
    maxScore?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    concept?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    questionPaperId?: StringWithAggregatesFilter<"Question"> | string
    questionNumber?: StringWithAggregatesFilter<"Question"> | string
    questionText?: StringWithAggregatesFilter<"Question"> | string
    maxScore?: FloatNullableWithAggregatesFilter<"Question"> | number | null
    topic?: StringNullableWithAggregatesFilter<"Question"> | string | null
    concept?: StringNullableWithAggregatesFilter<"Question"> | string | null
    positionX?: FloatNullableWithAggregatesFilter<"Question"> | number | null
    positionY?: FloatNullableWithAggregatesFilter<"Question"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    grade?: StringNullableFilter<"User"> | string | null
    school?: StringNullableFilter<"User"> | string | null
    languagePreference?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    gradings?: GradingListRelationFilter
    doubts?: DoubtListRelationFilter
    worksheets?: WorksheetListRelationFilter
    doubtRatings?: DoubtRatingListRelationFilter
    revisionSessions?: RevisionSessionListRelationFilter
    weakTopics?: WeakTopicListRelationFilter
    groupStudySessions?: GroupStudySessionListRelationFilter
    handlingSkillProgress?: XOR<HandlingSkillProgressNullableRelationFilter, HandlingSkillProgressWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    grade?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    gradings?: GradingOrderByRelationAggregateInput
    doubts?: DoubtOrderByRelationAggregateInput
    worksheets?: WorksheetOrderByRelationAggregateInput
    doubtRatings?: DoubtRatingOrderByRelationAggregateInput
    revisionSessions?: RevisionSessionOrderByRelationAggregateInput
    weakTopics?: WeakTopicOrderByRelationAggregateInput
    groupStudySessions?: GroupStudySessionOrderByRelationAggregateInput
    handlingSkillProgress?: HandlingSkillProgressOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    grade?: StringNullableFilter<"User"> | string | null
    school?: StringNullableFilter<"User"> | string | null
    languagePreference?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    gradings?: GradingListRelationFilter
    doubts?: DoubtListRelationFilter
    worksheets?: WorksheetListRelationFilter
    doubtRatings?: DoubtRatingListRelationFilter
    revisionSessions?: RevisionSessionListRelationFilter
    weakTopics?: WeakTopicListRelationFilter
    groupStudySessions?: GroupStudySessionListRelationFilter
    handlingSkillProgress?: XOR<HandlingSkillProgressNullableRelationFilter, HandlingSkillProgressWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    grade?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    grade?: StringNullableWithAggregatesFilter<"User"> | string | null
    school?: StringNullableWithAggregatesFilter<"User"> | string | null
    languagePreference?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type GradingWhereInput = {
    AND?: GradingWhereInput | GradingWhereInput[]
    OR?: GradingWhereInput[]
    NOT?: GradingWhereInput | GradingWhereInput[]
    id?: StringFilter<"Grading"> | string
    userId?: StringNullableFilter<"Grading"> | string | null
    questionPaperId?: StringNullableFilter<"Grading"> | string | null
    answerSheetUrl?: StringFilter<"Grading"> | string
    totalPages?: IntFilter<"Grading"> | number
    subject?: StringFilter<"Grading"> | string
    language?: StringFilter<"Grading"> | string
    gradeLevel?: StringFilter<"Grading"> | string
    totalScore?: StringFilter<"Grading"> | string
    feedback?: StringFilter<"Grading"> | string
    matchingMode?: StringNullableFilter<"Grading"> | string | null
    totalQuestions?: IntNullableFilter<"Grading"> | number | null
    answeredQuestions?: IntNullableFilter<"Grading"> | number | null
    annotations?: StringNullableFilter<"Grading"> | string | null
    imageDimensions?: StringNullableFilter<"Grading"> | string | null
    createdAt?: DateTimeFilter<"Grading"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    questionPaper?: XOR<QuestionPaperNullableRelationFilter, QuestionPaperWhereInput> | null
    pages?: GradingPageListRelationFilter
    answers?: AnswerListRelationFilter
  }

  export type GradingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    questionPaperId?: SortOrderInput | SortOrder
    answerSheetUrl?: SortOrder
    totalPages?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    gradeLevel?: SortOrder
    totalScore?: SortOrder
    feedback?: SortOrder
    matchingMode?: SortOrderInput | SortOrder
    totalQuestions?: SortOrderInput | SortOrder
    answeredQuestions?: SortOrderInput | SortOrder
    annotations?: SortOrderInput | SortOrder
    imageDimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    questionPaper?: QuestionPaperOrderByWithRelationInput
    pages?: GradingPageOrderByRelationAggregateInput
    answers?: AnswerOrderByRelationAggregateInput
  }

  export type GradingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradingWhereInput | GradingWhereInput[]
    OR?: GradingWhereInput[]
    NOT?: GradingWhereInput | GradingWhereInput[]
    userId?: StringNullableFilter<"Grading"> | string | null
    questionPaperId?: StringNullableFilter<"Grading"> | string | null
    answerSheetUrl?: StringFilter<"Grading"> | string
    totalPages?: IntFilter<"Grading"> | number
    subject?: StringFilter<"Grading"> | string
    language?: StringFilter<"Grading"> | string
    gradeLevel?: StringFilter<"Grading"> | string
    totalScore?: StringFilter<"Grading"> | string
    feedback?: StringFilter<"Grading"> | string
    matchingMode?: StringNullableFilter<"Grading"> | string | null
    totalQuestions?: IntNullableFilter<"Grading"> | number | null
    answeredQuestions?: IntNullableFilter<"Grading"> | number | null
    annotations?: StringNullableFilter<"Grading"> | string | null
    imageDimensions?: StringNullableFilter<"Grading"> | string | null
    createdAt?: DateTimeFilter<"Grading"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    questionPaper?: XOR<QuestionPaperNullableRelationFilter, QuestionPaperWhereInput> | null
    pages?: GradingPageListRelationFilter
    answers?: AnswerListRelationFilter
  }, "id">

  export type GradingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    questionPaperId?: SortOrderInput | SortOrder
    answerSheetUrl?: SortOrder
    totalPages?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    gradeLevel?: SortOrder
    totalScore?: SortOrder
    feedback?: SortOrder
    matchingMode?: SortOrderInput | SortOrder
    totalQuestions?: SortOrderInput | SortOrder
    answeredQuestions?: SortOrderInput | SortOrder
    annotations?: SortOrderInput | SortOrder
    imageDimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GradingCountOrderByAggregateInput
    _avg?: GradingAvgOrderByAggregateInput
    _max?: GradingMaxOrderByAggregateInput
    _min?: GradingMinOrderByAggregateInput
    _sum?: GradingSumOrderByAggregateInput
  }

  export type GradingScalarWhereWithAggregatesInput = {
    AND?: GradingScalarWhereWithAggregatesInput | GradingScalarWhereWithAggregatesInput[]
    OR?: GradingScalarWhereWithAggregatesInput[]
    NOT?: GradingScalarWhereWithAggregatesInput | GradingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grading"> | string
    userId?: StringNullableWithAggregatesFilter<"Grading"> | string | null
    questionPaperId?: StringNullableWithAggregatesFilter<"Grading"> | string | null
    answerSheetUrl?: StringWithAggregatesFilter<"Grading"> | string
    totalPages?: IntWithAggregatesFilter<"Grading"> | number
    subject?: StringWithAggregatesFilter<"Grading"> | string
    language?: StringWithAggregatesFilter<"Grading"> | string
    gradeLevel?: StringWithAggregatesFilter<"Grading"> | string
    totalScore?: StringWithAggregatesFilter<"Grading"> | string
    feedback?: StringWithAggregatesFilter<"Grading"> | string
    matchingMode?: StringNullableWithAggregatesFilter<"Grading"> | string | null
    totalQuestions?: IntNullableWithAggregatesFilter<"Grading"> | number | null
    answeredQuestions?: IntNullableWithAggregatesFilter<"Grading"> | number | null
    annotations?: StringNullableWithAggregatesFilter<"Grading"> | string | null
    imageDimensions?: StringNullableWithAggregatesFilter<"Grading"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Grading"> | Date | string
  }

  export type GradingPageWhereInput = {
    AND?: GradingPageWhereInput | GradingPageWhereInput[]
    OR?: GradingPageWhereInput[]
    NOT?: GradingPageWhereInput | GradingPageWhereInput[]
    id?: StringFilter<"GradingPage"> | string
    gradingId?: StringFilter<"GradingPage"> | string
    pageNumber?: IntFilter<"GradingPage"> | number
    imageUrl?: StringFilter<"GradingPage"> | string
    annotations?: StringNullableFilter<"GradingPage"> | string | null
    imageDimensions?: StringNullableFilter<"GradingPage"> | string | null
    createdAt?: DateTimeFilter<"GradingPage"> | Date | string
    grading?: XOR<GradingRelationFilter, GradingWhereInput>
    pageAnswers?: PageAnswerListRelationFilter
  }

  export type GradingPageOrderByWithRelationInput = {
    id?: SortOrder
    gradingId?: SortOrder
    pageNumber?: SortOrder
    imageUrl?: SortOrder
    annotations?: SortOrderInput | SortOrder
    imageDimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    grading?: GradingOrderByWithRelationInput
    pageAnswers?: PageAnswerOrderByRelationAggregateInput
  }

  export type GradingPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gradingId_pageNumber?: GradingPageGradingIdPageNumberCompoundUniqueInput
    AND?: GradingPageWhereInput | GradingPageWhereInput[]
    OR?: GradingPageWhereInput[]
    NOT?: GradingPageWhereInput | GradingPageWhereInput[]
    gradingId?: StringFilter<"GradingPage"> | string
    pageNumber?: IntFilter<"GradingPage"> | number
    imageUrl?: StringFilter<"GradingPage"> | string
    annotations?: StringNullableFilter<"GradingPage"> | string | null
    imageDimensions?: StringNullableFilter<"GradingPage"> | string | null
    createdAt?: DateTimeFilter<"GradingPage"> | Date | string
    grading?: XOR<GradingRelationFilter, GradingWhereInput>
    pageAnswers?: PageAnswerListRelationFilter
  }, "id" | "gradingId_pageNumber">

  export type GradingPageOrderByWithAggregationInput = {
    id?: SortOrder
    gradingId?: SortOrder
    pageNumber?: SortOrder
    imageUrl?: SortOrder
    annotations?: SortOrderInput | SortOrder
    imageDimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GradingPageCountOrderByAggregateInput
    _avg?: GradingPageAvgOrderByAggregateInput
    _max?: GradingPageMaxOrderByAggregateInput
    _min?: GradingPageMinOrderByAggregateInput
    _sum?: GradingPageSumOrderByAggregateInput
  }

  export type GradingPageScalarWhereWithAggregatesInput = {
    AND?: GradingPageScalarWhereWithAggregatesInput | GradingPageScalarWhereWithAggregatesInput[]
    OR?: GradingPageScalarWhereWithAggregatesInput[]
    NOT?: GradingPageScalarWhereWithAggregatesInput | GradingPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GradingPage"> | string
    gradingId?: StringWithAggregatesFilter<"GradingPage"> | string
    pageNumber?: IntWithAggregatesFilter<"GradingPage"> | number
    imageUrl?: StringWithAggregatesFilter<"GradingPage"> | string
    annotations?: StringNullableWithAggregatesFilter<"GradingPage"> | string | null
    imageDimensions?: StringNullableWithAggregatesFilter<"GradingPage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GradingPage"> | Date | string
  }

  export type PageAnswerWhereInput = {
    AND?: PageAnswerWhereInput | PageAnswerWhereInput[]
    OR?: PageAnswerWhereInput[]
    NOT?: PageAnswerWhereInput | PageAnswerWhereInput[]
    id?: StringFilter<"PageAnswer"> | string
    pageId?: StringFilter<"PageAnswer"> | string
    questionNumber?: StringFilter<"PageAnswer"> | string
    studentAnswer?: StringNullableFilter<"PageAnswer"> | string | null
    correct?: BoolFilter<"PageAnswer"> | boolean
    score?: StringFilter<"PageAnswer"> | string
    remarks?: StringFilter<"PageAnswer"> | string
    matched?: BoolFilter<"PageAnswer"> | boolean
    matchConfidence?: FloatNullableFilter<"PageAnswer"> | number | null
    positionX?: FloatNullableFilter<"PageAnswer"> | number | null
    positionY?: FloatNullableFilter<"PageAnswer"> | number | null
    continuedFrom?: IntNullableFilter<"PageAnswer"> | number | null
    continuedTo?: IntNullableFilter<"PageAnswer"> | number | null
    createdAt?: DateTimeFilter<"PageAnswer"> | Date | string
    page?: XOR<GradingPageRelationFilter, GradingPageWhereInput>
  }

  export type PageAnswerOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrderInput | SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    continuedFrom?: SortOrderInput | SortOrder
    continuedTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    page?: GradingPageOrderByWithRelationInput
  }

  export type PageAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PageAnswerWhereInput | PageAnswerWhereInput[]
    OR?: PageAnswerWhereInput[]
    NOT?: PageAnswerWhereInput | PageAnswerWhereInput[]
    pageId?: StringFilter<"PageAnswer"> | string
    questionNumber?: StringFilter<"PageAnswer"> | string
    studentAnswer?: StringNullableFilter<"PageAnswer"> | string | null
    correct?: BoolFilter<"PageAnswer"> | boolean
    score?: StringFilter<"PageAnswer"> | string
    remarks?: StringFilter<"PageAnswer"> | string
    matched?: BoolFilter<"PageAnswer"> | boolean
    matchConfidence?: FloatNullableFilter<"PageAnswer"> | number | null
    positionX?: FloatNullableFilter<"PageAnswer"> | number | null
    positionY?: FloatNullableFilter<"PageAnswer"> | number | null
    continuedFrom?: IntNullableFilter<"PageAnswer"> | number | null
    continuedTo?: IntNullableFilter<"PageAnswer"> | number | null
    createdAt?: DateTimeFilter<"PageAnswer"> | Date | string
    page?: XOR<GradingPageRelationFilter, GradingPageWhereInput>
  }, "id">

  export type PageAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrderInput | SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    continuedFrom?: SortOrderInput | SortOrder
    continuedTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PageAnswerCountOrderByAggregateInput
    _avg?: PageAnswerAvgOrderByAggregateInput
    _max?: PageAnswerMaxOrderByAggregateInput
    _min?: PageAnswerMinOrderByAggregateInput
    _sum?: PageAnswerSumOrderByAggregateInput
  }

  export type PageAnswerScalarWhereWithAggregatesInput = {
    AND?: PageAnswerScalarWhereWithAggregatesInput | PageAnswerScalarWhereWithAggregatesInput[]
    OR?: PageAnswerScalarWhereWithAggregatesInput[]
    NOT?: PageAnswerScalarWhereWithAggregatesInput | PageAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PageAnswer"> | string
    pageId?: StringWithAggregatesFilter<"PageAnswer"> | string
    questionNumber?: StringWithAggregatesFilter<"PageAnswer"> | string
    studentAnswer?: StringNullableWithAggregatesFilter<"PageAnswer"> | string | null
    correct?: BoolWithAggregatesFilter<"PageAnswer"> | boolean
    score?: StringWithAggregatesFilter<"PageAnswer"> | string
    remarks?: StringWithAggregatesFilter<"PageAnswer"> | string
    matched?: BoolWithAggregatesFilter<"PageAnswer"> | boolean
    matchConfidence?: FloatNullableWithAggregatesFilter<"PageAnswer"> | number | null
    positionX?: FloatNullableWithAggregatesFilter<"PageAnswer"> | number | null
    positionY?: FloatNullableWithAggregatesFilter<"PageAnswer"> | number | null
    continuedFrom?: IntNullableWithAggregatesFilter<"PageAnswer"> | number | null
    continuedTo?: IntNullableWithAggregatesFilter<"PageAnswer"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PageAnswer"> | Date | string
  }

  export type AnswerWhereInput = {
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    id?: StringFilter<"Answer"> | string
    gradingId?: StringFilter<"Answer"> | string
    questionNumber?: StringFilter<"Answer"> | string
    studentAnswer?: StringNullableFilter<"Answer"> | string | null
    correct?: BoolFilter<"Answer"> | boolean
    score?: StringFilter<"Answer"> | string
    remarks?: StringFilter<"Answer"> | string
    matched?: BoolFilter<"Answer"> | boolean
    matchConfidence?: FloatNullableFilter<"Answer"> | number | null
    positionX?: FloatNullableFilter<"Answer"> | number | null
    positionY?: FloatNullableFilter<"Answer"> | number | null
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    grading?: XOR<GradingRelationFilter, GradingWhereInput>
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    gradingId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrderInput | SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    grading?: GradingOrderByWithRelationInput
  }

  export type AnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    gradingId?: StringFilter<"Answer"> | string
    questionNumber?: StringFilter<"Answer"> | string
    studentAnswer?: StringNullableFilter<"Answer"> | string | null
    correct?: BoolFilter<"Answer"> | boolean
    score?: StringFilter<"Answer"> | string
    remarks?: StringFilter<"Answer"> | string
    matched?: BoolFilter<"Answer"> | boolean
    matchConfidence?: FloatNullableFilter<"Answer"> | number | null
    positionX?: FloatNullableFilter<"Answer"> | number | null
    positionY?: FloatNullableFilter<"Answer"> | number | null
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    grading?: XOR<GradingRelationFilter, GradingWhereInput>
  }, "id">

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    gradingId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrderInput | SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _avg?: AnswerAvgOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
    _sum?: AnswerSumOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    OR?: AnswerScalarWhereWithAggregatesInput[]
    NOT?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Answer"> | string
    gradingId?: StringWithAggregatesFilter<"Answer"> | string
    questionNumber?: StringWithAggregatesFilter<"Answer"> | string
    studentAnswer?: StringNullableWithAggregatesFilter<"Answer"> | string | null
    correct?: BoolWithAggregatesFilter<"Answer"> | boolean
    score?: StringWithAggregatesFilter<"Answer"> | string
    remarks?: StringWithAggregatesFilter<"Answer"> | string
    matched?: BoolWithAggregatesFilter<"Answer"> | boolean
    matchConfidence?: FloatNullableWithAggregatesFilter<"Answer"> | number | null
    positionX?: FloatNullableWithAggregatesFilter<"Answer"> | number | null
    positionY?: FloatNullableWithAggregatesFilter<"Answer"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Answer"> | Date | string
  }

  export type DoubtWhereInput = {
    AND?: DoubtWhereInput | DoubtWhereInput[]
    OR?: DoubtWhereInput[]
    NOT?: DoubtWhereInput | DoubtWhereInput[]
    id?: StringFilter<"Doubt"> | string
    userId?: StringNullableFilter<"Doubt"> | string | null
    questionImage?: StringNullableFilter<"Doubt"> | string | null
    questionText?: StringFilter<"Doubt"> | string
    subject?: StringFilter<"Doubt"> | string
    language?: StringFilter<"Doubt"> | string
    explanation?: StringFilter<"Doubt"> | string
    annotations?: StringNullableFilter<"Doubt"> | string | null
    imageDimensions?: StringNullableFilter<"Doubt"> | string | null
    conversationId?: StringFilter<"Doubt"> | string
    worksheetId?: StringNullableFilter<"Doubt"> | string | null
    questionNumber?: IntNullableFilter<"Doubt"> | number | null
    isInRevision?: BoolFilter<"Doubt"> | boolean
    addedToRevisionAt?: DateTimeNullableFilter<"Doubt"> | Date | string | null
    isFavorite?: BoolFilter<"Doubt"> | boolean
    messageCount?: IntFilter<"Doubt"> | number
    createdAt?: DateTimeFilter<"Doubt"> | Date | string
    updatedAt?: DateTimeFilter<"Doubt"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: DoubtMessageListRelationFilter
    worksheet?: XOR<WorksheetNullableRelationFilter, WorksheetWhereInput> | null
    worksheetQuestions?: WorksheetQuestionListRelationFilter
    rating?: XOR<DoubtRatingNullableRelationFilter, DoubtRatingWhereInput> | null
  }

  export type DoubtOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    questionImage?: SortOrderInput | SortOrder
    questionText?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    explanation?: SortOrder
    annotations?: SortOrderInput | SortOrder
    imageDimensions?: SortOrderInput | SortOrder
    conversationId?: SortOrder
    worksheetId?: SortOrderInput | SortOrder
    questionNumber?: SortOrderInput | SortOrder
    isInRevision?: SortOrder
    addedToRevisionAt?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: DoubtMessageOrderByRelationAggregateInput
    worksheet?: WorksheetOrderByWithRelationInput
    worksheetQuestions?: WorksheetQuestionOrderByRelationAggregateInput
    rating?: DoubtRatingOrderByWithRelationInput
  }

  export type DoubtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId?: string
    AND?: DoubtWhereInput | DoubtWhereInput[]
    OR?: DoubtWhereInput[]
    NOT?: DoubtWhereInput | DoubtWhereInput[]
    userId?: StringNullableFilter<"Doubt"> | string | null
    questionImage?: StringNullableFilter<"Doubt"> | string | null
    questionText?: StringFilter<"Doubt"> | string
    subject?: StringFilter<"Doubt"> | string
    language?: StringFilter<"Doubt"> | string
    explanation?: StringFilter<"Doubt"> | string
    annotations?: StringNullableFilter<"Doubt"> | string | null
    imageDimensions?: StringNullableFilter<"Doubt"> | string | null
    worksheetId?: StringNullableFilter<"Doubt"> | string | null
    questionNumber?: IntNullableFilter<"Doubt"> | number | null
    isInRevision?: BoolFilter<"Doubt"> | boolean
    addedToRevisionAt?: DateTimeNullableFilter<"Doubt"> | Date | string | null
    isFavorite?: BoolFilter<"Doubt"> | boolean
    messageCount?: IntFilter<"Doubt"> | number
    createdAt?: DateTimeFilter<"Doubt"> | Date | string
    updatedAt?: DateTimeFilter<"Doubt"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: DoubtMessageListRelationFilter
    worksheet?: XOR<WorksheetNullableRelationFilter, WorksheetWhereInput> | null
    worksheetQuestions?: WorksheetQuestionListRelationFilter
    rating?: XOR<DoubtRatingNullableRelationFilter, DoubtRatingWhereInput> | null
  }, "id" | "conversationId">

  export type DoubtOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    questionImage?: SortOrderInput | SortOrder
    questionText?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    explanation?: SortOrder
    annotations?: SortOrderInput | SortOrder
    imageDimensions?: SortOrderInput | SortOrder
    conversationId?: SortOrder
    worksheetId?: SortOrderInput | SortOrder
    questionNumber?: SortOrderInput | SortOrder
    isInRevision?: SortOrder
    addedToRevisionAt?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DoubtCountOrderByAggregateInput
    _avg?: DoubtAvgOrderByAggregateInput
    _max?: DoubtMaxOrderByAggregateInput
    _min?: DoubtMinOrderByAggregateInput
    _sum?: DoubtSumOrderByAggregateInput
  }

  export type DoubtScalarWhereWithAggregatesInput = {
    AND?: DoubtScalarWhereWithAggregatesInput | DoubtScalarWhereWithAggregatesInput[]
    OR?: DoubtScalarWhereWithAggregatesInput[]
    NOT?: DoubtScalarWhereWithAggregatesInput | DoubtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Doubt"> | string
    userId?: StringNullableWithAggregatesFilter<"Doubt"> | string | null
    questionImage?: StringNullableWithAggregatesFilter<"Doubt"> | string | null
    questionText?: StringWithAggregatesFilter<"Doubt"> | string
    subject?: StringWithAggregatesFilter<"Doubt"> | string
    language?: StringWithAggregatesFilter<"Doubt"> | string
    explanation?: StringWithAggregatesFilter<"Doubt"> | string
    annotations?: StringNullableWithAggregatesFilter<"Doubt"> | string | null
    imageDimensions?: StringNullableWithAggregatesFilter<"Doubt"> | string | null
    conversationId?: StringWithAggregatesFilter<"Doubt"> | string
    worksheetId?: StringNullableWithAggregatesFilter<"Doubt"> | string | null
    questionNumber?: IntNullableWithAggregatesFilter<"Doubt"> | number | null
    isInRevision?: BoolWithAggregatesFilter<"Doubt"> | boolean
    addedToRevisionAt?: DateTimeNullableWithAggregatesFilter<"Doubt"> | Date | string | null
    isFavorite?: BoolWithAggregatesFilter<"Doubt"> | boolean
    messageCount?: IntWithAggregatesFilter<"Doubt"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Doubt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Doubt"> | Date | string
  }

  export type DoubtMessageWhereInput = {
    AND?: DoubtMessageWhereInput | DoubtMessageWhereInput[]
    OR?: DoubtMessageWhereInput[]
    NOT?: DoubtMessageWhereInput | DoubtMessageWhereInput[]
    id?: StringFilter<"DoubtMessage"> | string
    doubtId?: StringFilter<"DoubtMessage"> | string
    role?: StringFilter<"DoubtMessage"> | string
    content?: StringFilter<"DoubtMessage"> | string
    audioUrl?: StringNullableFilter<"DoubtMessage"> | string | null
    createdAt?: DateTimeFilter<"DoubtMessage"> | Date | string
    doubt?: XOR<DoubtRelationFilter, DoubtWhereInput>
  }

  export type DoubtMessageOrderByWithRelationInput = {
    id?: SortOrder
    doubtId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    doubt?: DoubtOrderByWithRelationInput
  }

  export type DoubtMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DoubtMessageWhereInput | DoubtMessageWhereInput[]
    OR?: DoubtMessageWhereInput[]
    NOT?: DoubtMessageWhereInput | DoubtMessageWhereInput[]
    doubtId?: StringFilter<"DoubtMessage"> | string
    role?: StringFilter<"DoubtMessage"> | string
    content?: StringFilter<"DoubtMessage"> | string
    audioUrl?: StringNullableFilter<"DoubtMessage"> | string | null
    createdAt?: DateTimeFilter<"DoubtMessage"> | Date | string
    doubt?: XOR<DoubtRelationFilter, DoubtWhereInput>
  }, "id">

  export type DoubtMessageOrderByWithAggregationInput = {
    id?: SortOrder
    doubtId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DoubtMessageCountOrderByAggregateInput
    _max?: DoubtMessageMaxOrderByAggregateInput
    _min?: DoubtMessageMinOrderByAggregateInput
  }

  export type DoubtMessageScalarWhereWithAggregatesInput = {
    AND?: DoubtMessageScalarWhereWithAggregatesInput | DoubtMessageScalarWhereWithAggregatesInput[]
    OR?: DoubtMessageScalarWhereWithAggregatesInput[]
    NOT?: DoubtMessageScalarWhereWithAggregatesInput | DoubtMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DoubtMessage"> | string
    doubtId?: StringWithAggregatesFilter<"DoubtMessage"> | string
    role?: StringWithAggregatesFilter<"DoubtMessage"> | string
    content?: StringWithAggregatesFilter<"DoubtMessage"> | string
    audioUrl?: StringNullableWithAggregatesFilter<"DoubtMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DoubtMessage"> | Date | string
  }

  export type WorksheetWhereInput = {
    AND?: WorksheetWhereInput | WorksheetWhereInput[]
    OR?: WorksheetWhereInput[]
    NOT?: WorksheetWhereInput | WorksheetWhereInput[]
    id?: StringFilter<"Worksheet"> | string
    userId?: StringNullableFilter<"Worksheet"> | string | null
    imageUrl?: StringFilter<"Worksheet"> | string
    imageHash?: StringFilter<"Worksheet"> | string
    totalQuestions?: IntFilter<"Worksheet"> | number
    currentQuestion?: IntFilter<"Worksheet"> | number
    sessionId?: StringFilter<"Worksheet"> | string
    expiresAt?: DateTimeFilter<"Worksheet"> | Date | string
    title?: StringNullableFilter<"Worksheet"> | string | null
    subject?: StringNullableFilter<"Worksheet"> | string | null
    createdAt?: DateTimeFilter<"Worksheet"> | Date | string
    updatedAt?: DateTimeFilter<"Worksheet"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    questions?: WorksheetQuestionListRelationFilter
    doubts?: DoubtListRelationFilter
  }

  export type WorksheetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    currentQuestion?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    title?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    questions?: WorksheetQuestionOrderByRelationAggregateInput
    doubts?: DoubtOrderByRelationAggregateInput
  }

  export type WorksheetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    imageHash?: string
    sessionId?: string
    AND?: WorksheetWhereInput | WorksheetWhereInput[]
    OR?: WorksheetWhereInput[]
    NOT?: WorksheetWhereInput | WorksheetWhereInput[]
    userId?: StringNullableFilter<"Worksheet"> | string | null
    imageUrl?: StringFilter<"Worksheet"> | string
    totalQuestions?: IntFilter<"Worksheet"> | number
    currentQuestion?: IntFilter<"Worksheet"> | number
    expiresAt?: DateTimeFilter<"Worksheet"> | Date | string
    title?: StringNullableFilter<"Worksheet"> | string | null
    subject?: StringNullableFilter<"Worksheet"> | string | null
    createdAt?: DateTimeFilter<"Worksheet"> | Date | string
    updatedAt?: DateTimeFilter<"Worksheet"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    questions?: WorksheetQuestionListRelationFilter
    doubts?: DoubtListRelationFilter
  }, "id" | "imageHash" | "sessionId">

  export type WorksheetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    currentQuestion?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    title?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorksheetCountOrderByAggregateInput
    _avg?: WorksheetAvgOrderByAggregateInput
    _max?: WorksheetMaxOrderByAggregateInput
    _min?: WorksheetMinOrderByAggregateInput
    _sum?: WorksheetSumOrderByAggregateInput
  }

  export type WorksheetScalarWhereWithAggregatesInput = {
    AND?: WorksheetScalarWhereWithAggregatesInput | WorksheetScalarWhereWithAggregatesInput[]
    OR?: WorksheetScalarWhereWithAggregatesInput[]
    NOT?: WorksheetScalarWhereWithAggregatesInput | WorksheetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Worksheet"> | string
    userId?: StringNullableWithAggregatesFilter<"Worksheet"> | string | null
    imageUrl?: StringWithAggregatesFilter<"Worksheet"> | string
    imageHash?: StringWithAggregatesFilter<"Worksheet"> | string
    totalQuestions?: IntWithAggregatesFilter<"Worksheet"> | number
    currentQuestion?: IntWithAggregatesFilter<"Worksheet"> | number
    sessionId?: StringWithAggregatesFilter<"Worksheet"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Worksheet"> | Date | string
    title?: StringNullableWithAggregatesFilter<"Worksheet"> | string | null
    subject?: StringNullableWithAggregatesFilter<"Worksheet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Worksheet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Worksheet"> | Date | string
  }

  export type WorksheetQuestionWhereInput = {
    AND?: WorksheetQuestionWhereInput | WorksheetQuestionWhereInput[]
    OR?: WorksheetQuestionWhereInput[]
    NOT?: WorksheetQuestionWhereInput | WorksheetQuestionWhereInput[]
    id?: StringFilter<"WorksheetQuestion"> | string
    worksheetId?: StringFilter<"WorksheetQuestion"> | string
    questionNumber?: IntFilter<"WorksheetQuestion"> | number
    doubtId?: StringNullableFilter<"WorksheetQuestion"> | string | null
    status?: StringFilter<"WorksheetQuestion"> | string
    cachedExplanation?: StringNullableFilter<"WorksheetQuestion"> | string | null
    createdAt?: DateTimeFilter<"WorksheetQuestion"> | Date | string
    worksheet?: XOR<WorksheetRelationFilter, WorksheetWhereInput>
    doubt?: XOR<DoubtNullableRelationFilter, DoubtWhereInput> | null
  }

  export type WorksheetQuestionOrderByWithRelationInput = {
    id?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    doubtId?: SortOrderInput | SortOrder
    status?: SortOrder
    cachedExplanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    worksheet?: WorksheetOrderByWithRelationInput
    doubt?: DoubtOrderByWithRelationInput
  }

  export type WorksheetQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    worksheetId_questionNumber?: WorksheetQuestionWorksheetIdQuestionNumberCompoundUniqueInput
    AND?: WorksheetQuestionWhereInput | WorksheetQuestionWhereInput[]
    OR?: WorksheetQuestionWhereInput[]
    NOT?: WorksheetQuestionWhereInput | WorksheetQuestionWhereInput[]
    worksheetId?: StringFilter<"WorksheetQuestion"> | string
    questionNumber?: IntFilter<"WorksheetQuestion"> | number
    doubtId?: StringNullableFilter<"WorksheetQuestion"> | string | null
    status?: StringFilter<"WorksheetQuestion"> | string
    cachedExplanation?: StringNullableFilter<"WorksheetQuestion"> | string | null
    createdAt?: DateTimeFilter<"WorksheetQuestion"> | Date | string
    worksheet?: XOR<WorksheetRelationFilter, WorksheetWhereInput>
    doubt?: XOR<DoubtNullableRelationFilter, DoubtWhereInput> | null
  }, "id" | "worksheetId_questionNumber">

  export type WorksheetQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    doubtId?: SortOrderInput | SortOrder
    status?: SortOrder
    cachedExplanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WorksheetQuestionCountOrderByAggregateInput
    _avg?: WorksheetQuestionAvgOrderByAggregateInput
    _max?: WorksheetQuestionMaxOrderByAggregateInput
    _min?: WorksheetQuestionMinOrderByAggregateInput
    _sum?: WorksheetQuestionSumOrderByAggregateInput
  }

  export type WorksheetQuestionScalarWhereWithAggregatesInput = {
    AND?: WorksheetQuestionScalarWhereWithAggregatesInput | WorksheetQuestionScalarWhereWithAggregatesInput[]
    OR?: WorksheetQuestionScalarWhereWithAggregatesInput[]
    NOT?: WorksheetQuestionScalarWhereWithAggregatesInput | WorksheetQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorksheetQuestion"> | string
    worksheetId?: StringWithAggregatesFilter<"WorksheetQuestion"> | string
    questionNumber?: IntWithAggregatesFilter<"WorksheetQuestion"> | number
    doubtId?: StringNullableWithAggregatesFilter<"WorksheetQuestion"> | string | null
    status?: StringWithAggregatesFilter<"WorksheetQuestion"> | string
    cachedExplanation?: StringNullableWithAggregatesFilter<"WorksheetQuestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorksheetQuestion"> | Date | string
  }

  export type DoubtRatingWhereInput = {
    AND?: DoubtRatingWhereInput | DoubtRatingWhereInput[]
    OR?: DoubtRatingWhereInput[]
    NOT?: DoubtRatingWhereInput | DoubtRatingWhereInput[]
    id?: StringFilter<"DoubtRating"> | string
    doubtId?: StringFilter<"DoubtRating"> | string
    userId?: StringFilter<"DoubtRating"> | string
    rating?: IntFilter<"DoubtRating"> | number
    feedback?: StringNullableFilter<"DoubtRating"> | string | null
    createdAt?: DateTimeFilter<"DoubtRating"> | Date | string
    updatedAt?: DateTimeFilter<"DoubtRating"> | Date | string
    doubt?: XOR<DoubtRelationFilter, DoubtWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DoubtRatingOrderByWithRelationInput = {
    id?: SortOrder
    doubtId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doubt?: DoubtOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DoubtRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    doubtId?: string
    userId_doubtId?: DoubtRatingUserIdDoubtIdCompoundUniqueInput
    AND?: DoubtRatingWhereInput | DoubtRatingWhereInput[]
    OR?: DoubtRatingWhereInput[]
    NOT?: DoubtRatingWhereInput | DoubtRatingWhereInput[]
    userId?: StringFilter<"DoubtRating"> | string
    rating?: IntFilter<"DoubtRating"> | number
    feedback?: StringNullableFilter<"DoubtRating"> | string | null
    createdAt?: DateTimeFilter<"DoubtRating"> | Date | string
    updatedAt?: DateTimeFilter<"DoubtRating"> | Date | string
    doubt?: XOR<DoubtRelationFilter, DoubtWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "doubtId" | "userId_doubtId">

  export type DoubtRatingOrderByWithAggregationInput = {
    id?: SortOrder
    doubtId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DoubtRatingCountOrderByAggregateInput
    _avg?: DoubtRatingAvgOrderByAggregateInput
    _max?: DoubtRatingMaxOrderByAggregateInput
    _min?: DoubtRatingMinOrderByAggregateInput
    _sum?: DoubtRatingSumOrderByAggregateInput
  }

  export type DoubtRatingScalarWhereWithAggregatesInput = {
    AND?: DoubtRatingScalarWhereWithAggregatesInput | DoubtRatingScalarWhereWithAggregatesInput[]
    OR?: DoubtRatingScalarWhereWithAggregatesInput[]
    NOT?: DoubtRatingScalarWhereWithAggregatesInput | DoubtRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DoubtRating"> | string
    doubtId?: StringWithAggregatesFilter<"DoubtRating"> | string
    userId?: StringWithAggregatesFilter<"DoubtRating"> | string
    rating?: IntWithAggregatesFilter<"DoubtRating"> | number
    feedback?: StringNullableWithAggregatesFilter<"DoubtRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DoubtRating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DoubtRating"> | Date | string
  }

  export type RevisionSessionWhereInput = {
    AND?: RevisionSessionWhereInput | RevisionSessionWhereInput[]
    OR?: RevisionSessionWhereInput[]
    NOT?: RevisionSessionWhereInput | RevisionSessionWhereInput[]
    id?: StringFilter<"RevisionSession"> | string
    userId?: StringNullableFilter<"RevisionSession"> | string | null
    topic?: StringFilter<"RevisionSession"> | string
    subject?: StringFilter<"RevisionSession"> | string
    startedAt?: DateTimeFilter<"RevisionSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"RevisionSession"> | Date | string | null
    score?: IntNullableFilter<"RevisionSession"> | number | null
    weakAreas?: StringNullableFilter<"RevisionSession"> | string | null
    phasesCompleted?: StringNullableFilter<"RevisionSession"> | string | null
    createdAt?: DateTimeFilter<"RevisionSession"> | Date | string
    updatedAt?: DateTimeFilter<"RevisionSession"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type RevisionSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    topic?: SortOrder
    subject?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    weakAreas?: SortOrderInput | SortOrder
    phasesCompleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RevisionSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RevisionSessionWhereInput | RevisionSessionWhereInput[]
    OR?: RevisionSessionWhereInput[]
    NOT?: RevisionSessionWhereInput | RevisionSessionWhereInput[]
    userId?: StringNullableFilter<"RevisionSession"> | string | null
    topic?: StringFilter<"RevisionSession"> | string
    subject?: StringFilter<"RevisionSession"> | string
    startedAt?: DateTimeFilter<"RevisionSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"RevisionSession"> | Date | string | null
    score?: IntNullableFilter<"RevisionSession"> | number | null
    weakAreas?: StringNullableFilter<"RevisionSession"> | string | null
    phasesCompleted?: StringNullableFilter<"RevisionSession"> | string | null
    createdAt?: DateTimeFilter<"RevisionSession"> | Date | string
    updatedAt?: DateTimeFilter<"RevisionSession"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type RevisionSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    topic?: SortOrder
    subject?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    weakAreas?: SortOrderInput | SortOrder
    phasesCompleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RevisionSessionCountOrderByAggregateInput
    _avg?: RevisionSessionAvgOrderByAggregateInput
    _max?: RevisionSessionMaxOrderByAggregateInput
    _min?: RevisionSessionMinOrderByAggregateInput
    _sum?: RevisionSessionSumOrderByAggregateInput
  }

  export type RevisionSessionScalarWhereWithAggregatesInput = {
    AND?: RevisionSessionScalarWhereWithAggregatesInput | RevisionSessionScalarWhereWithAggregatesInput[]
    OR?: RevisionSessionScalarWhereWithAggregatesInput[]
    NOT?: RevisionSessionScalarWhereWithAggregatesInput | RevisionSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RevisionSession"> | string
    userId?: StringNullableWithAggregatesFilter<"RevisionSession"> | string | null
    topic?: StringWithAggregatesFilter<"RevisionSession"> | string
    subject?: StringWithAggregatesFilter<"RevisionSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"RevisionSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"RevisionSession"> | Date | string | null
    score?: IntNullableWithAggregatesFilter<"RevisionSession"> | number | null
    weakAreas?: StringNullableWithAggregatesFilter<"RevisionSession"> | string | null
    phasesCompleted?: StringNullableWithAggregatesFilter<"RevisionSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RevisionSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RevisionSession"> | Date | string
  }

  export type WeakTopicWhereInput = {
    AND?: WeakTopicWhereInput | WeakTopicWhereInput[]
    OR?: WeakTopicWhereInput[]
    NOT?: WeakTopicWhereInput | WeakTopicWhereInput[]
    id?: StringFilter<"WeakTopic"> | string
    userId?: StringNullableFilter<"WeakTopic"> | string | null
    topic?: StringFilter<"WeakTopic"> | string
    subject?: StringFilter<"WeakTopic"> | string
    occurrences?: IntFilter<"WeakTopic"> | number
    lastSeen?: DateTimeFilter<"WeakTopic"> | Date | string
    improved?: BoolFilter<"WeakTopic"> | boolean
    improvedAt?: DateTimeNullableFilter<"WeakTopic"> | Date | string | null
    createdAt?: DateTimeFilter<"WeakTopic"> | Date | string
    updatedAt?: DateTimeFilter<"WeakTopic"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type WeakTopicOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    topic?: SortOrder
    subject?: SortOrder
    occurrences?: SortOrder
    lastSeen?: SortOrder
    improved?: SortOrder
    improvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WeakTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_topic_subject?: WeakTopicUserIdTopicSubjectCompoundUniqueInput
    AND?: WeakTopicWhereInput | WeakTopicWhereInput[]
    OR?: WeakTopicWhereInput[]
    NOT?: WeakTopicWhereInput | WeakTopicWhereInput[]
    userId?: StringNullableFilter<"WeakTopic"> | string | null
    topic?: StringFilter<"WeakTopic"> | string
    subject?: StringFilter<"WeakTopic"> | string
    occurrences?: IntFilter<"WeakTopic"> | number
    lastSeen?: DateTimeFilter<"WeakTopic"> | Date | string
    improved?: BoolFilter<"WeakTopic"> | boolean
    improvedAt?: DateTimeNullableFilter<"WeakTopic"> | Date | string | null
    createdAt?: DateTimeFilter<"WeakTopic"> | Date | string
    updatedAt?: DateTimeFilter<"WeakTopic"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "userId_topic_subject">

  export type WeakTopicOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    topic?: SortOrder
    subject?: SortOrder
    occurrences?: SortOrder
    lastSeen?: SortOrder
    improved?: SortOrder
    improvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeakTopicCountOrderByAggregateInput
    _avg?: WeakTopicAvgOrderByAggregateInput
    _max?: WeakTopicMaxOrderByAggregateInput
    _min?: WeakTopicMinOrderByAggregateInput
    _sum?: WeakTopicSumOrderByAggregateInput
  }

  export type WeakTopicScalarWhereWithAggregatesInput = {
    AND?: WeakTopicScalarWhereWithAggregatesInput | WeakTopicScalarWhereWithAggregatesInput[]
    OR?: WeakTopicScalarWhereWithAggregatesInput[]
    NOT?: WeakTopicScalarWhereWithAggregatesInput | WeakTopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeakTopic"> | string
    userId?: StringNullableWithAggregatesFilter<"WeakTopic"> | string | null
    topic?: StringWithAggregatesFilter<"WeakTopic"> | string
    subject?: StringWithAggregatesFilter<"WeakTopic"> | string
    occurrences?: IntWithAggregatesFilter<"WeakTopic"> | number
    lastSeen?: DateTimeWithAggregatesFilter<"WeakTopic"> | Date | string
    improved?: BoolWithAggregatesFilter<"WeakTopic"> | boolean
    improvedAt?: DateTimeNullableWithAggregatesFilter<"WeakTopic"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeakTopic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeakTopic"> | Date | string
  }

  export type GroupStudySessionWhereInput = {
    AND?: GroupStudySessionWhereInput | GroupStudySessionWhereInput[]
    OR?: GroupStudySessionWhereInput[]
    NOT?: GroupStudySessionWhereInput | GroupStudySessionWhereInput[]
    id?: StringFilter<"GroupStudySession"> | string
    userId?: StringNullableFilter<"GroupStudySession"> | string | null
    topic?: StringFilter<"GroupStudySession"> | string
    subject?: StringFilter<"GroupStudySession"> | string
    question?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate1Name?: StringFilter<"GroupStudySession"> | string
    classmate2Name?: StringFilter<"GroupStudySession"> | string
    studentAnswer?: StringFilter<"GroupStudySession"> | string
    classmate1Question?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate2Counter?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate1Response?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate2Response?: StringNullableFilter<"GroupStudySession"> | string | null
    handlingScore?: IntNullableFilter<"GroupStudySession"> | number | null
    strengths?: StringNullableFilter<"GroupStudySession"> | string | null
    improvements?: StringNullableFilter<"GroupStudySession"> | string | null
    challengesCount?: IntFilter<"GroupStudySession"> | number
    startedAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"GroupStudySession"> | Date | string | null
    createdAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    updatedAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type GroupStudySessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    topic?: SortOrder
    subject?: SortOrder
    question?: SortOrderInput | SortOrder
    classmate1Name?: SortOrder
    classmate2Name?: SortOrder
    studentAnswer?: SortOrder
    classmate1Question?: SortOrderInput | SortOrder
    classmate2Counter?: SortOrderInput | SortOrder
    classmate1Response?: SortOrderInput | SortOrder
    classmate2Response?: SortOrderInput | SortOrder
    handlingScore?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    improvements?: SortOrderInput | SortOrder
    challengesCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GroupStudySessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupStudySessionWhereInput | GroupStudySessionWhereInput[]
    OR?: GroupStudySessionWhereInput[]
    NOT?: GroupStudySessionWhereInput | GroupStudySessionWhereInput[]
    userId?: StringNullableFilter<"GroupStudySession"> | string | null
    topic?: StringFilter<"GroupStudySession"> | string
    subject?: StringFilter<"GroupStudySession"> | string
    question?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate1Name?: StringFilter<"GroupStudySession"> | string
    classmate2Name?: StringFilter<"GroupStudySession"> | string
    studentAnswer?: StringFilter<"GroupStudySession"> | string
    classmate1Question?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate2Counter?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate1Response?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate2Response?: StringNullableFilter<"GroupStudySession"> | string | null
    handlingScore?: IntNullableFilter<"GroupStudySession"> | number | null
    strengths?: StringNullableFilter<"GroupStudySession"> | string | null
    improvements?: StringNullableFilter<"GroupStudySession"> | string | null
    challengesCount?: IntFilter<"GroupStudySession"> | number
    startedAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"GroupStudySession"> | Date | string | null
    createdAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    updatedAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type GroupStudySessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    topic?: SortOrder
    subject?: SortOrder
    question?: SortOrderInput | SortOrder
    classmate1Name?: SortOrder
    classmate2Name?: SortOrder
    studentAnswer?: SortOrder
    classmate1Question?: SortOrderInput | SortOrder
    classmate2Counter?: SortOrderInput | SortOrder
    classmate1Response?: SortOrderInput | SortOrder
    classmate2Response?: SortOrderInput | SortOrder
    handlingScore?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    improvements?: SortOrderInput | SortOrder
    challengesCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupStudySessionCountOrderByAggregateInput
    _avg?: GroupStudySessionAvgOrderByAggregateInput
    _max?: GroupStudySessionMaxOrderByAggregateInput
    _min?: GroupStudySessionMinOrderByAggregateInput
    _sum?: GroupStudySessionSumOrderByAggregateInput
  }

  export type GroupStudySessionScalarWhereWithAggregatesInput = {
    AND?: GroupStudySessionScalarWhereWithAggregatesInput | GroupStudySessionScalarWhereWithAggregatesInput[]
    OR?: GroupStudySessionScalarWhereWithAggregatesInput[]
    NOT?: GroupStudySessionScalarWhereWithAggregatesInput | GroupStudySessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupStudySession"> | string
    userId?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    topic?: StringWithAggregatesFilter<"GroupStudySession"> | string
    subject?: StringWithAggregatesFilter<"GroupStudySession"> | string
    question?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    classmate1Name?: StringWithAggregatesFilter<"GroupStudySession"> | string
    classmate2Name?: StringWithAggregatesFilter<"GroupStudySession"> | string
    studentAnswer?: StringWithAggregatesFilter<"GroupStudySession"> | string
    classmate1Question?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    classmate2Counter?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    classmate1Response?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    classmate2Response?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    handlingScore?: IntNullableWithAggregatesFilter<"GroupStudySession"> | number | null
    strengths?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    improvements?: StringNullableWithAggregatesFilter<"GroupStudySession"> | string | null
    challengesCount?: IntWithAggregatesFilter<"GroupStudySession"> | number
    startedAt?: DateTimeWithAggregatesFilter<"GroupStudySession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"GroupStudySession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GroupStudySession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GroupStudySession"> | Date | string
  }

  export type HandlingSkillProgressWhereInput = {
    AND?: HandlingSkillProgressWhereInput | HandlingSkillProgressWhereInput[]
    OR?: HandlingSkillProgressWhereInput[]
    NOT?: HandlingSkillProgressWhereInput | HandlingSkillProgressWhereInput[]
    id?: StringFilter<"HandlingSkillProgress"> | string
    userId?: StringFilter<"HandlingSkillProgress"> | string
    currentLevel?: StringFilter<"HandlingSkillProgress"> | string
    avgScore?: FloatFilter<"HandlingSkillProgress"> | number
    sessionsCount?: IntFilter<"HandlingSkillProgress"> | number
    badges?: StringFilter<"HandlingSkillProgress"> | string
    lastSession?: DateTimeFilter<"HandlingSkillProgress"> | Date | string
    createdAt?: DateTimeFilter<"HandlingSkillProgress"> | Date | string
    updatedAt?: DateTimeFilter<"HandlingSkillProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HandlingSkillProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    avgScore?: SortOrder
    sessionsCount?: SortOrder
    badges?: SortOrder
    lastSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HandlingSkillProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: HandlingSkillProgressWhereInput | HandlingSkillProgressWhereInput[]
    OR?: HandlingSkillProgressWhereInput[]
    NOT?: HandlingSkillProgressWhereInput | HandlingSkillProgressWhereInput[]
    currentLevel?: StringFilter<"HandlingSkillProgress"> | string
    avgScore?: FloatFilter<"HandlingSkillProgress"> | number
    sessionsCount?: IntFilter<"HandlingSkillProgress"> | number
    badges?: StringFilter<"HandlingSkillProgress"> | string
    lastSession?: DateTimeFilter<"HandlingSkillProgress"> | Date | string
    createdAt?: DateTimeFilter<"HandlingSkillProgress"> | Date | string
    updatedAt?: DateTimeFilter<"HandlingSkillProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type HandlingSkillProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    avgScore?: SortOrder
    sessionsCount?: SortOrder
    badges?: SortOrder
    lastSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HandlingSkillProgressCountOrderByAggregateInput
    _avg?: HandlingSkillProgressAvgOrderByAggregateInput
    _max?: HandlingSkillProgressMaxOrderByAggregateInput
    _min?: HandlingSkillProgressMinOrderByAggregateInput
    _sum?: HandlingSkillProgressSumOrderByAggregateInput
  }

  export type HandlingSkillProgressScalarWhereWithAggregatesInput = {
    AND?: HandlingSkillProgressScalarWhereWithAggregatesInput | HandlingSkillProgressScalarWhereWithAggregatesInput[]
    OR?: HandlingSkillProgressScalarWhereWithAggregatesInput[]
    NOT?: HandlingSkillProgressScalarWhereWithAggregatesInput | HandlingSkillProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HandlingSkillProgress"> | string
    userId?: StringWithAggregatesFilter<"HandlingSkillProgress"> | string
    currentLevel?: StringWithAggregatesFilter<"HandlingSkillProgress"> | string
    avgScore?: FloatWithAggregatesFilter<"HandlingSkillProgress"> | number
    sessionsCount?: IntWithAggregatesFilter<"HandlingSkillProgress"> | number
    badges?: StringWithAggregatesFilter<"HandlingSkillProgress"> | string
    lastSession?: DateTimeWithAggregatesFilter<"HandlingSkillProgress"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"HandlingSkillProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HandlingSkillProgress"> | Date | string
  }

  export type QuestionPaperCreateInput = {
    id?: string
    title?: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageCount?: number
    questions?: QuestionCreateNestedManyWithoutQuestionPaperInput
    gradings?: GradingCreateNestedManyWithoutQuestionPaperInput
  }

  export type QuestionPaperUncheckedCreateInput = {
    id?: string
    title?: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageCount?: number
    questions?: QuestionUncheckedCreateNestedManyWithoutQuestionPaperInput
    gradings?: GradingUncheckedCreateNestedManyWithoutQuestionPaperInput
  }

  export type QuestionPaperUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
    questions?: QuestionUpdateManyWithoutQuestionPaperNestedInput
    gradings?: GradingUpdateManyWithoutQuestionPaperNestedInput
  }

  export type QuestionPaperUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
    questions?: QuestionUncheckedUpdateManyWithoutQuestionPaperNestedInput
    gradings?: GradingUncheckedUpdateManyWithoutQuestionPaperNestedInput
  }

  export type QuestionPaperCreateManyInput = {
    id?: string
    title?: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageCount?: number
  }

  export type QuestionPaperUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionPaperUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionCreateInput = {
    id?: string
    questionNumber: string
    questionText: string
    maxScore?: number | null
    topic?: string | null
    concept?: string | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
    questionPaper: QuestionPaperCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    questionPaperId: string
    questionNumber: string
    questionText: string
    maxScore?: number | null
    topic?: string | null
    concept?: string | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionPaper?: QuestionPaperUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionPaperId?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyInput = {
    id?: string
    questionPaperId: string
    questionNumber: string
    questionText: string
    maxScore?: number | null
    topic?: string | null
    concept?: string | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionPaperId?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    doubts?: DoubtCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GradingCreateInput = {
    id?: string
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGradingsInput
    questionPaper?: QuestionPaperCreateNestedOneWithoutGradingsInput
    pages?: GradingPageCreateNestedManyWithoutGradingInput
    answers?: AnswerCreateNestedManyWithoutGradingInput
  }

  export type GradingUncheckedCreateInput = {
    id?: string
    userId?: string | null
    questionPaperId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    pages?: GradingPageUncheckedCreateNestedManyWithoutGradingInput
    answers?: AnswerUncheckedCreateNestedManyWithoutGradingInput
  }

  export type GradingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGradingsNestedInput
    questionPaper?: QuestionPaperUpdateOneWithoutGradingsNestedInput
    pages?: GradingPageUpdateManyWithoutGradingNestedInput
    answers?: AnswerUpdateManyWithoutGradingNestedInput
  }

  export type GradingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionPaperId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: GradingPageUncheckedUpdateManyWithoutGradingNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutGradingNestedInput
  }

  export type GradingCreateManyInput = {
    id?: string
    userId?: string | null
    questionPaperId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
  }

  export type GradingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionPaperId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingPageCreateInput = {
    id?: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    grading: GradingCreateNestedOneWithoutPagesInput
    pageAnswers?: PageAnswerCreateNestedManyWithoutPageInput
  }

  export type GradingPageUncheckedCreateInput = {
    id?: string
    gradingId: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    pageAnswers?: PageAnswerUncheckedCreateNestedManyWithoutPageInput
  }

  export type GradingPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grading?: GradingUpdateOneRequiredWithoutPagesNestedInput
    pageAnswers?: PageAnswerUpdateManyWithoutPageNestedInput
  }

  export type GradingPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradingId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pageAnswers?: PageAnswerUncheckedUpdateManyWithoutPageNestedInput
  }

  export type GradingPageCreateManyInput = {
    id?: string
    gradingId: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
  }

  export type GradingPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradingId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageAnswerCreateInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    continuedFrom?: number | null
    continuedTo?: number | null
    createdAt?: Date | string
    page: GradingPageCreateNestedOneWithoutPageAnswersInput
  }

  export type PageAnswerUncheckedCreateInput = {
    id?: string
    pageId: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    continuedFrom?: number | null
    continuedTo?: number | null
    createdAt?: Date | string
  }

  export type PageAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    continuedFrom?: NullableIntFieldUpdateOperationsInput | number | null
    continuedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: GradingPageUpdateOneRequiredWithoutPageAnswersNestedInput
  }

  export type PageAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    continuedFrom?: NullableIntFieldUpdateOperationsInput | number | null
    continuedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageAnswerCreateManyInput = {
    id?: string
    pageId: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    continuedFrom?: number | null
    continuedTo?: number | null
    createdAt?: Date | string
  }

  export type PageAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    continuedFrom?: NullableIntFieldUpdateOperationsInput | number | null
    continuedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    continuedFrom?: NullableIntFieldUpdateOperationsInput | number | null
    continuedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
    grading: GradingCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: string
    gradingId: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type AnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grading?: GradingUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradingId?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateManyInput = {
    id?: string
    gradingId: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type AnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradingId?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtCreateInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDoubtsInput
    messages?: DoubtMessageCreateNestedManyWithoutDoubtInput
    worksheet?: WorksheetCreateNestedOneWithoutDoubtsInput
    worksheetQuestions?: WorksheetQuestionCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingCreateNestedOneWithoutDoubtInput
  }

  export type DoubtUncheckedCreateInput = {
    id?: string
    userId?: string | null
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    worksheetId?: string | null
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DoubtMessageUncheckedCreateNestedManyWithoutDoubtInput
    worksheetQuestions?: WorksheetQuestionUncheckedCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingUncheckedCreateNestedOneWithoutDoubtInput
  }

  export type DoubtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDoubtsNestedInput
    messages?: DoubtMessageUpdateManyWithoutDoubtNestedInput
    worksheet?: WorksheetUpdateOneWithoutDoubtsNestedInput
    worksheetQuestions?: WorksheetQuestionUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    worksheetId?: NullableStringFieldUpdateOperationsInput | string | null
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DoubtMessageUncheckedUpdateManyWithoutDoubtNestedInput
    worksheetQuestions?: WorksheetQuestionUncheckedUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUncheckedUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtCreateManyInput = {
    id?: string
    userId?: string | null
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    worksheetId?: string | null
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoubtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    worksheetId?: NullableStringFieldUpdateOperationsInput | string | null
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtMessageCreateInput = {
    id?: string
    role: string
    content: string
    audioUrl?: string | null
    createdAt?: Date | string
    doubt: DoubtCreateNestedOneWithoutMessagesInput
  }

  export type DoubtMessageUncheckedCreateInput = {
    id?: string
    doubtId: string
    role: string
    content: string
    audioUrl?: string | null
    createdAt?: Date | string
  }

  export type DoubtMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doubt?: DoubtUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type DoubtMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doubtId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtMessageCreateManyInput = {
    id?: string
    doubtId: string
    role: string
    content: string
    audioUrl?: string | null
    createdAt?: Date | string
  }

  export type DoubtMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doubtId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetCreateInput = {
    id?: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWorksheetsInput
    questions?: WorksheetQuestionCreateNestedManyWithoutWorksheetInput
    doubts?: DoubtCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetUncheckedCreateInput = {
    id?: string
    userId?: string | null
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: WorksheetQuestionUncheckedCreateNestedManyWithoutWorksheetInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWorksheetsNestedInput
    questions?: WorksheetQuestionUpdateManyWithoutWorksheetNestedInput
    doubts?: DoubtUpdateManyWithoutWorksheetNestedInput
  }

  export type WorksheetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: WorksheetQuestionUncheckedUpdateManyWithoutWorksheetNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutWorksheetNestedInput
  }

  export type WorksheetCreateManyInput = {
    id?: string
    userId?: string | null
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorksheetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetQuestionCreateInput = {
    id?: string
    questionNumber: number
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
    worksheet: WorksheetCreateNestedOneWithoutQuestionsInput
    doubt?: DoubtCreateNestedOneWithoutWorksheetQuestionsInput
  }

  export type WorksheetQuestionUncheckedCreateInput = {
    id?: string
    worksheetId: string
    questionNumber: number
    doubtId?: string | null
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
  }

  export type WorksheetQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    worksheet?: WorksheetUpdateOneRequiredWithoutQuestionsNestedInput
    doubt?: DoubtUpdateOneWithoutWorksheetQuestionsNestedInput
  }

  export type WorksheetQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    worksheetId?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    doubtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetQuestionCreateManyInput = {
    id?: string
    worksheetId: string
    questionNumber: number
    doubtId?: string | null
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
  }

  export type WorksheetQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    worksheetId?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    doubtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtRatingCreateInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doubt: DoubtCreateNestedOneWithoutRatingInput
    user: UserCreateNestedOneWithoutDoubtRatingsInput
  }

  export type DoubtRatingUncheckedCreateInput = {
    id?: string
    doubtId: string
    userId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoubtRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doubt?: DoubtUpdateOneRequiredWithoutRatingNestedInput
    user?: UserUpdateOneRequiredWithoutDoubtRatingsNestedInput
  }

  export type DoubtRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doubtId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtRatingCreateManyInput = {
    id?: string
    doubtId: string
    userId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoubtRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doubtId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevisionSessionCreateInput = {
    id?: string
    topic: string
    subject: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number | null
    weakAreas?: string | null
    phasesCompleted?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRevisionSessionsInput
  }

  export type RevisionSessionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    topic: string
    subject: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number | null
    weakAreas?: string | null
    phasesCompleted?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevisionSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    weakAreas?: NullableStringFieldUpdateOperationsInput | string | null
    phasesCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRevisionSessionsNestedInput
  }

  export type RevisionSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    weakAreas?: NullableStringFieldUpdateOperationsInput | string | null
    phasesCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevisionSessionCreateManyInput = {
    id?: string
    userId?: string | null
    topic: string
    subject: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number | null
    weakAreas?: string | null
    phasesCompleted?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevisionSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    weakAreas?: NullableStringFieldUpdateOperationsInput | string | null
    phasesCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevisionSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    weakAreas?: NullableStringFieldUpdateOperationsInput | string | null
    phasesCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeakTopicCreateInput = {
    id?: string
    topic: string
    subject: string
    occurrences?: number
    lastSeen?: Date | string
    improved?: boolean
    improvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWeakTopicsInput
  }

  export type WeakTopicUncheckedCreateInput = {
    id?: string
    userId?: string | null
    topic: string
    subject: string
    occurrences?: number
    lastSeen?: Date | string
    improved?: boolean
    improvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeakTopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    occurrences?: IntFieldUpdateOperationsInput | number
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    improved?: BoolFieldUpdateOperationsInput | boolean
    improvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWeakTopicsNestedInput
  }

  export type WeakTopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    occurrences?: IntFieldUpdateOperationsInput | number
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    improved?: BoolFieldUpdateOperationsInput | boolean
    improvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeakTopicCreateManyInput = {
    id?: string
    userId?: string | null
    topic: string
    subject: string
    occurrences?: number
    lastSeen?: Date | string
    improved?: boolean
    improvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeakTopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    occurrences?: IntFieldUpdateOperationsInput | number
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    improved?: BoolFieldUpdateOperationsInput | boolean
    improvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeakTopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    occurrences?: IntFieldUpdateOperationsInput | number
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    improved?: BoolFieldUpdateOperationsInput | boolean
    improvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupStudySessionCreateInput = {
    id?: string
    topic: string
    subject: string
    question?: string | null
    classmate1Name: string
    classmate2Name: string
    studentAnswer: string
    classmate1Question?: string | null
    classmate2Counter?: string | null
    classmate1Response?: string | null
    classmate2Response?: string | null
    handlingScore?: number | null
    strengths?: string | null
    improvements?: string | null
    challengesCount?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutGroupStudySessionsInput
  }

  export type GroupStudySessionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    topic: string
    subject: string
    question?: string | null
    classmate1Name: string
    classmate2Name: string
    studentAnswer: string
    classmate1Question?: string | null
    classmate2Counter?: string | null
    classmate1Response?: string | null
    classmate2Response?: string | null
    handlingScore?: number | null
    strengths?: string | null
    improvements?: string | null
    challengesCount?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupStudySessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Name?: StringFieldUpdateOperationsInput | string
    classmate2Name?: StringFieldUpdateOperationsInput | string
    studentAnswer?: StringFieldUpdateOperationsInput | string
    classmate1Question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Counter?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Response?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Response?: NullableStringFieldUpdateOperationsInput | string | null
    handlingScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    challengesCount?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGroupStudySessionsNestedInput
  }

  export type GroupStudySessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Name?: StringFieldUpdateOperationsInput | string
    classmate2Name?: StringFieldUpdateOperationsInput | string
    studentAnswer?: StringFieldUpdateOperationsInput | string
    classmate1Question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Counter?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Response?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Response?: NullableStringFieldUpdateOperationsInput | string | null
    handlingScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    challengesCount?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupStudySessionCreateManyInput = {
    id?: string
    userId?: string | null
    topic: string
    subject: string
    question?: string | null
    classmate1Name: string
    classmate2Name: string
    studentAnswer: string
    classmate1Question?: string | null
    classmate2Counter?: string | null
    classmate1Response?: string | null
    classmate2Response?: string | null
    handlingScore?: number | null
    strengths?: string | null
    improvements?: string | null
    challengesCount?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupStudySessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Name?: StringFieldUpdateOperationsInput | string
    classmate2Name?: StringFieldUpdateOperationsInput | string
    studentAnswer?: StringFieldUpdateOperationsInput | string
    classmate1Question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Counter?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Response?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Response?: NullableStringFieldUpdateOperationsInput | string | null
    handlingScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    challengesCount?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupStudySessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Name?: StringFieldUpdateOperationsInput | string
    classmate2Name?: StringFieldUpdateOperationsInput | string
    studentAnswer?: StringFieldUpdateOperationsInput | string
    classmate1Question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Counter?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Response?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Response?: NullableStringFieldUpdateOperationsInput | string | null
    handlingScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    challengesCount?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandlingSkillProgressCreateInput = {
    id?: string
    currentLevel?: string
    avgScore?: number
    sessionsCount?: number
    badges?: string
    lastSession?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHandlingSkillProgressInput
  }

  export type HandlingSkillProgressUncheckedCreateInput = {
    id?: string
    userId: string
    currentLevel?: string
    avgScore?: number
    sessionsCount?: number
    badges?: string
    lastSession?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandlingSkillProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: StringFieldUpdateOperationsInput | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sessionsCount?: IntFieldUpdateOperationsInput | number
    badges?: StringFieldUpdateOperationsInput | string
    lastSession?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHandlingSkillProgressNestedInput
  }

  export type HandlingSkillProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLevel?: StringFieldUpdateOperationsInput | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sessionsCount?: IntFieldUpdateOperationsInput | number
    badges?: StringFieldUpdateOperationsInput | string
    lastSession?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandlingSkillProgressCreateManyInput = {
    id?: string
    userId: string
    currentLevel?: string
    avgScore?: number
    sessionsCount?: number
    badges?: string
    lastSession?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandlingSkillProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: StringFieldUpdateOperationsInput | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sessionsCount?: IntFieldUpdateOperationsInput | number
    badges?: StringFieldUpdateOperationsInput | string
    lastSession?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandlingSkillProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLevel?: StringFieldUpdateOperationsInput | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sessionsCount?: IntFieldUpdateOperationsInput | number
    badges?: StringFieldUpdateOperationsInput | string
    lastSession?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type GradingListRelationFilter = {
    every?: GradingWhereInput
    some?: GradingWhereInput
    none?: GradingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionPaperCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    gradeLevel?: SortOrder
    language?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usageCount?: SortOrder
  }

  export type QuestionPaperAvgOrderByAggregateInput = {
    totalQuestions?: SortOrder
    usageCount?: SortOrder
  }

  export type QuestionPaperMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    gradeLevel?: SortOrder
    language?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usageCount?: SortOrder
  }

  export type QuestionPaperMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    gradeLevel?: SortOrder
    language?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usageCount?: SortOrder
  }

  export type QuestionPaperSumOrderByAggregateInput = {
    totalQuestions?: SortOrder
    usageCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type QuestionPaperRelationFilter = {
    is?: QuestionPaperWhereInput
    isNot?: QuestionPaperWhereInput
  }

  export type QuestionQuestionPaperIdQuestionNumberCompoundUniqueInput = {
    questionPaperId: string
    questionNumber: string
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    questionPaperId?: SortOrder
    questionNumber?: SortOrder
    questionText?: SortOrder
    maxScore?: SortOrder
    topic?: SortOrder
    concept?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    maxScore?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionPaperId?: SortOrder
    questionNumber?: SortOrder
    questionText?: SortOrder
    maxScore?: SortOrder
    topic?: SortOrder
    concept?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    questionPaperId?: SortOrder
    questionNumber?: SortOrder
    questionText?: SortOrder
    maxScore?: SortOrder
    topic?: SortOrder
    concept?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    maxScore?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DoubtListRelationFilter = {
    every?: DoubtWhereInput
    some?: DoubtWhereInput
    none?: DoubtWhereInput
  }

  export type WorksheetListRelationFilter = {
    every?: WorksheetWhereInput
    some?: WorksheetWhereInput
    none?: WorksheetWhereInput
  }

  export type DoubtRatingListRelationFilter = {
    every?: DoubtRatingWhereInput
    some?: DoubtRatingWhereInput
    none?: DoubtRatingWhereInput
  }

  export type RevisionSessionListRelationFilter = {
    every?: RevisionSessionWhereInput
    some?: RevisionSessionWhereInput
    none?: RevisionSessionWhereInput
  }

  export type WeakTopicListRelationFilter = {
    every?: WeakTopicWhereInput
    some?: WeakTopicWhereInput
    none?: WeakTopicWhereInput
  }

  export type GroupStudySessionListRelationFilter = {
    every?: GroupStudySessionWhereInput
    some?: GroupStudySessionWhereInput
    none?: GroupStudySessionWhereInput
  }

  export type HandlingSkillProgressNullableRelationFilter = {
    is?: HandlingSkillProgressWhereInput | null
    isNot?: HandlingSkillProgressWhereInput | null
  }

  export type DoubtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorksheetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoubtRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RevisionSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeakTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupStudySessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    grade?: SortOrder
    school?: SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    grade?: SortOrder
    school?: SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    grade?: SortOrder
    school?: SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type QuestionPaperNullableRelationFilter = {
    is?: QuestionPaperWhereInput | null
    isNot?: QuestionPaperWhereInput | null
  }

  export type GradingPageListRelationFilter = {
    every?: GradingPageWhereInput
    some?: GradingPageWhereInput
    none?: GradingPageWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput
    some?: AnswerWhereInput
    none?: AnswerWhereInput
  }

  export type GradingPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionPaperId?: SortOrder
    answerSheetUrl?: SortOrder
    totalPages?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    gradeLevel?: SortOrder
    totalScore?: SortOrder
    feedback?: SortOrder
    matchingMode?: SortOrder
    totalQuestions?: SortOrder
    answeredQuestions?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    createdAt?: SortOrder
  }

  export type GradingAvgOrderByAggregateInput = {
    totalPages?: SortOrder
    totalQuestions?: SortOrder
    answeredQuestions?: SortOrder
  }

  export type GradingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionPaperId?: SortOrder
    answerSheetUrl?: SortOrder
    totalPages?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    gradeLevel?: SortOrder
    totalScore?: SortOrder
    feedback?: SortOrder
    matchingMode?: SortOrder
    totalQuestions?: SortOrder
    answeredQuestions?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    createdAt?: SortOrder
  }

  export type GradingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionPaperId?: SortOrder
    answerSheetUrl?: SortOrder
    totalPages?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    gradeLevel?: SortOrder
    totalScore?: SortOrder
    feedback?: SortOrder
    matchingMode?: SortOrder
    totalQuestions?: SortOrder
    answeredQuestions?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    createdAt?: SortOrder
  }

  export type GradingSumOrderByAggregateInput = {
    totalPages?: SortOrder
    totalQuestions?: SortOrder
    answeredQuestions?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type GradingRelationFilter = {
    is?: GradingWhereInput
    isNot?: GradingWhereInput
  }

  export type PageAnswerListRelationFilter = {
    every?: PageAnswerWhereInput
    some?: PageAnswerWhereInput
    none?: PageAnswerWhereInput
  }

  export type PageAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradingPageGradingIdPageNumberCompoundUniqueInput = {
    gradingId: string
    pageNumber: number
  }

  export type GradingPageCountOrderByAggregateInput = {
    id?: SortOrder
    gradingId?: SortOrder
    pageNumber?: SortOrder
    imageUrl?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    createdAt?: SortOrder
  }

  export type GradingPageAvgOrderByAggregateInput = {
    pageNumber?: SortOrder
  }

  export type GradingPageMaxOrderByAggregateInput = {
    id?: SortOrder
    gradingId?: SortOrder
    pageNumber?: SortOrder
    imageUrl?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    createdAt?: SortOrder
  }

  export type GradingPageMinOrderByAggregateInput = {
    id?: SortOrder
    gradingId?: SortOrder
    pageNumber?: SortOrder
    imageUrl?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    createdAt?: SortOrder
  }

  export type GradingPageSumOrderByAggregateInput = {
    pageNumber?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type GradingPageRelationFilter = {
    is?: GradingPageWhereInput
    isNot?: GradingPageWhereInput
  }

  export type PageAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    continuedFrom?: SortOrder
    continuedTo?: SortOrder
    createdAt?: SortOrder
  }

  export type PageAnswerAvgOrderByAggregateInput = {
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    continuedFrom?: SortOrder
    continuedTo?: SortOrder
  }

  export type PageAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    continuedFrom?: SortOrder
    continuedTo?: SortOrder
    createdAt?: SortOrder
  }

  export type PageAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    continuedFrom?: SortOrder
    continuedTo?: SortOrder
    createdAt?: SortOrder
  }

  export type PageAnswerSumOrderByAggregateInput = {
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    continuedFrom?: SortOrder
    continuedTo?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    gradingId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
  }

  export type AnswerAvgOrderByAggregateInput = {
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    gradingId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    gradingId?: SortOrder
    questionNumber?: SortOrder
    studentAnswer?: SortOrder
    correct?: SortOrder
    score?: SortOrder
    remarks?: SortOrder
    matched?: SortOrder
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
  }

  export type AnswerSumOrderByAggregateInput = {
    matchConfidence?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type DoubtMessageListRelationFilter = {
    every?: DoubtMessageWhereInput
    some?: DoubtMessageWhereInput
    none?: DoubtMessageWhereInput
  }

  export type WorksheetNullableRelationFilter = {
    is?: WorksheetWhereInput | null
    isNot?: WorksheetWhereInput | null
  }

  export type WorksheetQuestionListRelationFilter = {
    every?: WorksheetQuestionWhereInput
    some?: WorksheetQuestionWhereInput
    none?: WorksheetQuestionWhereInput
  }

  export type DoubtRatingNullableRelationFilter = {
    is?: DoubtRatingWhereInput | null
    isNot?: DoubtRatingWhereInput | null
  }

  export type DoubtMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorksheetQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoubtCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionImage?: SortOrder
    questionText?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    explanation?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    conversationId?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    isInRevision?: SortOrder
    addedToRevisionAt?: SortOrder
    isFavorite?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoubtAvgOrderByAggregateInput = {
    questionNumber?: SortOrder
    messageCount?: SortOrder
  }

  export type DoubtMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionImage?: SortOrder
    questionText?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    explanation?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    conversationId?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    isInRevision?: SortOrder
    addedToRevisionAt?: SortOrder
    isFavorite?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoubtMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionImage?: SortOrder
    questionText?: SortOrder
    subject?: SortOrder
    language?: SortOrder
    explanation?: SortOrder
    annotations?: SortOrder
    imageDimensions?: SortOrder
    conversationId?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    isInRevision?: SortOrder
    addedToRevisionAt?: SortOrder
    isFavorite?: SortOrder
    messageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoubtSumOrderByAggregateInput = {
    questionNumber?: SortOrder
    messageCount?: SortOrder
  }

  export type DoubtRelationFilter = {
    is?: DoubtWhereInput
    isNot?: DoubtWhereInput
  }

  export type DoubtMessageCountOrderByAggregateInput = {
    id?: SortOrder
    doubtId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DoubtMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    doubtId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DoubtMessageMinOrderByAggregateInput = {
    id?: SortOrder
    doubtId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type WorksheetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    currentQuestion?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorksheetAvgOrderByAggregateInput = {
    totalQuestions?: SortOrder
    currentQuestion?: SortOrder
  }

  export type WorksheetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    currentQuestion?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorksheetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    imageHash?: SortOrder
    totalQuestions?: SortOrder
    currentQuestion?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorksheetSumOrderByAggregateInput = {
    totalQuestions?: SortOrder
    currentQuestion?: SortOrder
  }

  export type WorksheetRelationFilter = {
    is?: WorksheetWhereInput
    isNot?: WorksheetWhereInput
  }

  export type DoubtNullableRelationFilter = {
    is?: DoubtWhereInput | null
    isNot?: DoubtWhereInput | null
  }

  export type WorksheetQuestionWorksheetIdQuestionNumberCompoundUniqueInput = {
    worksheetId: string
    questionNumber: number
  }

  export type WorksheetQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    doubtId?: SortOrder
    status?: SortOrder
    cachedExplanation?: SortOrder
    createdAt?: SortOrder
  }

  export type WorksheetQuestionAvgOrderByAggregateInput = {
    questionNumber?: SortOrder
  }

  export type WorksheetQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    doubtId?: SortOrder
    status?: SortOrder
    cachedExplanation?: SortOrder
    createdAt?: SortOrder
  }

  export type WorksheetQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    worksheetId?: SortOrder
    questionNumber?: SortOrder
    doubtId?: SortOrder
    status?: SortOrder
    cachedExplanation?: SortOrder
    createdAt?: SortOrder
  }

  export type WorksheetQuestionSumOrderByAggregateInput = {
    questionNumber?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DoubtRatingUserIdDoubtIdCompoundUniqueInput = {
    userId: string
    doubtId: string
  }

  export type DoubtRatingCountOrderByAggregateInput = {
    id?: SortOrder
    doubtId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoubtRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type DoubtRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    doubtId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoubtRatingMinOrderByAggregateInput = {
    id?: SortOrder
    doubtId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoubtRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type RevisionSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    weakAreas?: SortOrder
    phasesCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevisionSessionAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type RevisionSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    weakAreas?: SortOrder
    phasesCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevisionSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    weakAreas?: SortOrder
    phasesCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevisionSessionSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type WeakTopicUserIdTopicSubjectCompoundUniqueInput = {
    userId: string
    topic: string
    subject: string
  }

  export type WeakTopicCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    occurrences?: SortOrder
    lastSeen?: SortOrder
    improved?: SortOrder
    improvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeakTopicAvgOrderByAggregateInput = {
    occurrences?: SortOrder
  }

  export type WeakTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    occurrences?: SortOrder
    lastSeen?: SortOrder
    improved?: SortOrder
    improvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeakTopicMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    occurrences?: SortOrder
    lastSeen?: SortOrder
    improved?: SortOrder
    improvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeakTopicSumOrderByAggregateInput = {
    occurrences?: SortOrder
  }

  export type GroupStudySessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    question?: SortOrder
    classmate1Name?: SortOrder
    classmate2Name?: SortOrder
    studentAnswer?: SortOrder
    classmate1Question?: SortOrder
    classmate2Counter?: SortOrder
    classmate1Response?: SortOrder
    classmate2Response?: SortOrder
    handlingScore?: SortOrder
    strengths?: SortOrder
    improvements?: SortOrder
    challengesCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupStudySessionAvgOrderByAggregateInput = {
    handlingScore?: SortOrder
    challengesCount?: SortOrder
  }

  export type GroupStudySessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    question?: SortOrder
    classmate1Name?: SortOrder
    classmate2Name?: SortOrder
    studentAnswer?: SortOrder
    classmate1Question?: SortOrder
    classmate2Counter?: SortOrder
    classmate1Response?: SortOrder
    classmate2Response?: SortOrder
    handlingScore?: SortOrder
    strengths?: SortOrder
    improvements?: SortOrder
    challengesCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupStudySessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    question?: SortOrder
    classmate1Name?: SortOrder
    classmate2Name?: SortOrder
    studentAnswer?: SortOrder
    classmate1Question?: SortOrder
    classmate2Counter?: SortOrder
    classmate1Response?: SortOrder
    classmate2Response?: SortOrder
    handlingScore?: SortOrder
    strengths?: SortOrder
    improvements?: SortOrder
    challengesCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupStudySessionSumOrderByAggregateInput = {
    handlingScore?: SortOrder
    challengesCount?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type HandlingSkillProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    avgScore?: SortOrder
    sessionsCount?: SortOrder
    badges?: SortOrder
    lastSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandlingSkillProgressAvgOrderByAggregateInput = {
    avgScore?: SortOrder
    sessionsCount?: SortOrder
  }

  export type HandlingSkillProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    avgScore?: SortOrder
    sessionsCount?: SortOrder
    badges?: SortOrder
    lastSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandlingSkillProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    avgScore?: SortOrder
    sessionsCount?: SortOrder
    badges?: SortOrder
    lastSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandlingSkillProgressSumOrderByAggregateInput = {
    avgScore?: SortOrder
    sessionsCount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type QuestionCreateNestedManyWithoutQuestionPaperInput = {
    create?: XOR<QuestionCreateWithoutQuestionPaperInput, QuestionUncheckedCreateWithoutQuestionPaperInput> | QuestionCreateWithoutQuestionPaperInput[] | QuestionUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionPaperInput | QuestionCreateOrConnectWithoutQuestionPaperInput[]
    createMany?: QuestionCreateManyQuestionPaperInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type GradingCreateNestedManyWithoutQuestionPaperInput = {
    create?: XOR<GradingCreateWithoutQuestionPaperInput, GradingUncheckedCreateWithoutQuestionPaperInput> | GradingCreateWithoutQuestionPaperInput[] | GradingUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutQuestionPaperInput | GradingCreateOrConnectWithoutQuestionPaperInput[]
    createMany?: GradingCreateManyQuestionPaperInputEnvelope
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutQuestionPaperInput = {
    create?: XOR<QuestionCreateWithoutQuestionPaperInput, QuestionUncheckedCreateWithoutQuestionPaperInput> | QuestionCreateWithoutQuestionPaperInput[] | QuestionUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionPaperInput | QuestionCreateOrConnectWithoutQuestionPaperInput[]
    createMany?: QuestionCreateManyQuestionPaperInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type GradingUncheckedCreateNestedManyWithoutQuestionPaperInput = {
    create?: XOR<GradingCreateWithoutQuestionPaperInput, GradingUncheckedCreateWithoutQuestionPaperInput> | GradingCreateWithoutQuestionPaperInput[] | GradingUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutQuestionPaperInput | GradingCreateOrConnectWithoutQuestionPaperInput[]
    createMany?: GradingCreateManyQuestionPaperInputEnvelope
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type QuestionUpdateManyWithoutQuestionPaperNestedInput = {
    create?: XOR<QuestionCreateWithoutQuestionPaperInput, QuestionUncheckedCreateWithoutQuestionPaperInput> | QuestionCreateWithoutQuestionPaperInput[] | QuestionUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionPaperInput | QuestionCreateOrConnectWithoutQuestionPaperInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutQuestionPaperInput | QuestionUpsertWithWhereUniqueWithoutQuestionPaperInput[]
    createMany?: QuestionCreateManyQuestionPaperInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutQuestionPaperInput | QuestionUpdateWithWhereUniqueWithoutQuestionPaperInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutQuestionPaperInput | QuestionUpdateManyWithWhereWithoutQuestionPaperInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type GradingUpdateManyWithoutQuestionPaperNestedInput = {
    create?: XOR<GradingCreateWithoutQuestionPaperInput, GradingUncheckedCreateWithoutQuestionPaperInput> | GradingCreateWithoutQuestionPaperInput[] | GradingUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutQuestionPaperInput | GradingCreateOrConnectWithoutQuestionPaperInput[]
    upsert?: GradingUpsertWithWhereUniqueWithoutQuestionPaperInput | GradingUpsertWithWhereUniqueWithoutQuestionPaperInput[]
    createMany?: GradingCreateManyQuestionPaperInputEnvelope
    set?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    update?: GradingUpdateWithWhereUniqueWithoutQuestionPaperInput | GradingUpdateWithWhereUniqueWithoutQuestionPaperInput[]
    updateMany?: GradingUpdateManyWithWhereWithoutQuestionPaperInput | GradingUpdateManyWithWhereWithoutQuestionPaperInput[]
    deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutQuestionPaperNestedInput = {
    create?: XOR<QuestionCreateWithoutQuestionPaperInput, QuestionUncheckedCreateWithoutQuestionPaperInput> | QuestionCreateWithoutQuestionPaperInput[] | QuestionUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionPaperInput | QuestionCreateOrConnectWithoutQuestionPaperInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutQuestionPaperInput | QuestionUpsertWithWhereUniqueWithoutQuestionPaperInput[]
    createMany?: QuestionCreateManyQuestionPaperInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutQuestionPaperInput | QuestionUpdateWithWhereUniqueWithoutQuestionPaperInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutQuestionPaperInput | QuestionUpdateManyWithWhereWithoutQuestionPaperInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type GradingUncheckedUpdateManyWithoutQuestionPaperNestedInput = {
    create?: XOR<GradingCreateWithoutQuestionPaperInput, GradingUncheckedCreateWithoutQuestionPaperInput> | GradingCreateWithoutQuestionPaperInput[] | GradingUncheckedCreateWithoutQuestionPaperInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutQuestionPaperInput | GradingCreateOrConnectWithoutQuestionPaperInput[]
    upsert?: GradingUpsertWithWhereUniqueWithoutQuestionPaperInput | GradingUpsertWithWhereUniqueWithoutQuestionPaperInput[]
    createMany?: GradingCreateManyQuestionPaperInputEnvelope
    set?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    update?: GradingUpdateWithWhereUniqueWithoutQuestionPaperInput | GradingUpdateWithWhereUniqueWithoutQuestionPaperInput[]
    updateMany?: GradingUpdateManyWithWhereWithoutQuestionPaperInput | GradingUpdateManyWithWhereWithoutQuestionPaperInput[]
    deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[]
  }

  export type QuestionPaperCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuestionPaperCreateWithoutQuestionsInput, QuestionPaperUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuestionPaperCreateOrConnectWithoutQuestionsInput
    connect?: QuestionPaperWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QuestionPaperUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuestionPaperCreateWithoutQuestionsInput, QuestionPaperUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuestionPaperCreateOrConnectWithoutQuestionsInput
    upsert?: QuestionPaperUpsertWithoutQuestionsInput
    connect?: QuestionPaperWhereUniqueInput
    update?: XOR<XOR<QuestionPaperUpdateToOneWithWhereWithoutQuestionsInput, QuestionPaperUpdateWithoutQuestionsInput>, QuestionPaperUncheckedUpdateWithoutQuestionsInput>
  }

  export type GradingCreateNestedManyWithoutUserInput = {
    create?: XOR<GradingCreateWithoutUserInput, GradingUncheckedCreateWithoutUserInput> | GradingCreateWithoutUserInput[] | GradingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutUserInput | GradingCreateOrConnectWithoutUserInput[]
    createMany?: GradingCreateManyUserInputEnvelope
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
  }

  export type DoubtCreateNestedManyWithoutUserInput = {
    create?: XOR<DoubtCreateWithoutUserInput, DoubtUncheckedCreateWithoutUserInput> | DoubtCreateWithoutUserInput[] | DoubtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutUserInput | DoubtCreateOrConnectWithoutUserInput[]
    createMany?: DoubtCreateManyUserInputEnvelope
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
  }

  export type WorksheetCreateNestedManyWithoutUserInput = {
    create?: XOR<WorksheetCreateWithoutUserInput, WorksheetUncheckedCreateWithoutUserInput> | WorksheetCreateWithoutUserInput[] | WorksheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorksheetCreateOrConnectWithoutUserInput | WorksheetCreateOrConnectWithoutUserInput[]
    createMany?: WorksheetCreateManyUserInputEnvelope
    connect?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
  }

  export type DoubtRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<DoubtRatingCreateWithoutUserInput, DoubtRatingUncheckedCreateWithoutUserInput> | DoubtRatingCreateWithoutUserInput[] | DoubtRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutUserInput | DoubtRatingCreateOrConnectWithoutUserInput[]
    createMany?: DoubtRatingCreateManyUserInputEnvelope
    connect?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
  }

  export type RevisionSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<RevisionSessionCreateWithoutUserInput, RevisionSessionUncheckedCreateWithoutUserInput> | RevisionSessionCreateWithoutUserInput[] | RevisionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RevisionSessionCreateOrConnectWithoutUserInput | RevisionSessionCreateOrConnectWithoutUserInput[]
    createMany?: RevisionSessionCreateManyUserInputEnvelope
    connect?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
  }

  export type WeakTopicCreateNestedManyWithoutUserInput = {
    create?: XOR<WeakTopicCreateWithoutUserInput, WeakTopicUncheckedCreateWithoutUserInput> | WeakTopicCreateWithoutUserInput[] | WeakTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeakTopicCreateOrConnectWithoutUserInput | WeakTopicCreateOrConnectWithoutUserInput[]
    createMany?: WeakTopicCreateManyUserInputEnvelope
    connect?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
  }

  export type GroupStudySessionCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupStudySessionCreateWithoutUserInput, GroupStudySessionUncheckedCreateWithoutUserInput> | GroupStudySessionCreateWithoutUserInput[] | GroupStudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupStudySessionCreateOrConnectWithoutUserInput | GroupStudySessionCreateOrConnectWithoutUserInput[]
    createMany?: GroupStudySessionCreateManyUserInputEnvelope
    connect?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
  }

  export type HandlingSkillProgressCreateNestedOneWithoutUserInput = {
    create?: XOR<HandlingSkillProgressCreateWithoutUserInput, HandlingSkillProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: HandlingSkillProgressCreateOrConnectWithoutUserInput
    connect?: HandlingSkillProgressWhereUniqueInput
  }

  export type GradingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GradingCreateWithoutUserInput, GradingUncheckedCreateWithoutUserInput> | GradingCreateWithoutUserInput[] | GradingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutUserInput | GradingCreateOrConnectWithoutUserInput[]
    createMany?: GradingCreateManyUserInputEnvelope
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
  }

  export type DoubtUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DoubtCreateWithoutUserInput, DoubtUncheckedCreateWithoutUserInput> | DoubtCreateWithoutUserInput[] | DoubtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutUserInput | DoubtCreateOrConnectWithoutUserInput[]
    createMany?: DoubtCreateManyUserInputEnvelope
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
  }

  export type WorksheetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorksheetCreateWithoutUserInput, WorksheetUncheckedCreateWithoutUserInput> | WorksheetCreateWithoutUserInput[] | WorksheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorksheetCreateOrConnectWithoutUserInput | WorksheetCreateOrConnectWithoutUserInput[]
    createMany?: WorksheetCreateManyUserInputEnvelope
    connect?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
  }

  export type DoubtRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DoubtRatingCreateWithoutUserInput, DoubtRatingUncheckedCreateWithoutUserInput> | DoubtRatingCreateWithoutUserInput[] | DoubtRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutUserInput | DoubtRatingCreateOrConnectWithoutUserInput[]
    createMany?: DoubtRatingCreateManyUserInputEnvelope
    connect?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
  }

  export type RevisionSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RevisionSessionCreateWithoutUserInput, RevisionSessionUncheckedCreateWithoutUserInput> | RevisionSessionCreateWithoutUserInput[] | RevisionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RevisionSessionCreateOrConnectWithoutUserInput | RevisionSessionCreateOrConnectWithoutUserInput[]
    createMany?: RevisionSessionCreateManyUserInputEnvelope
    connect?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
  }

  export type WeakTopicUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WeakTopicCreateWithoutUserInput, WeakTopicUncheckedCreateWithoutUserInput> | WeakTopicCreateWithoutUserInput[] | WeakTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeakTopicCreateOrConnectWithoutUserInput | WeakTopicCreateOrConnectWithoutUserInput[]
    createMany?: WeakTopicCreateManyUserInputEnvelope
    connect?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
  }

  export type GroupStudySessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupStudySessionCreateWithoutUserInput, GroupStudySessionUncheckedCreateWithoutUserInput> | GroupStudySessionCreateWithoutUserInput[] | GroupStudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupStudySessionCreateOrConnectWithoutUserInput | GroupStudySessionCreateOrConnectWithoutUserInput[]
    createMany?: GroupStudySessionCreateManyUserInputEnvelope
    connect?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
  }

  export type HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HandlingSkillProgressCreateWithoutUserInput, HandlingSkillProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: HandlingSkillProgressCreateOrConnectWithoutUserInput
    connect?: HandlingSkillProgressWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type GradingUpdateManyWithoutUserNestedInput = {
    create?: XOR<GradingCreateWithoutUserInput, GradingUncheckedCreateWithoutUserInput> | GradingCreateWithoutUserInput[] | GradingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutUserInput | GradingCreateOrConnectWithoutUserInput[]
    upsert?: GradingUpsertWithWhereUniqueWithoutUserInput | GradingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GradingCreateManyUserInputEnvelope
    set?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    update?: GradingUpdateWithWhereUniqueWithoutUserInput | GradingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GradingUpdateManyWithWhereWithoutUserInput | GradingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[]
  }

  export type DoubtUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoubtCreateWithoutUserInput, DoubtUncheckedCreateWithoutUserInput> | DoubtCreateWithoutUserInput[] | DoubtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutUserInput | DoubtCreateOrConnectWithoutUserInput[]
    upsert?: DoubtUpsertWithWhereUniqueWithoutUserInput | DoubtUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DoubtCreateManyUserInputEnvelope
    set?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    disconnect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    delete?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    update?: DoubtUpdateWithWhereUniqueWithoutUserInput | DoubtUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DoubtUpdateManyWithWhereWithoutUserInput | DoubtUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DoubtScalarWhereInput | DoubtScalarWhereInput[]
  }

  export type WorksheetUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorksheetCreateWithoutUserInput, WorksheetUncheckedCreateWithoutUserInput> | WorksheetCreateWithoutUserInput[] | WorksheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorksheetCreateOrConnectWithoutUserInput | WorksheetCreateOrConnectWithoutUserInput[]
    upsert?: WorksheetUpsertWithWhereUniqueWithoutUserInput | WorksheetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorksheetCreateManyUserInputEnvelope
    set?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    disconnect?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    delete?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    connect?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    update?: WorksheetUpdateWithWhereUniqueWithoutUserInput | WorksheetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorksheetUpdateManyWithWhereWithoutUserInput | WorksheetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorksheetScalarWhereInput | WorksheetScalarWhereInput[]
  }

  export type DoubtRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoubtRatingCreateWithoutUserInput, DoubtRatingUncheckedCreateWithoutUserInput> | DoubtRatingCreateWithoutUserInput[] | DoubtRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutUserInput | DoubtRatingCreateOrConnectWithoutUserInput[]
    upsert?: DoubtRatingUpsertWithWhereUniqueWithoutUserInput | DoubtRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DoubtRatingCreateManyUserInputEnvelope
    set?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    disconnect?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    delete?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    connect?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    update?: DoubtRatingUpdateWithWhereUniqueWithoutUserInput | DoubtRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DoubtRatingUpdateManyWithWhereWithoutUserInput | DoubtRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DoubtRatingScalarWhereInput | DoubtRatingScalarWhereInput[]
  }

  export type RevisionSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<RevisionSessionCreateWithoutUserInput, RevisionSessionUncheckedCreateWithoutUserInput> | RevisionSessionCreateWithoutUserInput[] | RevisionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RevisionSessionCreateOrConnectWithoutUserInput | RevisionSessionCreateOrConnectWithoutUserInput[]
    upsert?: RevisionSessionUpsertWithWhereUniqueWithoutUserInput | RevisionSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RevisionSessionCreateManyUserInputEnvelope
    set?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    disconnect?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    delete?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    connect?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    update?: RevisionSessionUpdateWithWhereUniqueWithoutUserInput | RevisionSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RevisionSessionUpdateManyWithWhereWithoutUserInput | RevisionSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RevisionSessionScalarWhereInput | RevisionSessionScalarWhereInput[]
  }

  export type WeakTopicUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeakTopicCreateWithoutUserInput, WeakTopicUncheckedCreateWithoutUserInput> | WeakTopicCreateWithoutUserInput[] | WeakTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeakTopicCreateOrConnectWithoutUserInput | WeakTopicCreateOrConnectWithoutUserInput[]
    upsert?: WeakTopicUpsertWithWhereUniqueWithoutUserInput | WeakTopicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeakTopicCreateManyUserInputEnvelope
    set?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    disconnect?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    delete?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    connect?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    update?: WeakTopicUpdateWithWhereUniqueWithoutUserInput | WeakTopicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeakTopicUpdateManyWithWhereWithoutUserInput | WeakTopicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeakTopicScalarWhereInput | WeakTopicScalarWhereInput[]
  }

  export type GroupStudySessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupStudySessionCreateWithoutUserInput, GroupStudySessionUncheckedCreateWithoutUserInput> | GroupStudySessionCreateWithoutUserInput[] | GroupStudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupStudySessionCreateOrConnectWithoutUserInput | GroupStudySessionCreateOrConnectWithoutUserInput[]
    upsert?: GroupStudySessionUpsertWithWhereUniqueWithoutUserInput | GroupStudySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupStudySessionCreateManyUserInputEnvelope
    set?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    disconnect?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    delete?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    connect?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    update?: GroupStudySessionUpdateWithWhereUniqueWithoutUserInput | GroupStudySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupStudySessionUpdateManyWithWhereWithoutUserInput | GroupStudySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupStudySessionScalarWhereInput | GroupStudySessionScalarWhereInput[]
  }

  export type HandlingSkillProgressUpdateOneWithoutUserNestedInput = {
    create?: XOR<HandlingSkillProgressCreateWithoutUserInput, HandlingSkillProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: HandlingSkillProgressCreateOrConnectWithoutUserInput
    upsert?: HandlingSkillProgressUpsertWithoutUserInput
    disconnect?: HandlingSkillProgressWhereInput | boolean
    delete?: HandlingSkillProgressWhereInput | boolean
    connect?: HandlingSkillProgressWhereUniqueInput
    update?: XOR<XOR<HandlingSkillProgressUpdateToOneWithWhereWithoutUserInput, HandlingSkillProgressUpdateWithoutUserInput>, HandlingSkillProgressUncheckedUpdateWithoutUserInput>
  }

  export type GradingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GradingCreateWithoutUserInput, GradingUncheckedCreateWithoutUserInput> | GradingCreateWithoutUserInput[] | GradingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GradingCreateOrConnectWithoutUserInput | GradingCreateOrConnectWithoutUserInput[]
    upsert?: GradingUpsertWithWhereUniqueWithoutUserInput | GradingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GradingCreateManyUserInputEnvelope
    set?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[]
    update?: GradingUpdateWithWhereUniqueWithoutUserInput | GradingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GradingUpdateManyWithWhereWithoutUserInput | GradingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[]
  }

  export type DoubtUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoubtCreateWithoutUserInput, DoubtUncheckedCreateWithoutUserInput> | DoubtCreateWithoutUserInput[] | DoubtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutUserInput | DoubtCreateOrConnectWithoutUserInput[]
    upsert?: DoubtUpsertWithWhereUniqueWithoutUserInput | DoubtUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DoubtCreateManyUserInputEnvelope
    set?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    disconnect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    delete?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    update?: DoubtUpdateWithWhereUniqueWithoutUserInput | DoubtUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DoubtUpdateManyWithWhereWithoutUserInput | DoubtUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DoubtScalarWhereInput | DoubtScalarWhereInput[]
  }

  export type WorksheetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorksheetCreateWithoutUserInput, WorksheetUncheckedCreateWithoutUserInput> | WorksheetCreateWithoutUserInput[] | WorksheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorksheetCreateOrConnectWithoutUserInput | WorksheetCreateOrConnectWithoutUserInput[]
    upsert?: WorksheetUpsertWithWhereUniqueWithoutUserInput | WorksheetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorksheetCreateManyUserInputEnvelope
    set?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    disconnect?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    delete?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    connect?: WorksheetWhereUniqueInput | WorksheetWhereUniqueInput[]
    update?: WorksheetUpdateWithWhereUniqueWithoutUserInput | WorksheetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorksheetUpdateManyWithWhereWithoutUserInput | WorksheetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorksheetScalarWhereInput | WorksheetScalarWhereInput[]
  }

  export type DoubtRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoubtRatingCreateWithoutUserInput, DoubtRatingUncheckedCreateWithoutUserInput> | DoubtRatingCreateWithoutUserInput[] | DoubtRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutUserInput | DoubtRatingCreateOrConnectWithoutUserInput[]
    upsert?: DoubtRatingUpsertWithWhereUniqueWithoutUserInput | DoubtRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DoubtRatingCreateManyUserInputEnvelope
    set?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    disconnect?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    delete?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    connect?: DoubtRatingWhereUniqueInput | DoubtRatingWhereUniqueInput[]
    update?: DoubtRatingUpdateWithWhereUniqueWithoutUserInput | DoubtRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DoubtRatingUpdateManyWithWhereWithoutUserInput | DoubtRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DoubtRatingScalarWhereInput | DoubtRatingScalarWhereInput[]
  }

  export type RevisionSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RevisionSessionCreateWithoutUserInput, RevisionSessionUncheckedCreateWithoutUserInput> | RevisionSessionCreateWithoutUserInput[] | RevisionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RevisionSessionCreateOrConnectWithoutUserInput | RevisionSessionCreateOrConnectWithoutUserInput[]
    upsert?: RevisionSessionUpsertWithWhereUniqueWithoutUserInput | RevisionSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RevisionSessionCreateManyUserInputEnvelope
    set?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    disconnect?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    delete?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    connect?: RevisionSessionWhereUniqueInput | RevisionSessionWhereUniqueInput[]
    update?: RevisionSessionUpdateWithWhereUniqueWithoutUserInput | RevisionSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RevisionSessionUpdateManyWithWhereWithoutUserInput | RevisionSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RevisionSessionScalarWhereInput | RevisionSessionScalarWhereInput[]
  }

  export type WeakTopicUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeakTopicCreateWithoutUserInput, WeakTopicUncheckedCreateWithoutUserInput> | WeakTopicCreateWithoutUserInput[] | WeakTopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeakTopicCreateOrConnectWithoutUserInput | WeakTopicCreateOrConnectWithoutUserInput[]
    upsert?: WeakTopicUpsertWithWhereUniqueWithoutUserInput | WeakTopicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeakTopicCreateManyUserInputEnvelope
    set?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    disconnect?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    delete?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    connect?: WeakTopicWhereUniqueInput | WeakTopicWhereUniqueInput[]
    update?: WeakTopicUpdateWithWhereUniqueWithoutUserInput | WeakTopicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeakTopicUpdateManyWithWhereWithoutUserInput | WeakTopicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeakTopicScalarWhereInput | WeakTopicScalarWhereInput[]
  }

  export type GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupStudySessionCreateWithoutUserInput, GroupStudySessionUncheckedCreateWithoutUserInput> | GroupStudySessionCreateWithoutUserInput[] | GroupStudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupStudySessionCreateOrConnectWithoutUserInput | GroupStudySessionCreateOrConnectWithoutUserInput[]
    upsert?: GroupStudySessionUpsertWithWhereUniqueWithoutUserInput | GroupStudySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupStudySessionCreateManyUserInputEnvelope
    set?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    disconnect?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    delete?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    connect?: GroupStudySessionWhereUniqueInput | GroupStudySessionWhereUniqueInput[]
    update?: GroupStudySessionUpdateWithWhereUniqueWithoutUserInput | GroupStudySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupStudySessionUpdateManyWithWhereWithoutUserInput | GroupStudySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupStudySessionScalarWhereInput | GroupStudySessionScalarWhereInput[]
  }

  export type HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HandlingSkillProgressCreateWithoutUserInput, HandlingSkillProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: HandlingSkillProgressCreateOrConnectWithoutUserInput
    upsert?: HandlingSkillProgressUpsertWithoutUserInput
    disconnect?: HandlingSkillProgressWhereInput | boolean
    delete?: HandlingSkillProgressWhereInput | boolean
    connect?: HandlingSkillProgressWhereUniqueInput
    update?: XOR<XOR<HandlingSkillProgressUpdateToOneWithWhereWithoutUserInput, HandlingSkillProgressUpdateWithoutUserInput>, HandlingSkillProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutGradingsInput = {
    create?: XOR<UserCreateWithoutGradingsInput, UserUncheckedCreateWithoutGradingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradingsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionPaperCreateNestedOneWithoutGradingsInput = {
    create?: XOR<QuestionPaperCreateWithoutGradingsInput, QuestionPaperUncheckedCreateWithoutGradingsInput>
    connectOrCreate?: QuestionPaperCreateOrConnectWithoutGradingsInput
    connect?: QuestionPaperWhereUniqueInput
  }

  export type GradingPageCreateNestedManyWithoutGradingInput = {
    create?: XOR<GradingPageCreateWithoutGradingInput, GradingPageUncheckedCreateWithoutGradingInput> | GradingPageCreateWithoutGradingInput[] | GradingPageUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: GradingPageCreateOrConnectWithoutGradingInput | GradingPageCreateOrConnectWithoutGradingInput[]
    createMany?: GradingPageCreateManyGradingInputEnvelope
    connect?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
  }

  export type AnswerCreateNestedManyWithoutGradingInput = {
    create?: XOR<AnswerCreateWithoutGradingInput, AnswerUncheckedCreateWithoutGradingInput> | AnswerCreateWithoutGradingInput[] | AnswerUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutGradingInput | AnswerCreateOrConnectWithoutGradingInput[]
    createMany?: AnswerCreateManyGradingInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type GradingPageUncheckedCreateNestedManyWithoutGradingInput = {
    create?: XOR<GradingPageCreateWithoutGradingInput, GradingPageUncheckedCreateWithoutGradingInput> | GradingPageCreateWithoutGradingInput[] | GradingPageUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: GradingPageCreateOrConnectWithoutGradingInput | GradingPageCreateOrConnectWithoutGradingInput[]
    createMany?: GradingPageCreateManyGradingInputEnvelope
    connect?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutGradingInput = {
    create?: XOR<AnswerCreateWithoutGradingInput, AnswerUncheckedCreateWithoutGradingInput> | AnswerCreateWithoutGradingInput[] | AnswerUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutGradingInput | AnswerCreateOrConnectWithoutGradingInput[]
    createMany?: AnswerCreateManyGradingInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutGradingsNestedInput = {
    create?: XOR<UserCreateWithoutGradingsInput, UserUncheckedCreateWithoutGradingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradingsInput
    upsert?: UserUpsertWithoutGradingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGradingsInput, UserUpdateWithoutGradingsInput>, UserUncheckedUpdateWithoutGradingsInput>
  }

  export type QuestionPaperUpdateOneWithoutGradingsNestedInput = {
    create?: XOR<QuestionPaperCreateWithoutGradingsInput, QuestionPaperUncheckedCreateWithoutGradingsInput>
    connectOrCreate?: QuestionPaperCreateOrConnectWithoutGradingsInput
    upsert?: QuestionPaperUpsertWithoutGradingsInput
    disconnect?: QuestionPaperWhereInput | boolean
    delete?: QuestionPaperWhereInput | boolean
    connect?: QuestionPaperWhereUniqueInput
    update?: XOR<XOR<QuestionPaperUpdateToOneWithWhereWithoutGradingsInput, QuestionPaperUpdateWithoutGradingsInput>, QuestionPaperUncheckedUpdateWithoutGradingsInput>
  }

  export type GradingPageUpdateManyWithoutGradingNestedInput = {
    create?: XOR<GradingPageCreateWithoutGradingInput, GradingPageUncheckedCreateWithoutGradingInput> | GradingPageCreateWithoutGradingInput[] | GradingPageUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: GradingPageCreateOrConnectWithoutGradingInput | GradingPageCreateOrConnectWithoutGradingInput[]
    upsert?: GradingPageUpsertWithWhereUniqueWithoutGradingInput | GradingPageUpsertWithWhereUniqueWithoutGradingInput[]
    createMany?: GradingPageCreateManyGradingInputEnvelope
    set?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    disconnect?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    delete?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    connect?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    update?: GradingPageUpdateWithWhereUniqueWithoutGradingInput | GradingPageUpdateWithWhereUniqueWithoutGradingInput[]
    updateMany?: GradingPageUpdateManyWithWhereWithoutGradingInput | GradingPageUpdateManyWithWhereWithoutGradingInput[]
    deleteMany?: GradingPageScalarWhereInput | GradingPageScalarWhereInput[]
  }

  export type AnswerUpdateManyWithoutGradingNestedInput = {
    create?: XOR<AnswerCreateWithoutGradingInput, AnswerUncheckedCreateWithoutGradingInput> | AnswerCreateWithoutGradingInput[] | AnswerUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutGradingInput | AnswerCreateOrConnectWithoutGradingInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutGradingInput | AnswerUpsertWithWhereUniqueWithoutGradingInput[]
    createMany?: AnswerCreateManyGradingInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutGradingInput | AnswerUpdateWithWhereUniqueWithoutGradingInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutGradingInput | AnswerUpdateManyWithWhereWithoutGradingInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type GradingPageUncheckedUpdateManyWithoutGradingNestedInput = {
    create?: XOR<GradingPageCreateWithoutGradingInput, GradingPageUncheckedCreateWithoutGradingInput> | GradingPageCreateWithoutGradingInput[] | GradingPageUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: GradingPageCreateOrConnectWithoutGradingInput | GradingPageCreateOrConnectWithoutGradingInput[]
    upsert?: GradingPageUpsertWithWhereUniqueWithoutGradingInput | GradingPageUpsertWithWhereUniqueWithoutGradingInput[]
    createMany?: GradingPageCreateManyGradingInputEnvelope
    set?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    disconnect?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    delete?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    connect?: GradingPageWhereUniqueInput | GradingPageWhereUniqueInput[]
    update?: GradingPageUpdateWithWhereUniqueWithoutGradingInput | GradingPageUpdateWithWhereUniqueWithoutGradingInput[]
    updateMany?: GradingPageUpdateManyWithWhereWithoutGradingInput | GradingPageUpdateManyWithWhereWithoutGradingInput[]
    deleteMany?: GradingPageScalarWhereInput | GradingPageScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutGradingNestedInput = {
    create?: XOR<AnswerCreateWithoutGradingInput, AnswerUncheckedCreateWithoutGradingInput> | AnswerCreateWithoutGradingInput[] | AnswerUncheckedCreateWithoutGradingInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutGradingInput | AnswerCreateOrConnectWithoutGradingInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutGradingInput | AnswerUpsertWithWhereUniqueWithoutGradingInput[]
    createMany?: AnswerCreateManyGradingInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutGradingInput | AnswerUpdateWithWhereUniqueWithoutGradingInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutGradingInput | AnswerUpdateManyWithWhereWithoutGradingInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type GradingCreateNestedOneWithoutPagesInput = {
    create?: XOR<GradingCreateWithoutPagesInput, GradingUncheckedCreateWithoutPagesInput>
    connectOrCreate?: GradingCreateOrConnectWithoutPagesInput
    connect?: GradingWhereUniqueInput
  }

  export type PageAnswerCreateNestedManyWithoutPageInput = {
    create?: XOR<PageAnswerCreateWithoutPageInput, PageAnswerUncheckedCreateWithoutPageInput> | PageAnswerCreateWithoutPageInput[] | PageAnswerUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageAnswerCreateOrConnectWithoutPageInput | PageAnswerCreateOrConnectWithoutPageInput[]
    createMany?: PageAnswerCreateManyPageInputEnvelope
    connect?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
  }

  export type PageAnswerUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<PageAnswerCreateWithoutPageInput, PageAnswerUncheckedCreateWithoutPageInput> | PageAnswerCreateWithoutPageInput[] | PageAnswerUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageAnswerCreateOrConnectWithoutPageInput | PageAnswerCreateOrConnectWithoutPageInput[]
    createMany?: PageAnswerCreateManyPageInputEnvelope
    connect?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
  }

  export type GradingUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<GradingCreateWithoutPagesInput, GradingUncheckedCreateWithoutPagesInput>
    connectOrCreate?: GradingCreateOrConnectWithoutPagesInput
    upsert?: GradingUpsertWithoutPagesInput
    connect?: GradingWhereUniqueInput
    update?: XOR<XOR<GradingUpdateToOneWithWhereWithoutPagesInput, GradingUpdateWithoutPagesInput>, GradingUncheckedUpdateWithoutPagesInput>
  }

  export type PageAnswerUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageAnswerCreateWithoutPageInput, PageAnswerUncheckedCreateWithoutPageInput> | PageAnswerCreateWithoutPageInput[] | PageAnswerUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageAnswerCreateOrConnectWithoutPageInput | PageAnswerCreateOrConnectWithoutPageInput[]
    upsert?: PageAnswerUpsertWithWhereUniqueWithoutPageInput | PageAnswerUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageAnswerCreateManyPageInputEnvelope
    set?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    disconnect?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    delete?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    connect?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    update?: PageAnswerUpdateWithWhereUniqueWithoutPageInput | PageAnswerUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageAnswerUpdateManyWithWhereWithoutPageInput | PageAnswerUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageAnswerScalarWhereInput | PageAnswerScalarWhereInput[]
  }

  export type PageAnswerUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageAnswerCreateWithoutPageInput, PageAnswerUncheckedCreateWithoutPageInput> | PageAnswerCreateWithoutPageInput[] | PageAnswerUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageAnswerCreateOrConnectWithoutPageInput | PageAnswerCreateOrConnectWithoutPageInput[]
    upsert?: PageAnswerUpsertWithWhereUniqueWithoutPageInput | PageAnswerUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageAnswerCreateManyPageInputEnvelope
    set?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    disconnect?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    delete?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    connect?: PageAnswerWhereUniqueInput | PageAnswerWhereUniqueInput[]
    update?: PageAnswerUpdateWithWhereUniqueWithoutPageInput | PageAnswerUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageAnswerUpdateManyWithWhereWithoutPageInput | PageAnswerUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageAnswerScalarWhereInput | PageAnswerScalarWhereInput[]
  }

  export type GradingPageCreateNestedOneWithoutPageAnswersInput = {
    create?: XOR<GradingPageCreateWithoutPageAnswersInput, GradingPageUncheckedCreateWithoutPageAnswersInput>
    connectOrCreate?: GradingPageCreateOrConnectWithoutPageAnswersInput
    connect?: GradingPageWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GradingPageUpdateOneRequiredWithoutPageAnswersNestedInput = {
    create?: XOR<GradingPageCreateWithoutPageAnswersInput, GradingPageUncheckedCreateWithoutPageAnswersInput>
    connectOrCreate?: GradingPageCreateOrConnectWithoutPageAnswersInput
    upsert?: GradingPageUpsertWithoutPageAnswersInput
    connect?: GradingPageWhereUniqueInput
    update?: XOR<XOR<GradingPageUpdateToOneWithWhereWithoutPageAnswersInput, GradingPageUpdateWithoutPageAnswersInput>, GradingPageUncheckedUpdateWithoutPageAnswersInput>
  }

  export type GradingCreateNestedOneWithoutAnswersInput = {
    create?: XOR<GradingCreateWithoutAnswersInput, GradingUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: GradingCreateOrConnectWithoutAnswersInput
    connect?: GradingWhereUniqueInput
  }

  export type GradingUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<GradingCreateWithoutAnswersInput, GradingUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: GradingCreateOrConnectWithoutAnswersInput
    upsert?: GradingUpsertWithoutAnswersInput
    connect?: GradingWhereUniqueInput
    update?: XOR<XOR<GradingUpdateToOneWithWhereWithoutAnswersInput, GradingUpdateWithoutAnswersInput>, GradingUncheckedUpdateWithoutAnswersInput>
  }

  export type UserCreateNestedOneWithoutDoubtsInput = {
    create?: XOR<UserCreateWithoutDoubtsInput, UserUncheckedCreateWithoutDoubtsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoubtsInput
    connect?: UserWhereUniqueInput
  }

  export type DoubtMessageCreateNestedManyWithoutDoubtInput = {
    create?: XOR<DoubtMessageCreateWithoutDoubtInput, DoubtMessageUncheckedCreateWithoutDoubtInput> | DoubtMessageCreateWithoutDoubtInput[] | DoubtMessageUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: DoubtMessageCreateOrConnectWithoutDoubtInput | DoubtMessageCreateOrConnectWithoutDoubtInput[]
    createMany?: DoubtMessageCreateManyDoubtInputEnvelope
    connect?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
  }

  export type WorksheetCreateNestedOneWithoutDoubtsInput = {
    create?: XOR<WorksheetCreateWithoutDoubtsInput, WorksheetUncheckedCreateWithoutDoubtsInput>
    connectOrCreate?: WorksheetCreateOrConnectWithoutDoubtsInput
    connect?: WorksheetWhereUniqueInput
  }

  export type WorksheetQuestionCreateNestedManyWithoutDoubtInput = {
    create?: XOR<WorksheetQuestionCreateWithoutDoubtInput, WorksheetQuestionUncheckedCreateWithoutDoubtInput> | WorksheetQuestionCreateWithoutDoubtInput[] | WorksheetQuestionUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutDoubtInput | WorksheetQuestionCreateOrConnectWithoutDoubtInput[]
    createMany?: WorksheetQuestionCreateManyDoubtInputEnvelope
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
  }

  export type DoubtRatingCreateNestedOneWithoutDoubtInput = {
    create?: XOR<DoubtRatingCreateWithoutDoubtInput, DoubtRatingUncheckedCreateWithoutDoubtInput>
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutDoubtInput
    connect?: DoubtRatingWhereUniqueInput
  }

  export type DoubtMessageUncheckedCreateNestedManyWithoutDoubtInput = {
    create?: XOR<DoubtMessageCreateWithoutDoubtInput, DoubtMessageUncheckedCreateWithoutDoubtInput> | DoubtMessageCreateWithoutDoubtInput[] | DoubtMessageUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: DoubtMessageCreateOrConnectWithoutDoubtInput | DoubtMessageCreateOrConnectWithoutDoubtInput[]
    createMany?: DoubtMessageCreateManyDoubtInputEnvelope
    connect?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
  }

  export type WorksheetQuestionUncheckedCreateNestedManyWithoutDoubtInput = {
    create?: XOR<WorksheetQuestionCreateWithoutDoubtInput, WorksheetQuestionUncheckedCreateWithoutDoubtInput> | WorksheetQuestionCreateWithoutDoubtInput[] | WorksheetQuestionUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutDoubtInput | WorksheetQuestionCreateOrConnectWithoutDoubtInput[]
    createMany?: WorksheetQuestionCreateManyDoubtInputEnvelope
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
  }

  export type DoubtRatingUncheckedCreateNestedOneWithoutDoubtInput = {
    create?: XOR<DoubtRatingCreateWithoutDoubtInput, DoubtRatingUncheckedCreateWithoutDoubtInput>
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutDoubtInput
    connect?: DoubtRatingWhereUniqueInput
  }

  export type UserUpdateOneWithoutDoubtsNestedInput = {
    create?: XOR<UserCreateWithoutDoubtsInput, UserUncheckedCreateWithoutDoubtsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoubtsInput
    upsert?: UserUpsertWithoutDoubtsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoubtsInput, UserUpdateWithoutDoubtsInput>, UserUncheckedUpdateWithoutDoubtsInput>
  }

  export type DoubtMessageUpdateManyWithoutDoubtNestedInput = {
    create?: XOR<DoubtMessageCreateWithoutDoubtInput, DoubtMessageUncheckedCreateWithoutDoubtInput> | DoubtMessageCreateWithoutDoubtInput[] | DoubtMessageUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: DoubtMessageCreateOrConnectWithoutDoubtInput | DoubtMessageCreateOrConnectWithoutDoubtInput[]
    upsert?: DoubtMessageUpsertWithWhereUniqueWithoutDoubtInput | DoubtMessageUpsertWithWhereUniqueWithoutDoubtInput[]
    createMany?: DoubtMessageCreateManyDoubtInputEnvelope
    set?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    disconnect?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    delete?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    connect?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    update?: DoubtMessageUpdateWithWhereUniqueWithoutDoubtInput | DoubtMessageUpdateWithWhereUniqueWithoutDoubtInput[]
    updateMany?: DoubtMessageUpdateManyWithWhereWithoutDoubtInput | DoubtMessageUpdateManyWithWhereWithoutDoubtInput[]
    deleteMany?: DoubtMessageScalarWhereInput | DoubtMessageScalarWhereInput[]
  }

  export type WorksheetUpdateOneWithoutDoubtsNestedInput = {
    create?: XOR<WorksheetCreateWithoutDoubtsInput, WorksheetUncheckedCreateWithoutDoubtsInput>
    connectOrCreate?: WorksheetCreateOrConnectWithoutDoubtsInput
    upsert?: WorksheetUpsertWithoutDoubtsInput
    disconnect?: WorksheetWhereInput | boolean
    delete?: WorksheetWhereInput | boolean
    connect?: WorksheetWhereUniqueInput
    update?: XOR<XOR<WorksheetUpdateToOneWithWhereWithoutDoubtsInput, WorksheetUpdateWithoutDoubtsInput>, WorksheetUncheckedUpdateWithoutDoubtsInput>
  }

  export type WorksheetQuestionUpdateManyWithoutDoubtNestedInput = {
    create?: XOR<WorksheetQuestionCreateWithoutDoubtInput, WorksheetQuestionUncheckedCreateWithoutDoubtInput> | WorksheetQuestionCreateWithoutDoubtInput[] | WorksheetQuestionUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutDoubtInput | WorksheetQuestionCreateOrConnectWithoutDoubtInput[]
    upsert?: WorksheetQuestionUpsertWithWhereUniqueWithoutDoubtInput | WorksheetQuestionUpsertWithWhereUniqueWithoutDoubtInput[]
    createMany?: WorksheetQuestionCreateManyDoubtInputEnvelope
    set?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    disconnect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    delete?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    update?: WorksheetQuestionUpdateWithWhereUniqueWithoutDoubtInput | WorksheetQuestionUpdateWithWhereUniqueWithoutDoubtInput[]
    updateMany?: WorksheetQuestionUpdateManyWithWhereWithoutDoubtInput | WorksheetQuestionUpdateManyWithWhereWithoutDoubtInput[]
    deleteMany?: WorksheetQuestionScalarWhereInput | WorksheetQuestionScalarWhereInput[]
  }

  export type DoubtRatingUpdateOneWithoutDoubtNestedInput = {
    create?: XOR<DoubtRatingCreateWithoutDoubtInput, DoubtRatingUncheckedCreateWithoutDoubtInput>
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutDoubtInput
    upsert?: DoubtRatingUpsertWithoutDoubtInput
    disconnect?: DoubtRatingWhereInput | boolean
    delete?: DoubtRatingWhereInput | boolean
    connect?: DoubtRatingWhereUniqueInput
    update?: XOR<XOR<DoubtRatingUpdateToOneWithWhereWithoutDoubtInput, DoubtRatingUpdateWithoutDoubtInput>, DoubtRatingUncheckedUpdateWithoutDoubtInput>
  }

  export type DoubtMessageUncheckedUpdateManyWithoutDoubtNestedInput = {
    create?: XOR<DoubtMessageCreateWithoutDoubtInput, DoubtMessageUncheckedCreateWithoutDoubtInput> | DoubtMessageCreateWithoutDoubtInput[] | DoubtMessageUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: DoubtMessageCreateOrConnectWithoutDoubtInput | DoubtMessageCreateOrConnectWithoutDoubtInput[]
    upsert?: DoubtMessageUpsertWithWhereUniqueWithoutDoubtInput | DoubtMessageUpsertWithWhereUniqueWithoutDoubtInput[]
    createMany?: DoubtMessageCreateManyDoubtInputEnvelope
    set?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    disconnect?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    delete?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    connect?: DoubtMessageWhereUniqueInput | DoubtMessageWhereUniqueInput[]
    update?: DoubtMessageUpdateWithWhereUniqueWithoutDoubtInput | DoubtMessageUpdateWithWhereUniqueWithoutDoubtInput[]
    updateMany?: DoubtMessageUpdateManyWithWhereWithoutDoubtInput | DoubtMessageUpdateManyWithWhereWithoutDoubtInput[]
    deleteMany?: DoubtMessageScalarWhereInput | DoubtMessageScalarWhereInput[]
  }

  export type WorksheetQuestionUncheckedUpdateManyWithoutDoubtNestedInput = {
    create?: XOR<WorksheetQuestionCreateWithoutDoubtInput, WorksheetQuestionUncheckedCreateWithoutDoubtInput> | WorksheetQuestionCreateWithoutDoubtInput[] | WorksheetQuestionUncheckedCreateWithoutDoubtInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutDoubtInput | WorksheetQuestionCreateOrConnectWithoutDoubtInput[]
    upsert?: WorksheetQuestionUpsertWithWhereUniqueWithoutDoubtInput | WorksheetQuestionUpsertWithWhereUniqueWithoutDoubtInput[]
    createMany?: WorksheetQuestionCreateManyDoubtInputEnvelope
    set?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    disconnect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    delete?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    update?: WorksheetQuestionUpdateWithWhereUniqueWithoutDoubtInput | WorksheetQuestionUpdateWithWhereUniqueWithoutDoubtInput[]
    updateMany?: WorksheetQuestionUpdateManyWithWhereWithoutDoubtInput | WorksheetQuestionUpdateManyWithWhereWithoutDoubtInput[]
    deleteMany?: WorksheetQuestionScalarWhereInput | WorksheetQuestionScalarWhereInput[]
  }

  export type DoubtRatingUncheckedUpdateOneWithoutDoubtNestedInput = {
    create?: XOR<DoubtRatingCreateWithoutDoubtInput, DoubtRatingUncheckedCreateWithoutDoubtInput>
    connectOrCreate?: DoubtRatingCreateOrConnectWithoutDoubtInput
    upsert?: DoubtRatingUpsertWithoutDoubtInput
    disconnect?: DoubtRatingWhereInput | boolean
    delete?: DoubtRatingWhereInput | boolean
    connect?: DoubtRatingWhereUniqueInput
    update?: XOR<XOR<DoubtRatingUpdateToOneWithWhereWithoutDoubtInput, DoubtRatingUpdateWithoutDoubtInput>, DoubtRatingUncheckedUpdateWithoutDoubtInput>
  }

  export type DoubtCreateNestedOneWithoutMessagesInput = {
    create?: XOR<DoubtCreateWithoutMessagesInput, DoubtUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: DoubtCreateOrConnectWithoutMessagesInput
    connect?: DoubtWhereUniqueInput
  }

  export type DoubtUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<DoubtCreateWithoutMessagesInput, DoubtUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: DoubtCreateOrConnectWithoutMessagesInput
    upsert?: DoubtUpsertWithoutMessagesInput
    connect?: DoubtWhereUniqueInput
    update?: XOR<XOR<DoubtUpdateToOneWithWhereWithoutMessagesInput, DoubtUpdateWithoutMessagesInput>, DoubtUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutWorksheetsInput = {
    create?: XOR<UserCreateWithoutWorksheetsInput, UserUncheckedCreateWithoutWorksheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorksheetsInput
    connect?: UserWhereUniqueInput
  }

  export type WorksheetQuestionCreateNestedManyWithoutWorksheetInput = {
    create?: XOR<WorksheetQuestionCreateWithoutWorksheetInput, WorksheetQuestionUncheckedCreateWithoutWorksheetInput> | WorksheetQuestionCreateWithoutWorksheetInput[] | WorksheetQuestionUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutWorksheetInput | WorksheetQuestionCreateOrConnectWithoutWorksheetInput[]
    createMany?: WorksheetQuestionCreateManyWorksheetInputEnvelope
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
  }

  export type DoubtCreateNestedManyWithoutWorksheetInput = {
    create?: XOR<DoubtCreateWithoutWorksheetInput, DoubtUncheckedCreateWithoutWorksheetInput> | DoubtCreateWithoutWorksheetInput[] | DoubtUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutWorksheetInput | DoubtCreateOrConnectWithoutWorksheetInput[]
    createMany?: DoubtCreateManyWorksheetInputEnvelope
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
  }

  export type WorksheetQuestionUncheckedCreateNestedManyWithoutWorksheetInput = {
    create?: XOR<WorksheetQuestionCreateWithoutWorksheetInput, WorksheetQuestionUncheckedCreateWithoutWorksheetInput> | WorksheetQuestionCreateWithoutWorksheetInput[] | WorksheetQuestionUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutWorksheetInput | WorksheetQuestionCreateOrConnectWithoutWorksheetInput[]
    createMany?: WorksheetQuestionCreateManyWorksheetInputEnvelope
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
  }

  export type DoubtUncheckedCreateNestedManyWithoutWorksheetInput = {
    create?: XOR<DoubtCreateWithoutWorksheetInput, DoubtUncheckedCreateWithoutWorksheetInput> | DoubtCreateWithoutWorksheetInput[] | DoubtUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutWorksheetInput | DoubtCreateOrConnectWithoutWorksheetInput[]
    createMany?: DoubtCreateManyWorksheetInputEnvelope
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutWorksheetsNestedInput = {
    create?: XOR<UserCreateWithoutWorksheetsInput, UserUncheckedCreateWithoutWorksheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorksheetsInput
    upsert?: UserUpsertWithoutWorksheetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorksheetsInput, UserUpdateWithoutWorksheetsInput>, UserUncheckedUpdateWithoutWorksheetsInput>
  }

  export type WorksheetQuestionUpdateManyWithoutWorksheetNestedInput = {
    create?: XOR<WorksheetQuestionCreateWithoutWorksheetInput, WorksheetQuestionUncheckedCreateWithoutWorksheetInput> | WorksheetQuestionCreateWithoutWorksheetInput[] | WorksheetQuestionUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutWorksheetInput | WorksheetQuestionCreateOrConnectWithoutWorksheetInput[]
    upsert?: WorksheetQuestionUpsertWithWhereUniqueWithoutWorksheetInput | WorksheetQuestionUpsertWithWhereUniqueWithoutWorksheetInput[]
    createMany?: WorksheetQuestionCreateManyWorksheetInputEnvelope
    set?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    disconnect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    delete?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    update?: WorksheetQuestionUpdateWithWhereUniqueWithoutWorksheetInput | WorksheetQuestionUpdateWithWhereUniqueWithoutWorksheetInput[]
    updateMany?: WorksheetQuestionUpdateManyWithWhereWithoutWorksheetInput | WorksheetQuestionUpdateManyWithWhereWithoutWorksheetInput[]
    deleteMany?: WorksheetQuestionScalarWhereInput | WorksheetQuestionScalarWhereInput[]
  }

  export type DoubtUpdateManyWithoutWorksheetNestedInput = {
    create?: XOR<DoubtCreateWithoutWorksheetInput, DoubtUncheckedCreateWithoutWorksheetInput> | DoubtCreateWithoutWorksheetInput[] | DoubtUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutWorksheetInput | DoubtCreateOrConnectWithoutWorksheetInput[]
    upsert?: DoubtUpsertWithWhereUniqueWithoutWorksheetInput | DoubtUpsertWithWhereUniqueWithoutWorksheetInput[]
    createMany?: DoubtCreateManyWorksheetInputEnvelope
    set?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    disconnect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    delete?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    update?: DoubtUpdateWithWhereUniqueWithoutWorksheetInput | DoubtUpdateWithWhereUniqueWithoutWorksheetInput[]
    updateMany?: DoubtUpdateManyWithWhereWithoutWorksheetInput | DoubtUpdateManyWithWhereWithoutWorksheetInput[]
    deleteMany?: DoubtScalarWhereInput | DoubtScalarWhereInput[]
  }

  export type WorksheetQuestionUncheckedUpdateManyWithoutWorksheetNestedInput = {
    create?: XOR<WorksheetQuestionCreateWithoutWorksheetInput, WorksheetQuestionUncheckedCreateWithoutWorksheetInput> | WorksheetQuestionCreateWithoutWorksheetInput[] | WorksheetQuestionUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: WorksheetQuestionCreateOrConnectWithoutWorksheetInput | WorksheetQuestionCreateOrConnectWithoutWorksheetInput[]
    upsert?: WorksheetQuestionUpsertWithWhereUniqueWithoutWorksheetInput | WorksheetQuestionUpsertWithWhereUniqueWithoutWorksheetInput[]
    createMany?: WorksheetQuestionCreateManyWorksheetInputEnvelope
    set?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    disconnect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    delete?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    connect?: WorksheetQuestionWhereUniqueInput | WorksheetQuestionWhereUniqueInput[]
    update?: WorksheetQuestionUpdateWithWhereUniqueWithoutWorksheetInput | WorksheetQuestionUpdateWithWhereUniqueWithoutWorksheetInput[]
    updateMany?: WorksheetQuestionUpdateManyWithWhereWithoutWorksheetInput | WorksheetQuestionUpdateManyWithWhereWithoutWorksheetInput[]
    deleteMany?: WorksheetQuestionScalarWhereInput | WorksheetQuestionScalarWhereInput[]
  }

  export type DoubtUncheckedUpdateManyWithoutWorksheetNestedInput = {
    create?: XOR<DoubtCreateWithoutWorksheetInput, DoubtUncheckedCreateWithoutWorksheetInput> | DoubtCreateWithoutWorksheetInput[] | DoubtUncheckedCreateWithoutWorksheetInput[]
    connectOrCreate?: DoubtCreateOrConnectWithoutWorksheetInput | DoubtCreateOrConnectWithoutWorksheetInput[]
    upsert?: DoubtUpsertWithWhereUniqueWithoutWorksheetInput | DoubtUpsertWithWhereUniqueWithoutWorksheetInput[]
    createMany?: DoubtCreateManyWorksheetInputEnvelope
    set?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    disconnect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    delete?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    connect?: DoubtWhereUniqueInput | DoubtWhereUniqueInput[]
    update?: DoubtUpdateWithWhereUniqueWithoutWorksheetInput | DoubtUpdateWithWhereUniqueWithoutWorksheetInput[]
    updateMany?: DoubtUpdateManyWithWhereWithoutWorksheetInput | DoubtUpdateManyWithWhereWithoutWorksheetInput[]
    deleteMany?: DoubtScalarWhereInput | DoubtScalarWhereInput[]
  }

  export type WorksheetCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<WorksheetCreateWithoutQuestionsInput, WorksheetUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: WorksheetCreateOrConnectWithoutQuestionsInput
    connect?: WorksheetWhereUniqueInput
  }

  export type DoubtCreateNestedOneWithoutWorksheetQuestionsInput = {
    create?: XOR<DoubtCreateWithoutWorksheetQuestionsInput, DoubtUncheckedCreateWithoutWorksheetQuestionsInput>
    connectOrCreate?: DoubtCreateOrConnectWithoutWorksheetQuestionsInput
    connect?: DoubtWhereUniqueInput
  }

  export type WorksheetUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<WorksheetCreateWithoutQuestionsInput, WorksheetUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: WorksheetCreateOrConnectWithoutQuestionsInput
    upsert?: WorksheetUpsertWithoutQuestionsInput
    connect?: WorksheetWhereUniqueInput
    update?: XOR<XOR<WorksheetUpdateToOneWithWhereWithoutQuestionsInput, WorksheetUpdateWithoutQuestionsInput>, WorksheetUncheckedUpdateWithoutQuestionsInput>
  }

  export type DoubtUpdateOneWithoutWorksheetQuestionsNestedInput = {
    create?: XOR<DoubtCreateWithoutWorksheetQuestionsInput, DoubtUncheckedCreateWithoutWorksheetQuestionsInput>
    connectOrCreate?: DoubtCreateOrConnectWithoutWorksheetQuestionsInput
    upsert?: DoubtUpsertWithoutWorksheetQuestionsInput
    disconnect?: DoubtWhereInput | boolean
    delete?: DoubtWhereInput | boolean
    connect?: DoubtWhereUniqueInput
    update?: XOR<XOR<DoubtUpdateToOneWithWhereWithoutWorksheetQuestionsInput, DoubtUpdateWithoutWorksheetQuestionsInput>, DoubtUncheckedUpdateWithoutWorksheetQuestionsInput>
  }

  export type DoubtCreateNestedOneWithoutRatingInput = {
    create?: XOR<DoubtCreateWithoutRatingInput, DoubtUncheckedCreateWithoutRatingInput>
    connectOrCreate?: DoubtCreateOrConnectWithoutRatingInput
    connect?: DoubtWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoubtRatingsInput = {
    create?: XOR<UserCreateWithoutDoubtRatingsInput, UserUncheckedCreateWithoutDoubtRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoubtRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type DoubtUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<DoubtCreateWithoutRatingInput, DoubtUncheckedCreateWithoutRatingInput>
    connectOrCreate?: DoubtCreateOrConnectWithoutRatingInput
    upsert?: DoubtUpsertWithoutRatingInput
    connect?: DoubtWhereUniqueInput
    update?: XOR<XOR<DoubtUpdateToOneWithWhereWithoutRatingInput, DoubtUpdateWithoutRatingInput>, DoubtUncheckedUpdateWithoutRatingInput>
  }

  export type UserUpdateOneRequiredWithoutDoubtRatingsNestedInput = {
    create?: XOR<UserCreateWithoutDoubtRatingsInput, UserUncheckedCreateWithoutDoubtRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoubtRatingsInput
    upsert?: UserUpsertWithoutDoubtRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoubtRatingsInput, UserUpdateWithoutDoubtRatingsInput>, UserUncheckedUpdateWithoutDoubtRatingsInput>
  }

  export type UserCreateNestedOneWithoutRevisionSessionsInput = {
    create?: XOR<UserCreateWithoutRevisionSessionsInput, UserUncheckedCreateWithoutRevisionSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevisionSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutRevisionSessionsNestedInput = {
    create?: XOR<UserCreateWithoutRevisionSessionsInput, UserUncheckedCreateWithoutRevisionSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevisionSessionsInput
    upsert?: UserUpsertWithoutRevisionSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRevisionSessionsInput, UserUpdateWithoutRevisionSessionsInput>, UserUncheckedUpdateWithoutRevisionSessionsInput>
  }

  export type UserCreateNestedOneWithoutWeakTopicsInput = {
    create?: XOR<UserCreateWithoutWeakTopicsInput, UserUncheckedCreateWithoutWeakTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeakTopicsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutWeakTopicsNestedInput = {
    create?: XOR<UserCreateWithoutWeakTopicsInput, UserUncheckedCreateWithoutWeakTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeakTopicsInput
    upsert?: UserUpsertWithoutWeakTopicsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWeakTopicsInput, UserUpdateWithoutWeakTopicsInput>, UserUncheckedUpdateWithoutWeakTopicsInput>
  }

  export type UserCreateNestedOneWithoutGroupStudySessionsInput = {
    create?: XOR<UserCreateWithoutGroupStudySessionsInput, UserUncheckedCreateWithoutGroupStudySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupStudySessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutGroupStudySessionsNestedInput = {
    create?: XOR<UserCreateWithoutGroupStudySessionsInput, UserUncheckedCreateWithoutGroupStudySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupStudySessionsInput
    upsert?: UserUpsertWithoutGroupStudySessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupStudySessionsInput, UserUpdateWithoutGroupStudySessionsInput>, UserUncheckedUpdateWithoutGroupStudySessionsInput>
  }

  export type UserCreateNestedOneWithoutHandlingSkillProgressInput = {
    create?: XOR<UserCreateWithoutHandlingSkillProgressInput, UserUncheckedCreateWithoutHandlingSkillProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutHandlingSkillProgressInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutHandlingSkillProgressNestedInput = {
    create?: XOR<UserCreateWithoutHandlingSkillProgressInput, UserUncheckedCreateWithoutHandlingSkillProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutHandlingSkillProgressInput
    upsert?: UserUpsertWithoutHandlingSkillProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHandlingSkillProgressInput, UserUpdateWithoutHandlingSkillProgressInput>, UserUncheckedUpdateWithoutHandlingSkillProgressInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type QuestionCreateWithoutQuestionPaperInput = {
    id?: string
    questionNumber: string
    questionText: string
    maxScore?: number | null
    topic?: string | null
    concept?: string | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type QuestionUncheckedCreateWithoutQuestionPaperInput = {
    id?: string
    questionNumber: string
    questionText: string
    maxScore?: number | null
    topic?: string | null
    concept?: string | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type QuestionCreateOrConnectWithoutQuestionPaperInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutQuestionPaperInput, QuestionUncheckedCreateWithoutQuestionPaperInput>
  }

  export type QuestionCreateManyQuestionPaperInputEnvelope = {
    data: QuestionCreateManyQuestionPaperInput | QuestionCreateManyQuestionPaperInput[]
    skipDuplicates?: boolean
  }

  export type GradingCreateWithoutQuestionPaperInput = {
    id?: string
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGradingsInput
    pages?: GradingPageCreateNestedManyWithoutGradingInput
    answers?: AnswerCreateNestedManyWithoutGradingInput
  }

  export type GradingUncheckedCreateWithoutQuestionPaperInput = {
    id?: string
    userId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    pages?: GradingPageUncheckedCreateNestedManyWithoutGradingInput
    answers?: AnswerUncheckedCreateNestedManyWithoutGradingInput
  }

  export type GradingCreateOrConnectWithoutQuestionPaperInput = {
    where: GradingWhereUniqueInput
    create: XOR<GradingCreateWithoutQuestionPaperInput, GradingUncheckedCreateWithoutQuestionPaperInput>
  }

  export type GradingCreateManyQuestionPaperInputEnvelope = {
    data: GradingCreateManyQuestionPaperInput | GradingCreateManyQuestionPaperInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithWhereUniqueWithoutQuestionPaperInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutQuestionPaperInput, QuestionUncheckedUpdateWithoutQuestionPaperInput>
    create: XOR<QuestionCreateWithoutQuestionPaperInput, QuestionUncheckedCreateWithoutQuestionPaperInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutQuestionPaperInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutQuestionPaperInput, QuestionUncheckedUpdateWithoutQuestionPaperInput>
  }

  export type QuestionUpdateManyWithWhereWithoutQuestionPaperInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutQuestionPaperInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    questionPaperId?: StringFilter<"Question"> | string
    questionNumber?: StringFilter<"Question"> | string
    questionText?: StringFilter<"Question"> | string
    maxScore?: FloatNullableFilter<"Question"> | number | null
    topic?: StringNullableFilter<"Question"> | string | null
    concept?: StringNullableFilter<"Question"> | string | null
    positionX?: FloatNullableFilter<"Question"> | number | null
    positionY?: FloatNullableFilter<"Question"> | number | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
  }

  export type GradingUpsertWithWhereUniqueWithoutQuestionPaperInput = {
    where: GradingWhereUniqueInput
    update: XOR<GradingUpdateWithoutQuestionPaperInput, GradingUncheckedUpdateWithoutQuestionPaperInput>
    create: XOR<GradingCreateWithoutQuestionPaperInput, GradingUncheckedCreateWithoutQuestionPaperInput>
  }

  export type GradingUpdateWithWhereUniqueWithoutQuestionPaperInput = {
    where: GradingWhereUniqueInput
    data: XOR<GradingUpdateWithoutQuestionPaperInput, GradingUncheckedUpdateWithoutQuestionPaperInput>
  }

  export type GradingUpdateManyWithWhereWithoutQuestionPaperInput = {
    where: GradingScalarWhereInput
    data: XOR<GradingUpdateManyMutationInput, GradingUncheckedUpdateManyWithoutQuestionPaperInput>
  }

  export type GradingScalarWhereInput = {
    AND?: GradingScalarWhereInput | GradingScalarWhereInput[]
    OR?: GradingScalarWhereInput[]
    NOT?: GradingScalarWhereInput | GradingScalarWhereInput[]
    id?: StringFilter<"Grading"> | string
    userId?: StringNullableFilter<"Grading"> | string | null
    questionPaperId?: StringNullableFilter<"Grading"> | string | null
    answerSheetUrl?: StringFilter<"Grading"> | string
    totalPages?: IntFilter<"Grading"> | number
    subject?: StringFilter<"Grading"> | string
    language?: StringFilter<"Grading"> | string
    gradeLevel?: StringFilter<"Grading"> | string
    totalScore?: StringFilter<"Grading"> | string
    feedback?: StringFilter<"Grading"> | string
    matchingMode?: StringNullableFilter<"Grading"> | string | null
    totalQuestions?: IntNullableFilter<"Grading"> | number | null
    answeredQuestions?: IntNullableFilter<"Grading"> | number | null
    annotations?: StringNullableFilter<"Grading"> | string | null
    imageDimensions?: StringNullableFilter<"Grading"> | string | null
    createdAt?: DateTimeFilter<"Grading"> | Date | string
  }

  export type QuestionPaperCreateWithoutQuestionsInput = {
    id?: string
    title?: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageCount?: number
    gradings?: GradingCreateNestedManyWithoutQuestionPaperInput
  }

  export type QuestionPaperUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title?: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageCount?: number
    gradings?: GradingUncheckedCreateNestedManyWithoutQuestionPaperInput
  }

  export type QuestionPaperCreateOrConnectWithoutQuestionsInput = {
    where: QuestionPaperWhereUniqueInput
    create: XOR<QuestionPaperCreateWithoutQuestionsInput, QuestionPaperUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionPaperUpsertWithoutQuestionsInput = {
    update: XOR<QuestionPaperUpdateWithoutQuestionsInput, QuestionPaperUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuestionPaperCreateWithoutQuestionsInput, QuestionPaperUncheckedCreateWithoutQuestionsInput>
    where?: QuestionPaperWhereInput
  }

  export type QuestionPaperUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuestionPaperWhereInput
    data: XOR<QuestionPaperUpdateWithoutQuestionsInput, QuestionPaperUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionPaperUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
    gradings?: GradingUpdateManyWithoutQuestionPaperNestedInput
  }

  export type QuestionPaperUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
    gradings?: GradingUncheckedUpdateManyWithoutQuestionPaperNestedInput
  }

  export type GradingCreateWithoutUserInput = {
    id?: string
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    questionPaper?: QuestionPaperCreateNestedOneWithoutGradingsInput
    pages?: GradingPageCreateNestedManyWithoutGradingInput
    answers?: AnswerCreateNestedManyWithoutGradingInput
  }

  export type GradingUncheckedCreateWithoutUserInput = {
    id?: string
    questionPaperId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    pages?: GradingPageUncheckedCreateNestedManyWithoutGradingInput
    answers?: AnswerUncheckedCreateNestedManyWithoutGradingInput
  }

  export type GradingCreateOrConnectWithoutUserInput = {
    where: GradingWhereUniqueInput
    create: XOR<GradingCreateWithoutUserInput, GradingUncheckedCreateWithoutUserInput>
  }

  export type GradingCreateManyUserInputEnvelope = {
    data: GradingCreateManyUserInput | GradingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DoubtCreateWithoutUserInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DoubtMessageCreateNestedManyWithoutDoubtInput
    worksheet?: WorksheetCreateNestedOneWithoutDoubtsInput
    worksheetQuestions?: WorksheetQuestionCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingCreateNestedOneWithoutDoubtInput
  }

  export type DoubtUncheckedCreateWithoutUserInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    worksheetId?: string | null
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DoubtMessageUncheckedCreateNestedManyWithoutDoubtInput
    worksheetQuestions?: WorksheetQuestionUncheckedCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingUncheckedCreateNestedOneWithoutDoubtInput
  }

  export type DoubtCreateOrConnectWithoutUserInput = {
    where: DoubtWhereUniqueInput
    create: XOR<DoubtCreateWithoutUserInput, DoubtUncheckedCreateWithoutUserInput>
  }

  export type DoubtCreateManyUserInputEnvelope = {
    data: DoubtCreateManyUserInput | DoubtCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorksheetCreateWithoutUserInput = {
    id?: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: WorksheetQuestionCreateNestedManyWithoutWorksheetInput
    doubts?: DoubtCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetUncheckedCreateWithoutUserInput = {
    id?: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: WorksheetQuestionUncheckedCreateNestedManyWithoutWorksheetInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetCreateOrConnectWithoutUserInput = {
    where: WorksheetWhereUniqueInput
    create: XOR<WorksheetCreateWithoutUserInput, WorksheetUncheckedCreateWithoutUserInput>
  }

  export type WorksheetCreateManyUserInputEnvelope = {
    data: WorksheetCreateManyUserInput | WorksheetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DoubtRatingCreateWithoutUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doubt: DoubtCreateNestedOneWithoutRatingInput
  }

  export type DoubtRatingUncheckedCreateWithoutUserInput = {
    id?: string
    doubtId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoubtRatingCreateOrConnectWithoutUserInput = {
    where: DoubtRatingWhereUniqueInput
    create: XOR<DoubtRatingCreateWithoutUserInput, DoubtRatingUncheckedCreateWithoutUserInput>
  }

  export type DoubtRatingCreateManyUserInputEnvelope = {
    data: DoubtRatingCreateManyUserInput | DoubtRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RevisionSessionCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number | null
    weakAreas?: string | null
    phasesCompleted?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevisionSessionUncheckedCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number | null
    weakAreas?: string | null
    phasesCompleted?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevisionSessionCreateOrConnectWithoutUserInput = {
    where: RevisionSessionWhereUniqueInput
    create: XOR<RevisionSessionCreateWithoutUserInput, RevisionSessionUncheckedCreateWithoutUserInput>
  }

  export type RevisionSessionCreateManyUserInputEnvelope = {
    data: RevisionSessionCreateManyUserInput | RevisionSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WeakTopicCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    occurrences?: number
    lastSeen?: Date | string
    improved?: boolean
    improvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeakTopicUncheckedCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    occurrences?: number
    lastSeen?: Date | string
    improved?: boolean
    improvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeakTopicCreateOrConnectWithoutUserInput = {
    where: WeakTopicWhereUniqueInput
    create: XOR<WeakTopicCreateWithoutUserInput, WeakTopicUncheckedCreateWithoutUserInput>
  }

  export type WeakTopicCreateManyUserInputEnvelope = {
    data: WeakTopicCreateManyUserInput | WeakTopicCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupStudySessionCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    question?: string | null
    classmate1Name: string
    classmate2Name: string
    studentAnswer: string
    classmate1Question?: string | null
    classmate2Counter?: string | null
    classmate1Response?: string | null
    classmate2Response?: string | null
    handlingScore?: number | null
    strengths?: string | null
    improvements?: string | null
    challengesCount?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupStudySessionUncheckedCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    question?: string | null
    classmate1Name: string
    classmate2Name: string
    studentAnswer: string
    classmate1Question?: string | null
    classmate2Counter?: string | null
    classmate1Response?: string | null
    classmate2Response?: string | null
    handlingScore?: number | null
    strengths?: string | null
    improvements?: string | null
    challengesCount?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupStudySessionCreateOrConnectWithoutUserInput = {
    where: GroupStudySessionWhereUniqueInput
    create: XOR<GroupStudySessionCreateWithoutUserInput, GroupStudySessionUncheckedCreateWithoutUserInput>
  }

  export type GroupStudySessionCreateManyUserInputEnvelope = {
    data: GroupStudySessionCreateManyUserInput | GroupStudySessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HandlingSkillProgressCreateWithoutUserInput = {
    id?: string
    currentLevel?: string
    avgScore?: number
    sessionsCount?: number
    badges?: string
    lastSession?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandlingSkillProgressUncheckedCreateWithoutUserInput = {
    id?: string
    currentLevel?: string
    avgScore?: number
    sessionsCount?: number
    badges?: string
    lastSession?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandlingSkillProgressCreateOrConnectWithoutUserInput = {
    where: HandlingSkillProgressWhereUniqueInput
    create: XOR<HandlingSkillProgressCreateWithoutUserInput, HandlingSkillProgressUncheckedCreateWithoutUserInput>
  }

  export type GradingUpsertWithWhereUniqueWithoutUserInput = {
    where: GradingWhereUniqueInput
    update: XOR<GradingUpdateWithoutUserInput, GradingUncheckedUpdateWithoutUserInput>
    create: XOR<GradingCreateWithoutUserInput, GradingUncheckedCreateWithoutUserInput>
  }

  export type GradingUpdateWithWhereUniqueWithoutUserInput = {
    where: GradingWhereUniqueInput
    data: XOR<GradingUpdateWithoutUserInput, GradingUncheckedUpdateWithoutUserInput>
  }

  export type GradingUpdateManyWithWhereWithoutUserInput = {
    where: GradingScalarWhereInput
    data: XOR<GradingUpdateManyMutationInput, GradingUncheckedUpdateManyWithoutUserInput>
  }

  export type DoubtUpsertWithWhereUniqueWithoutUserInput = {
    where: DoubtWhereUniqueInput
    update: XOR<DoubtUpdateWithoutUserInput, DoubtUncheckedUpdateWithoutUserInput>
    create: XOR<DoubtCreateWithoutUserInput, DoubtUncheckedCreateWithoutUserInput>
  }

  export type DoubtUpdateWithWhereUniqueWithoutUserInput = {
    where: DoubtWhereUniqueInput
    data: XOR<DoubtUpdateWithoutUserInput, DoubtUncheckedUpdateWithoutUserInput>
  }

  export type DoubtUpdateManyWithWhereWithoutUserInput = {
    where: DoubtScalarWhereInput
    data: XOR<DoubtUpdateManyMutationInput, DoubtUncheckedUpdateManyWithoutUserInput>
  }

  export type DoubtScalarWhereInput = {
    AND?: DoubtScalarWhereInput | DoubtScalarWhereInput[]
    OR?: DoubtScalarWhereInput[]
    NOT?: DoubtScalarWhereInput | DoubtScalarWhereInput[]
    id?: StringFilter<"Doubt"> | string
    userId?: StringNullableFilter<"Doubt"> | string | null
    questionImage?: StringNullableFilter<"Doubt"> | string | null
    questionText?: StringFilter<"Doubt"> | string
    subject?: StringFilter<"Doubt"> | string
    language?: StringFilter<"Doubt"> | string
    explanation?: StringFilter<"Doubt"> | string
    annotations?: StringNullableFilter<"Doubt"> | string | null
    imageDimensions?: StringNullableFilter<"Doubt"> | string | null
    conversationId?: StringFilter<"Doubt"> | string
    worksheetId?: StringNullableFilter<"Doubt"> | string | null
    questionNumber?: IntNullableFilter<"Doubt"> | number | null
    isInRevision?: BoolFilter<"Doubt"> | boolean
    addedToRevisionAt?: DateTimeNullableFilter<"Doubt"> | Date | string | null
    isFavorite?: BoolFilter<"Doubt"> | boolean
    messageCount?: IntFilter<"Doubt"> | number
    createdAt?: DateTimeFilter<"Doubt"> | Date | string
    updatedAt?: DateTimeFilter<"Doubt"> | Date | string
  }

  export type WorksheetUpsertWithWhereUniqueWithoutUserInput = {
    where: WorksheetWhereUniqueInput
    update: XOR<WorksheetUpdateWithoutUserInput, WorksheetUncheckedUpdateWithoutUserInput>
    create: XOR<WorksheetCreateWithoutUserInput, WorksheetUncheckedCreateWithoutUserInput>
  }

  export type WorksheetUpdateWithWhereUniqueWithoutUserInput = {
    where: WorksheetWhereUniqueInput
    data: XOR<WorksheetUpdateWithoutUserInput, WorksheetUncheckedUpdateWithoutUserInput>
  }

  export type WorksheetUpdateManyWithWhereWithoutUserInput = {
    where: WorksheetScalarWhereInput
    data: XOR<WorksheetUpdateManyMutationInput, WorksheetUncheckedUpdateManyWithoutUserInput>
  }

  export type WorksheetScalarWhereInput = {
    AND?: WorksheetScalarWhereInput | WorksheetScalarWhereInput[]
    OR?: WorksheetScalarWhereInput[]
    NOT?: WorksheetScalarWhereInput | WorksheetScalarWhereInput[]
    id?: StringFilter<"Worksheet"> | string
    userId?: StringNullableFilter<"Worksheet"> | string | null
    imageUrl?: StringFilter<"Worksheet"> | string
    imageHash?: StringFilter<"Worksheet"> | string
    totalQuestions?: IntFilter<"Worksheet"> | number
    currentQuestion?: IntFilter<"Worksheet"> | number
    sessionId?: StringFilter<"Worksheet"> | string
    expiresAt?: DateTimeFilter<"Worksheet"> | Date | string
    title?: StringNullableFilter<"Worksheet"> | string | null
    subject?: StringNullableFilter<"Worksheet"> | string | null
    createdAt?: DateTimeFilter<"Worksheet"> | Date | string
    updatedAt?: DateTimeFilter<"Worksheet"> | Date | string
  }

  export type DoubtRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: DoubtRatingWhereUniqueInput
    update: XOR<DoubtRatingUpdateWithoutUserInput, DoubtRatingUncheckedUpdateWithoutUserInput>
    create: XOR<DoubtRatingCreateWithoutUserInput, DoubtRatingUncheckedCreateWithoutUserInput>
  }

  export type DoubtRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: DoubtRatingWhereUniqueInput
    data: XOR<DoubtRatingUpdateWithoutUserInput, DoubtRatingUncheckedUpdateWithoutUserInput>
  }

  export type DoubtRatingUpdateManyWithWhereWithoutUserInput = {
    where: DoubtRatingScalarWhereInput
    data: XOR<DoubtRatingUpdateManyMutationInput, DoubtRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type DoubtRatingScalarWhereInput = {
    AND?: DoubtRatingScalarWhereInput | DoubtRatingScalarWhereInput[]
    OR?: DoubtRatingScalarWhereInput[]
    NOT?: DoubtRatingScalarWhereInput | DoubtRatingScalarWhereInput[]
    id?: StringFilter<"DoubtRating"> | string
    doubtId?: StringFilter<"DoubtRating"> | string
    userId?: StringFilter<"DoubtRating"> | string
    rating?: IntFilter<"DoubtRating"> | number
    feedback?: StringNullableFilter<"DoubtRating"> | string | null
    createdAt?: DateTimeFilter<"DoubtRating"> | Date | string
    updatedAt?: DateTimeFilter<"DoubtRating"> | Date | string
  }

  export type RevisionSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: RevisionSessionWhereUniqueInput
    update: XOR<RevisionSessionUpdateWithoutUserInput, RevisionSessionUncheckedUpdateWithoutUserInput>
    create: XOR<RevisionSessionCreateWithoutUserInput, RevisionSessionUncheckedCreateWithoutUserInput>
  }

  export type RevisionSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: RevisionSessionWhereUniqueInput
    data: XOR<RevisionSessionUpdateWithoutUserInput, RevisionSessionUncheckedUpdateWithoutUserInput>
  }

  export type RevisionSessionUpdateManyWithWhereWithoutUserInput = {
    where: RevisionSessionScalarWhereInput
    data: XOR<RevisionSessionUpdateManyMutationInput, RevisionSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type RevisionSessionScalarWhereInput = {
    AND?: RevisionSessionScalarWhereInput | RevisionSessionScalarWhereInput[]
    OR?: RevisionSessionScalarWhereInput[]
    NOT?: RevisionSessionScalarWhereInput | RevisionSessionScalarWhereInput[]
    id?: StringFilter<"RevisionSession"> | string
    userId?: StringNullableFilter<"RevisionSession"> | string | null
    topic?: StringFilter<"RevisionSession"> | string
    subject?: StringFilter<"RevisionSession"> | string
    startedAt?: DateTimeFilter<"RevisionSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"RevisionSession"> | Date | string | null
    score?: IntNullableFilter<"RevisionSession"> | number | null
    weakAreas?: StringNullableFilter<"RevisionSession"> | string | null
    phasesCompleted?: StringNullableFilter<"RevisionSession"> | string | null
    createdAt?: DateTimeFilter<"RevisionSession"> | Date | string
    updatedAt?: DateTimeFilter<"RevisionSession"> | Date | string
  }

  export type WeakTopicUpsertWithWhereUniqueWithoutUserInput = {
    where: WeakTopicWhereUniqueInput
    update: XOR<WeakTopicUpdateWithoutUserInput, WeakTopicUncheckedUpdateWithoutUserInput>
    create: XOR<WeakTopicCreateWithoutUserInput, WeakTopicUncheckedCreateWithoutUserInput>
  }

  export type WeakTopicUpdateWithWhereUniqueWithoutUserInput = {
    where: WeakTopicWhereUniqueInput
    data: XOR<WeakTopicUpdateWithoutUserInput, WeakTopicUncheckedUpdateWithoutUserInput>
  }

  export type WeakTopicUpdateManyWithWhereWithoutUserInput = {
    where: WeakTopicScalarWhereInput
    data: XOR<WeakTopicUpdateManyMutationInput, WeakTopicUncheckedUpdateManyWithoutUserInput>
  }

  export type WeakTopicScalarWhereInput = {
    AND?: WeakTopicScalarWhereInput | WeakTopicScalarWhereInput[]
    OR?: WeakTopicScalarWhereInput[]
    NOT?: WeakTopicScalarWhereInput | WeakTopicScalarWhereInput[]
    id?: StringFilter<"WeakTopic"> | string
    userId?: StringNullableFilter<"WeakTopic"> | string | null
    topic?: StringFilter<"WeakTopic"> | string
    subject?: StringFilter<"WeakTopic"> | string
    occurrences?: IntFilter<"WeakTopic"> | number
    lastSeen?: DateTimeFilter<"WeakTopic"> | Date | string
    improved?: BoolFilter<"WeakTopic"> | boolean
    improvedAt?: DateTimeNullableFilter<"WeakTopic"> | Date | string | null
    createdAt?: DateTimeFilter<"WeakTopic"> | Date | string
    updatedAt?: DateTimeFilter<"WeakTopic"> | Date | string
  }

  export type GroupStudySessionUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupStudySessionWhereUniqueInput
    update: XOR<GroupStudySessionUpdateWithoutUserInput, GroupStudySessionUncheckedUpdateWithoutUserInput>
    create: XOR<GroupStudySessionCreateWithoutUserInput, GroupStudySessionUncheckedCreateWithoutUserInput>
  }

  export type GroupStudySessionUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupStudySessionWhereUniqueInput
    data: XOR<GroupStudySessionUpdateWithoutUserInput, GroupStudySessionUncheckedUpdateWithoutUserInput>
  }

  export type GroupStudySessionUpdateManyWithWhereWithoutUserInput = {
    where: GroupStudySessionScalarWhereInput
    data: XOR<GroupStudySessionUpdateManyMutationInput, GroupStudySessionUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupStudySessionScalarWhereInput = {
    AND?: GroupStudySessionScalarWhereInput | GroupStudySessionScalarWhereInput[]
    OR?: GroupStudySessionScalarWhereInput[]
    NOT?: GroupStudySessionScalarWhereInput | GroupStudySessionScalarWhereInput[]
    id?: StringFilter<"GroupStudySession"> | string
    userId?: StringNullableFilter<"GroupStudySession"> | string | null
    topic?: StringFilter<"GroupStudySession"> | string
    subject?: StringFilter<"GroupStudySession"> | string
    question?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate1Name?: StringFilter<"GroupStudySession"> | string
    classmate2Name?: StringFilter<"GroupStudySession"> | string
    studentAnswer?: StringFilter<"GroupStudySession"> | string
    classmate1Question?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate2Counter?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate1Response?: StringNullableFilter<"GroupStudySession"> | string | null
    classmate2Response?: StringNullableFilter<"GroupStudySession"> | string | null
    handlingScore?: IntNullableFilter<"GroupStudySession"> | number | null
    strengths?: StringNullableFilter<"GroupStudySession"> | string | null
    improvements?: StringNullableFilter<"GroupStudySession"> | string | null
    challengesCount?: IntFilter<"GroupStudySession"> | number
    startedAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"GroupStudySession"> | Date | string | null
    createdAt?: DateTimeFilter<"GroupStudySession"> | Date | string
    updatedAt?: DateTimeFilter<"GroupStudySession"> | Date | string
  }

  export type HandlingSkillProgressUpsertWithoutUserInput = {
    update: XOR<HandlingSkillProgressUpdateWithoutUserInput, HandlingSkillProgressUncheckedUpdateWithoutUserInput>
    create: XOR<HandlingSkillProgressCreateWithoutUserInput, HandlingSkillProgressUncheckedCreateWithoutUserInput>
    where?: HandlingSkillProgressWhereInput
  }

  export type HandlingSkillProgressUpdateToOneWithWhereWithoutUserInput = {
    where?: HandlingSkillProgressWhereInput
    data: XOR<HandlingSkillProgressUpdateWithoutUserInput, HandlingSkillProgressUncheckedUpdateWithoutUserInput>
  }

  export type HandlingSkillProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: StringFieldUpdateOperationsInput | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sessionsCount?: IntFieldUpdateOperationsInput | number
    badges?: StringFieldUpdateOperationsInput | string
    lastSession?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandlingSkillProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: StringFieldUpdateOperationsInput | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sessionsCount?: IntFieldUpdateOperationsInput | number
    badges?: StringFieldUpdateOperationsInput | string
    lastSession?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutGradingsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    doubts?: DoubtCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGradingsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGradingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGradingsInput, UserUncheckedCreateWithoutGradingsInput>
  }

  export type QuestionPaperCreateWithoutGradingsInput = {
    id?: string
    title?: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageCount?: number
    questions?: QuestionCreateNestedManyWithoutQuestionPaperInput
  }

  export type QuestionPaperUncheckedCreateWithoutGradingsInput = {
    id?: string
    title?: string | null
    subject: string
    gradeLevel: string
    language: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageCount?: number
    questions?: QuestionUncheckedCreateNestedManyWithoutQuestionPaperInput
  }

  export type QuestionPaperCreateOrConnectWithoutGradingsInput = {
    where: QuestionPaperWhereUniqueInput
    create: XOR<QuestionPaperCreateWithoutGradingsInput, QuestionPaperUncheckedCreateWithoutGradingsInput>
  }

  export type GradingPageCreateWithoutGradingInput = {
    id?: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    pageAnswers?: PageAnswerCreateNestedManyWithoutPageInput
  }

  export type GradingPageUncheckedCreateWithoutGradingInput = {
    id?: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    pageAnswers?: PageAnswerUncheckedCreateNestedManyWithoutPageInput
  }

  export type GradingPageCreateOrConnectWithoutGradingInput = {
    where: GradingPageWhereUniqueInput
    create: XOR<GradingPageCreateWithoutGradingInput, GradingPageUncheckedCreateWithoutGradingInput>
  }

  export type GradingPageCreateManyGradingInputEnvelope = {
    data: GradingPageCreateManyGradingInput | GradingPageCreateManyGradingInput[]
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutGradingInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type AnswerUncheckedCreateWithoutGradingInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type AnswerCreateOrConnectWithoutGradingInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutGradingInput, AnswerUncheckedCreateWithoutGradingInput>
  }

  export type AnswerCreateManyGradingInputEnvelope = {
    data: AnswerCreateManyGradingInput | AnswerCreateManyGradingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGradingsInput = {
    update: XOR<UserUpdateWithoutGradingsInput, UserUncheckedUpdateWithoutGradingsInput>
    create: XOR<UserCreateWithoutGradingsInput, UserUncheckedCreateWithoutGradingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGradingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGradingsInput, UserUncheckedUpdateWithoutGradingsInput>
  }

  export type UserUpdateWithoutGradingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGradingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type QuestionPaperUpsertWithoutGradingsInput = {
    update: XOR<QuestionPaperUpdateWithoutGradingsInput, QuestionPaperUncheckedUpdateWithoutGradingsInput>
    create: XOR<QuestionPaperCreateWithoutGradingsInput, QuestionPaperUncheckedCreateWithoutGradingsInput>
    where?: QuestionPaperWhereInput
  }

  export type QuestionPaperUpdateToOneWithWhereWithoutGradingsInput = {
    where?: QuestionPaperWhereInput
    data: XOR<QuestionPaperUpdateWithoutGradingsInput, QuestionPaperUncheckedUpdateWithoutGradingsInput>
  }

  export type QuestionPaperUpdateWithoutGradingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
    questions?: QuestionUpdateManyWithoutQuestionPaperNestedInput
  }

  export type QuestionPaperUncheckedUpdateWithoutGradingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageCount?: IntFieldUpdateOperationsInput | number
    questions?: QuestionUncheckedUpdateManyWithoutQuestionPaperNestedInput
  }

  export type GradingPageUpsertWithWhereUniqueWithoutGradingInput = {
    where: GradingPageWhereUniqueInput
    update: XOR<GradingPageUpdateWithoutGradingInput, GradingPageUncheckedUpdateWithoutGradingInput>
    create: XOR<GradingPageCreateWithoutGradingInput, GradingPageUncheckedCreateWithoutGradingInput>
  }

  export type GradingPageUpdateWithWhereUniqueWithoutGradingInput = {
    where: GradingPageWhereUniqueInput
    data: XOR<GradingPageUpdateWithoutGradingInput, GradingPageUncheckedUpdateWithoutGradingInput>
  }

  export type GradingPageUpdateManyWithWhereWithoutGradingInput = {
    where: GradingPageScalarWhereInput
    data: XOR<GradingPageUpdateManyMutationInput, GradingPageUncheckedUpdateManyWithoutGradingInput>
  }

  export type GradingPageScalarWhereInput = {
    AND?: GradingPageScalarWhereInput | GradingPageScalarWhereInput[]
    OR?: GradingPageScalarWhereInput[]
    NOT?: GradingPageScalarWhereInput | GradingPageScalarWhereInput[]
    id?: StringFilter<"GradingPage"> | string
    gradingId?: StringFilter<"GradingPage"> | string
    pageNumber?: IntFilter<"GradingPage"> | number
    imageUrl?: StringFilter<"GradingPage"> | string
    annotations?: StringNullableFilter<"GradingPage"> | string | null
    imageDimensions?: StringNullableFilter<"GradingPage"> | string | null
    createdAt?: DateTimeFilter<"GradingPage"> | Date | string
  }

  export type AnswerUpsertWithWhereUniqueWithoutGradingInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutGradingInput, AnswerUncheckedUpdateWithoutGradingInput>
    create: XOR<AnswerCreateWithoutGradingInput, AnswerUncheckedCreateWithoutGradingInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutGradingInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutGradingInput, AnswerUncheckedUpdateWithoutGradingInput>
  }

  export type AnswerUpdateManyWithWhereWithoutGradingInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutGradingInput>
  }

  export type AnswerScalarWhereInput = {
    AND?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    OR?: AnswerScalarWhereInput[]
    NOT?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    id?: StringFilter<"Answer"> | string
    gradingId?: StringFilter<"Answer"> | string
    questionNumber?: StringFilter<"Answer"> | string
    studentAnswer?: StringNullableFilter<"Answer"> | string | null
    correct?: BoolFilter<"Answer"> | boolean
    score?: StringFilter<"Answer"> | string
    remarks?: StringFilter<"Answer"> | string
    matched?: BoolFilter<"Answer"> | boolean
    matchConfidence?: FloatNullableFilter<"Answer"> | number | null
    positionX?: FloatNullableFilter<"Answer"> | number | null
    positionY?: FloatNullableFilter<"Answer"> | number | null
    createdAt?: DateTimeFilter<"Answer"> | Date | string
  }

  export type GradingCreateWithoutPagesInput = {
    id?: string
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGradingsInput
    questionPaper?: QuestionPaperCreateNestedOneWithoutGradingsInput
    answers?: AnswerCreateNestedManyWithoutGradingInput
  }

  export type GradingUncheckedCreateWithoutPagesInput = {
    id?: string
    userId?: string | null
    questionPaperId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutGradingInput
  }

  export type GradingCreateOrConnectWithoutPagesInput = {
    where: GradingWhereUniqueInput
    create: XOR<GradingCreateWithoutPagesInput, GradingUncheckedCreateWithoutPagesInput>
  }

  export type PageAnswerCreateWithoutPageInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    continuedFrom?: number | null
    continuedTo?: number | null
    createdAt?: Date | string
  }

  export type PageAnswerUncheckedCreateWithoutPageInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    continuedFrom?: number | null
    continuedTo?: number | null
    createdAt?: Date | string
  }

  export type PageAnswerCreateOrConnectWithoutPageInput = {
    where: PageAnswerWhereUniqueInput
    create: XOR<PageAnswerCreateWithoutPageInput, PageAnswerUncheckedCreateWithoutPageInput>
  }

  export type PageAnswerCreateManyPageInputEnvelope = {
    data: PageAnswerCreateManyPageInput | PageAnswerCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type GradingUpsertWithoutPagesInput = {
    update: XOR<GradingUpdateWithoutPagesInput, GradingUncheckedUpdateWithoutPagesInput>
    create: XOR<GradingCreateWithoutPagesInput, GradingUncheckedCreateWithoutPagesInput>
    where?: GradingWhereInput
  }

  export type GradingUpdateToOneWithWhereWithoutPagesInput = {
    where?: GradingWhereInput
    data: XOR<GradingUpdateWithoutPagesInput, GradingUncheckedUpdateWithoutPagesInput>
  }

  export type GradingUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGradingsNestedInput
    questionPaper?: QuestionPaperUpdateOneWithoutGradingsNestedInput
    answers?: AnswerUpdateManyWithoutGradingNestedInput
  }

  export type GradingUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionPaperId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutGradingNestedInput
  }

  export type PageAnswerUpsertWithWhereUniqueWithoutPageInput = {
    where: PageAnswerWhereUniqueInput
    update: XOR<PageAnswerUpdateWithoutPageInput, PageAnswerUncheckedUpdateWithoutPageInput>
    create: XOR<PageAnswerCreateWithoutPageInput, PageAnswerUncheckedCreateWithoutPageInput>
  }

  export type PageAnswerUpdateWithWhereUniqueWithoutPageInput = {
    where: PageAnswerWhereUniqueInput
    data: XOR<PageAnswerUpdateWithoutPageInput, PageAnswerUncheckedUpdateWithoutPageInput>
  }

  export type PageAnswerUpdateManyWithWhereWithoutPageInput = {
    where: PageAnswerScalarWhereInput
    data: XOR<PageAnswerUpdateManyMutationInput, PageAnswerUncheckedUpdateManyWithoutPageInput>
  }

  export type PageAnswerScalarWhereInput = {
    AND?: PageAnswerScalarWhereInput | PageAnswerScalarWhereInput[]
    OR?: PageAnswerScalarWhereInput[]
    NOT?: PageAnswerScalarWhereInput | PageAnswerScalarWhereInput[]
    id?: StringFilter<"PageAnswer"> | string
    pageId?: StringFilter<"PageAnswer"> | string
    questionNumber?: StringFilter<"PageAnswer"> | string
    studentAnswer?: StringNullableFilter<"PageAnswer"> | string | null
    correct?: BoolFilter<"PageAnswer"> | boolean
    score?: StringFilter<"PageAnswer"> | string
    remarks?: StringFilter<"PageAnswer"> | string
    matched?: BoolFilter<"PageAnswer"> | boolean
    matchConfidence?: FloatNullableFilter<"PageAnswer"> | number | null
    positionX?: FloatNullableFilter<"PageAnswer"> | number | null
    positionY?: FloatNullableFilter<"PageAnswer"> | number | null
    continuedFrom?: IntNullableFilter<"PageAnswer"> | number | null
    continuedTo?: IntNullableFilter<"PageAnswer"> | number | null
    createdAt?: DateTimeFilter<"PageAnswer"> | Date | string
  }

  export type GradingPageCreateWithoutPageAnswersInput = {
    id?: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    grading: GradingCreateNestedOneWithoutPagesInput
  }

  export type GradingPageUncheckedCreateWithoutPageAnswersInput = {
    id?: string
    gradingId: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
  }

  export type GradingPageCreateOrConnectWithoutPageAnswersInput = {
    where: GradingPageWhereUniqueInput
    create: XOR<GradingPageCreateWithoutPageAnswersInput, GradingPageUncheckedCreateWithoutPageAnswersInput>
  }

  export type GradingPageUpsertWithoutPageAnswersInput = {
    update: XOR<GradingPageUpdateWithoutPageAnswersInput, GradingPageUncheckedUpdateWithoutPageAnswersInput>
    create: XOR<GradingPageCreateWithoutPageAnswersInput, GradingPageUncheckedCreateWithoutPageAnswersInput>
    where?: GradingPageWhereInput
  }

  export type GradingPageUpdateToOneWithWhereWithoutPageAnswersInput = {
    where?: GradingPageWhereInput
    data: XOR<GradingPageUpdateWithoutPageAnswersInput, GradingPageUncheckedUpdateWithoutPageAnswersInput>
  }

  export type GradingPageUpdateWithoutPageAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grading?: GradingUpdateOneRequiredWithoutPagesNestedInput
  }

  export type GradingPageUncheckedUpdateWithoutPageAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradingId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingCreateWithoutAnswersInput = {
    id?: string
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGradingsInput
    questionPaper?: QuestionPaperCreateNestedOneWithoutGradingsInput
    pages?: GradingPageCreateNestedManyWithoutGradingInput
  }

  export type GradingUncheckedCreateWithoutAnswersInput = {
    id?: string
    userId?: string | null
    questionPaperId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
    pages?: GradingPageUncheckedCreateNestedManyWithoutGradingInput
  }

  export type GradingCreateOrConnectWithoutAnswersInput = {
    where: GradingWhereUniqueInput
    create: XOR<GradingCreateWithoutAnswersInput, GradingUncheckedCreateWithoutAnswersInput>
  }

  export type GradingUpsertWithoutAnswersInput = {
    update: XOR<GradingUpdateWithoutAnswersInput, GradingUncheckedUpdateWithoutAnswersInput>
    create: XOR<GradingCreateWithoutAnswersInput, GradingUncheckedCreateWithoutAnswersInput>
    where?: GradingWhereInput
  }

  export type GradingUpdateToOneWithWhereWithoutAnswersInput = {
    where?: GradingWhereInput
    data: XOR<GradingUpdateWithoutAnswersInput, GradingUncheckedUpdateWithoutAnswersInput>
  }

  export type GradingUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGradingsNestedInput
    questionPaper?: QuestionPaperUpdateOneWithoutGradingsNestedInput
    pages?: GradingPageUpdateManyWithoutGradingNestedInput
  }

  export type GradingUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionPaperId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: GradingPageUncheckedUpdateManyWithoutGradingNestedInput
  }

  export type UserCreateWithoutDoubtsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoubtsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoubtsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoubtsInput, UserUncheckedCreateWithoutDoubtsInput>
  }

  export type DoubtMessageCreateWithoutDoubtInput = {
    id?: string
    role: string
    content: string
    audioUrl?: string | null
    createdAt?: Date | string
  }

  export type DoubtMessageUncheckedCreateWithoutDoubtInput = {
    id?: string
    role: string
    content: string
    audioUrl?: string | null
    createdAt?: Date | string
  }

  export type DoubtMessageCreateOrConnectWithoutDoubtInput = {
    where: DoubtMessageWhereUniqueInput
    create: XOR<DoubtMessageCreateWithoutDoubtInput, DoubtMessageUncheckedCreateWithoutDoubtInput>
  }

  export type DoubtMessageCreateManyDoubtInputEnvelope = {
    data: DoubtMessageCreateManyDoubtInput | DoubtMessageCreateManyDoubtInput[]
    skipDuplicates?: boolean
  }

  export type WorksheetCreateWithoutDoubtsInput = {
    id?: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWorksheetsInput
    questions?: WorksheetQuestionCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetUncheckedCreateWithoutDoubtsInput = {
    id?: string
    userId?: string | null
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: WorksheetQuestionUncheckedCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetCreateOrConnectWithoutDoubtsInput = {
    where: WorksheetWhereUniqueInput
    create: XOR<WorksheetCreateWithoutDoubtsInput, WorksheetUncheckedCreateWithoutDoubtsInput>
  }

  export type WorksheetQuestionCreateWithoutDoubtInput = {
    id?: string
    questionNumber: number
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
    worksheet: WorksheetCreateNestedOneWithoutQuestionsInput
  }

  export type WorksheetQuestionUncheckedCreateWithoutDoubtInput = {
    id?: string
    worksheetId: string
    questionNumber: number
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
  }

  export type WorksheetQuestionCreateOrConnectWithoutDoubtInput = {
    where: WorksheetQuestionWhereUniqueInput
    create: XOR<WorksheetQuestionCreateWithoutDoubtInput, WorksheetQuestionUncheckedCreateWithoutDoubtInput>
  }

  export type WorksheetQuestionCreateManyDoubtInputEnvelope = {
    data: WorksheetQuestionCreateManyDoubtInput | WorksheetQuestionCreateManyDoubtInput[]
    skipDuplicates?: boolean
  }

  export type DoubtRatingCreateWithoutDoubtInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoubtRatingsInput
  }

  export type DoubtRatingUncheckedCreateWithoutDoubtInput = {
    id?: string
    userId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoubtRatingCreateOrConnectWithoutDoubtInput = {
    where: DoubtRatingWhereUniqueInput
    create: XOR<DoubtRatingCreateWithoutDoubtInput, DoubtRatingUncheckedCreateWithoutDoubtInput>
  }

  export type UserUpsertWithoutDoubtsInput = {
    update: XOR<UserUpdateWithoutDoubtsInput, UserUncheckedUpdateWithoutDoubtsInput>
    create: XOR<UserCreateWithoutDoubtsInput, UserUncheckedCreateWithoutDoubtsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoubtsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoubtsInput, UserUncheckedUpdateWithoutDoubtsInput>
  }

  export type UserUpdateWithoutDoubtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoubtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DoubtMessageUpsertWithWhereUniqueWithoutDoubtInput = {
    where: DoubtMessageWhereUniqueInput
    update: XOR<DoubtMessageUpdateWithoutDoubtInput, DoubtMessageUncheckedUpdateWithoutDoubtInput>
    create: XOR<DoubtMessageCreateWithoutDoubtInput, DoubtMessageUncheckedCreateWithoutDoubtInput>
  }

  export type DoubtMessageUpdateWithWhereUniqueWithoutDoubtInput = {
    where: DoubtMessageWhereUniqueInput
    data: XOR<DoubtMessageUpdateWithoutDoubtInput, DoubtMessageUncheckedUpdateWithoutDoubtInput>
  }

  export type DoubtMessageUpdateManyWithWhereWithoutDoubtInput = {
    where: DoubtMessageScalarWhereInput
    data: XOR<DoubtMessageUpdateManyMutationInput, DoubtMessageUncheckedUpdateManyWithoutDoubtInput>
  }

  export type DoubtMessageScalarWhereInput = {
    AND?: DoubtMessageScalarWhereInput | DoubtMessageScalarWhereInput[]
    OR?: DoubtMessageScalarWhereInput[]
    NOT?: DoubtMessageScalarWhereInput | DoubtMessageScalarWhereInput[]
    id?: StringFilter<"DoubtMessage"> | string
    doubtId?: StringFilter<"DoubtMessage"> | string
    role?: StringFilter<"DoubtMessage"> | string
    content?: StringFilter<"DoubtMessage"> | string
    audioUrl?: StringNullableFilter<"DoubtMessage"> | string | null
    createdAt?: DateTimeFilter<"DoubtMessage"> | Date | string
  }

  export type WorksheetUpsertWithoutDoubtsInput = {
    update: XOR<WorksheetUpdateWithoutDoubtsInput, WorksheetUncheckedUpdateWithoutDoubtsInput>
    create: XOR<WorksheetCreateWithoutDoubtsInput, WorksheetUncheckedCreateWithoutDoubtsInput>
    where?: WorksheetWhereInput
  }

  export type WorksheetUpdateToOneWithWhereWithoutDoubtsInput = {
    where?: WorksheetWhereInput
    data: XOR<WorksheetUpdateWithoutDoubtsInput, WorksheetUncheckedUpdateWithoutDoubtsInput>
  }

  export type WorksheetUpdateWithoutDoubtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWorksheetsNestedInput
    questions?: WorksheetQuestionUpdateManyWithoutWorksheetNestedInput
  }

  export type WorksheetUncheckedUpdateWithoutDoubtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: WorksheetQuestionUncheckedUpdateManyWithoutWorksheetNestedInput
  }

  export type WorksheetQuestionUpsertWithWhereUniqueWithoutDoubtInput = {
    where: WorksheetQuestionWhereUniqueInput
    update: XOR<WorksheetQuestionUpdateWithoutDoubtInput, WorksheetQuestionUncheckedUpdateWithoutDoubtInput>
    create: XOR<WorksheetQuestionCreateWithoutDoubtInput, WorksheetQuestionUncheckedCreateWithoutDoubtInput>
  }

  export type WorksheetQuestionUpdateWithWhereUniqueWithoutDoubtInput = {
    where: WorksheetQuestionWhereUniqueInput
    data: XOR<WorksheetQuestionUpdateWithoutDoubtInput, WorksheetQuestionUncheckedUpdateWithoutDoubtInput>
  }

  export type WorksheetQuestionUpdateManyWithWhereWithoutDoubtInput = {
    where: WorksheetQuestionScalarWhereInput
    data: XOR<WorksheetQuestionUpdateManyMutationInput, WorksheetQuestionUncheckedUpdateManyWithoutDoubtInput>
  }

  export type WorksheetQuestionScalarWhereInput = {
    AND?: WorksheetQuestionScalarWhereInput | WorksheetQuestionScalarWhereInput[]
    OR?: WorksheetQuestionScalarWhereInput[]
    NOT?: WorksheetQuestionScalarWhereInput | WorksheetQuestionScalarWhereInput[]
    id?: StringFilter<"WorksheetQuestion"> | string
    worksheetId?: StringFilter<"WorksheetQuestion"> | string
    questionNumber?: IntFilter<"WorksheetQuestion"> | number
    doubtId?: StringNullableFilter<"WorksheetQuestion"> | string | null
    status?: StringFilter<"WorksheetQuestion"> | string
    cachedExplanation?: StringNullableFilter<"WorksheetQuestion"> | string | null
    createdAt?: DateTimeFilter<"WorksheetQuestion"> | Date | string
  }

  export type DoubtRatingUpsertWithoutDoubtInput = {
    update: XOR<DoubtRatingUpdateWithoutDoubtInput, DoubtRatingUncheckedUpdateWithoutDoubtInput>
    create: XOR<DoubtRatingCreateWithoutDoubtInput, DoubtRatingUncheckedCreateWithoutDoubtInput>
    where?: DoubtRatingWhereInput
  }

  export type DoubtRatingUpdateToOneWithWhereWithoutDoubtInput = {
    where?: DoubtRatingWhereInput
    data: XOR<DoubtRatingUpdateWithoutDoubtInput, DoubtRatingUncheckedUpdateWithoutDoubtInput>
  }

  export type DoubtRatingUpdateWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoubtRatingsNestedInput
  }

  export type DoubtRatingUncheckedUpdateWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtCreateWithoutMessagesInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDoubtsInput
    worksheet?: WorksheetCreateNestedOneWithoutDoubtsInput
    worksheetQuestions?: WorksheetQuestionCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingCreateNestedOneWithoutDoubtInput
  }

  export type DoubtUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId?: string | null
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    worksheetId?: string | null
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    worksheetQuestions?: WorksheetQuestionUncheckedCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingUncheckedCreateNestedOneWithoutDoubtInput
  }

  export type DoubtCreateOrConnectWithoutMessagesInput = {
    where: DoubtWhereUniqueInput
    create: XOR<DoubtCreateWithoutMessagesInput, DoubtUncheckedCreateWithoutMessagesInput>
  }

  export type DoubtUpsertWithoutMessagesInput = {
    update: XOR<DoubtUpdateWithoutMessagesInput, DoubtUncheckedUpdateWithoutMessagesInput>
    create: XOR<DoubtCreateWithoutMessagesInput, DoubtUncheckedCreateWithoutMessagesInput>
    where?: DoubtWhereInput
  }

  export type DoubtUpdateToOneWithWhereWithoutMessagesInput = {
    where?: DoubtWhereInput
    data: XOR<DoubtUpdateWithoutMessagesInput, DoubtUncheckedUpdateWithoutMessagesInput>
  }

  export type DoubtUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDoubtsNestedInput
    worksheet?: WorksheetUpdateOneWithoutDoubtsNestedInput
    worksheetQuestions?: WorksheetQuestionUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    worksheetId?: NullableStringFieldUpdateOperationsInput | string | null
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    worksheetQuestions?: WorksheetQuestionUncheckedUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUncheckedUpdateOneWithoutDoubtNestedInput
  }

  export type UserCreateWithoutWorksheetsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    doubts?: DoubtCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorksheetsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorksheetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorksheetsInput, UserUncheckedCreateWithoutWorksheetsInput>
  }

  export type WorksheetQuestionCreateWithoutWorksheetInput = {
    id?: string
    questionNumber: number
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
    doubt?: DoubtCreateNestedOneWithoutWorksheetQuestionsInput
  }

  export type WorksheetQuestionUncheckedCreateWithoutWorksheetInput = {
    id?: string
    questionNumber: number
    doubtId?: string | null
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
  }

  export type WorksheetQuestionCreateOrConnectWithoutWorksheetInput = {
    where: WorksheetQuestionWhereUniqueInput
    create: XOR<WorksheetQuestionCreateWithoutWorksheetInput, WorksheetQuestionUncheckedCreateWithoutWorksheetInput>
  }

  export type WorksheetQuestionCreateManyWorksheetInputEnvelope = {
    data: WorksheetQuestionCreateManyWorksheetInput | WorksheetQuestionCreateManyWorksheetInput[]
    skipDuplicates?: boolean
  }

  export type DoubtCreateWithoutWorksheetInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDoubtsInput
    messages?: DoubtMessageCreateNestedManyWithoutDoubtInput
    worksheetQuestions?: WorksheetQuestionCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingCreateNestedOneWithoutDoubtInput
  }

  export type DoubtUncheckedCreateWithoutWorksheetInput = {
    id?: string
    userId?: string | null
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DoubtMessageUncheckedCreateNestedManyWithoutDoubtInput
    worksheetQuestions?: WorksheetQuestionUncheckedCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingUncheckedCreateNestedOneWithoutDoubtInput
  }

  export type DoubtCreateOrConnectWithoutWorksheetInput = {
    where: DoubtWhereUniqueInput
    create: XOR<DoubtCreateWithoutWorksheetInput, DoubtUncheckedCreateWithoutWorksheetInput>
  }

  export type DoubtCreateManyWorksheetInputEnvelope = {
    data: DoubtCreateManyWorksheetInput | DoubtCreateManyWorksheetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorksheetsInput = {
    update: XOR<UserUpdateWithoutWorksheetsInput, UserUncheckedUpdateWithoutWorksheetsInput>
    create: XOR<UserCreateWithoutWorksheetsInput, UserUncheckedCreateWithoutWorksheetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorksheetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorksheetsInput, UserUncheckedUpdateWithoutWorksheetsInput>
  }

  export type UserUpdateWithoutWorksheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorksheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WorksheetQuestionUpsertWithWhereUniqueWithoutWorksheetInput = {
    where: WorksheetQuestionWhereUniqueInput
    update: XOR<WorksheetQuestionUpdateWithoutWorksheetInput, WorksheetQuestionUncheckedUpdateWithoutWorksheetInput>
    create: XOR<WorksheetQuestionCreateWithoutWorksheetInput, WorksheetQuestionUncheckedCreateWithoutWorksheetInput>
  }

  export type WorksheetQuestionUpdateWithWhereUniqueWithoutWorksheetInput = {
    where: WorksheetQuestionWhereUniqueInput
    data: XOR<WorksheetQuestionUpdateWithoutWorksheetInput, WorksheetQuestionUncheckedUpdateWithoutWorksheetInput>
  }

  export type WorksheetQuestionUpdateManyWithWhereWithoutWorksheetInput = {
    where: WorksheetQuestionScalarWhereInput
    data: XOR<WorksheetQuestionUpdateManyMutationInput, WorksheetQuestionUncheckedUpdateManyWithoutWorksheetInput>
  }

  export type DoubtUpsertWithWhereUniqueWithoutWorksheetInput = {
    where: DoubtWhereUniqueInput
    update: XOR<DoubtUpdateWithoutWorksheetInput, DoubtUncheckedUpdateWithoutWorksheetInput>
    create: XOR<DoubtCreateWithoutWorksheetInput, DoubtUncheckedCreateWithoutWorksheetInput>
  }

  export type DoubtUpdateWithWhereUniqueWithoutWorksheetInput = {
    where: DoubtWhereUniqueInput
    data: XOR<DoubtUpdateWithoutWorksheetInput, DoubtUncheckedUpdateWithoutWorksheetInput>
  }

  export type DoubtUpdateManyWithWhereWithoutWorksheetInput = {
    where: DoubtScalarWhereInput
    data: XOR<DoubtUpdateManyMutationInput, DoubtUncheckedUpdateManyWithoutWorksheetInput>
  }

  export type WorksheetCreateWithoutQuestionsInput = {
    id?: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWorksheetsInput
    doubts?: DoubtCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetUncheckedCreateWithoutQuestionsInput = {
    id?: string
    userId?: string | null
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doubts?: DoubtUncheckedCreateNestedManyWithoutWorksheetInput
  }

  export type WorksheetCreateOrConnectWithoutQuestionsInput = {
    where: WorksheetWhereUniqueInput
    create: XOR<WorksheetCreateWithoutQuestionsInput, WorksheetUncheckedCreateWithoutQuestionsInput>
  }

  export type DoubtCreateWithoutWorksheetQuestionsInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDoubtsInput
    messages?: DoubtMessageCreateNestedManyWithoutDoubtInput
    worksheet?: WorksheetCreateNestedOneWithoutDoubtsInput
    rating?: DoubtRatingCreateNestedOneWithoutDoubtInput
  }

  export type DoubtUncheckedCreateWithoutWorksheetQuestionsInput = {
    id?: string
    userId?: string | null
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    worksheetId?: string | null
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DoubtMessageUncheckedCreateNestedManyWithoutDoubtInput
    rating?: DoubtRatingUncheckedCreateNestedOneWithoutDoubtInput
  }

  export type DoubtCreateOrConnectWithoutWorksheetQuestionsInput = {
    where: DoubtWhereUniqueInput
    create: XOR<DoubtCreateWithoutWorksheetQuestionsInput, DoubtUncheckedCreateWithoutWorksheetQuestionsInput>
  }

  export type WorksheetUpsertWithoutQuestionsInput = {
    update: XOR<WorksheetUpdateWithoutQuestionsInput, WorksheetUncheckedUpdateWithoutQuestionsInput>
    create: XOR<WorksheetCreateWithoutQuestionsInput, WorksheetUncheckedCreateWithoutQuestionsInput>
    where?: WorksheetWhereInput
  }

  export type WorksheetUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: WorksheetWhereInput
    data: XOR<WorksheetUpdateWithoutQuestionsInput, WorksheetUncheckedUpdateWithoutQuestionsInput>
  }

  export type WorksheetUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWorksheetsNestedInput
    doubts?: DoubtUpdateManyWithoutWorksheetNestedInput
  }

  export type WorksheetUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doubts?: DoubtUncheckedUpdateManyWithoutWorksheetNestedInput
  }

  export type DoubtUpsertWithoutWorksheetQuestionsInput = {
    update: XOR<DoubtUpdateWithoutWorksheetQuestionsInput, DoubtUncheckedUpdateWithoutWorksheetQuestionsInput>
    create: XOR<DoubtCreateWithoutWorksheetQuestionsInput, DoubtUncheckedCreateWithoutWorksheetQuestionsInput>
    where?: DoubtWhereInput
  }

  export type DoubtUpdateToOneWithWhereWithoutWorksheetQuestionsInput = {
    where?: DoubtWhereInput
    data: XOR<DoubtUpdateWithoutWorksheetQuestionsInput, DoubtUncheckedUpdateWithoutWorksheetQuestionsInput>
  }

  export type DoubtUpdateWithoutWorksheetQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDoubtsNestedInput
    messages?: DoubtMessageUpdateManyWithoutDoubtNestedInput
    worksheet?: WorksheetUpdateOneWithoutDoubtsNestedInput
    rating?: DoubtRatingUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateWithoutWorksheetQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    worksheetId?: NullableStringFieldUpdateOperationsInput | string | null
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DoubtMessageUncheckedUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUncheckedUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtCreateWithoutRatingInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDoubtsInput
    messages?: DoubtMessageCreateNestedManyWithoutDoubtInput
    worksheet?: WorksheetCreateNestedOneWithoutDoubtsInput
    worksheetQuestions?: WorksheetQuestionCreateNestedManyWithoutDoubtInput
  }

  export type DoubtUncheckedCreateWithoutRatingInput = {
    id?: string
    userId?: string | null
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    worksheetId?: string | null
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DoubtMessageUncheckedCreateNestedManyWithoutDoubtInput
    worksheetQuestions?: WorksheetQuestionUncheckedCreateNestedManyWithoutDoubtInput
  }

  export type DoubtCreateOrConnectWithoutRatingInput = {
    where: DoubtWhereUniqueInput
    create: XOR<DoubtCreateWithoutRatingInput, DoubtUncheckedCreateWithoutRatingInput>
  }

  export type UserCreateWithoutDoubtRatingsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    doubts?: DoubtCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoubtRatingsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoubtRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoubtRatingsInput, UserUncheckedCreateWithoutDoubtRatingsInput>
  }

  export type DoubtUpsertWithoutRatingInput = {
    update: XOR<DoubtUpdateWithoutRatingInput, DoubtUncheckedUpdateWithoutRatingInput>
    create: XOR<DoubtCreateWithoutRatingInput, DoubtUncheckedCreateWithoutRatingInput>
    where?: DoubtWhereInput
  }

  export type DoubtUpdateToOneWithWhereWithoutRatingInput = {
    where?: DoubtWhereInput
    data: XOR<DoubtUpdateWithoutRatingInput, DoubtUncheckedUpdateWithoutRatingInput>
  }

  export type DoubtUpdateWithoutRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDoubtsNestedInput
    messages?: DoubtMessageUpdateManyWithoutDoubtNestedInput
    worksheet?: WorksheetUpdateOneWithoutDoubtsNestedInput
    worksheetQuestions?: WorksheetQuestionUpdateManyWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateWithoutRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    worksheetId?: NullableStringFieldUpdateOperationsInput | string | null
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DoubtMessageUncheckedUpdateManyWithoutDoubtNestedInput
    worksheetQuestions?: WorksheetQuestionUncheckedUpdateManyWithoutDoubtNestedInput
  }

  export type UserUpsertWithoutDoubtRatingsInput = {
    update: XOR<UserUpdateWithoutDoubtRatingsInput, UserUncheckedUpdateWithoutDoubtRatingsInput>
    create: XOR<UserCreateWithoutDoubtRatingsInput, UserUncheckedCreateWithoutDoubtRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoubtRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoubtRatingsInput, UserUncheckedUpdateWithoutDoubtRatingsInput>
  }

  export type UserUpdateWithoutDoubtRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoubtRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutRevisionSessionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    doubts?: DoubtCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRevisionSessionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRevisionSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRevisionSessionsInput, UserUncheckedCreateWithoutRevisionSessionsInput>
  }

  export type UserUpsertWithoutRevisionSessionsInput = {
    update: XOR<UserUpdateWithoutRevisionSessionsInput, UserUncheckedUpdateWithoutRevisionSessionsInput>
    create: XOR<UserCreateWithoutRevisionSessionsInput, UserUncheckedCreateWithoutRevisionSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRevisionSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRevisionSessionsInput, UserUncheckedUpdateWithoutRevisionSessionsInput>
  }

  export type UserUpdateWithoutRevisionSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRevisionSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutWeakTopicsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    doubts?: DoubtCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWeakTopicsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWeakTopicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWeakTopicsInput, UserUncheckedCreateWithoutWeakTopicsInput>
  }

  export type UserUpsertWithoutWeakTopicsInput = {
    update: XOR<UserUpdateWithoutWeakTopicsInput, UserUncheckedUpdateWithoutWeakTopicsInput>
    create: XOR<UserCreateWithoutWeakTopicsInput, UserUncheckedCreateWithoutWeakTopicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWeakTopicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWeakTopicsInput, UserUncheckedUpdateWithoutWeakTopicsInput>
  }

  export type UserUpdateWithoutWeakTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWeakTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutGroupStudySessionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    doubts?: DoubtCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupStudySessionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupStudySessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupStudySessionsInput, UserUncheckedCreateWithoutGroupStudySessionsInput>
  }

  export type UserUpsertWithoutGroupStudySessionsInput = {
    update: XOR<UserUpdateWithoutGroupStudySessionsInput, UserUncheckedUpdateWithoutGroupStudySessionsInput>
    create: XOR<UserCreateWithoutGroupStudySessionsInput, UserUncheckedCreateWithoutGroupStudySessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupStudySessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupStudySessionsInput, UserUncheckedUpdateWithoutGroupStudySessionsInput>
  }

  export type UserUpdateWithoutGroupStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    handlingSkillProgress?: HandlingSkillProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutHandlingSkillProgressInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingCreateNestedManyWithoutUserInput
    doubts?: DoubtCreateNestedManyWithoutUserInput
    worksheets?: WorksheetCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHandlingSkillProgressInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    grade?: string | null
    school?: string | null
    languagePreference?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    gradings?: GradingUncheckedCreateNestedManyWithoutUserInput
    doubts?: DoubtUncheckedCreateNestedManyWithoutUserInput
    worksheets?: WorksheetUncheckedCreateNestedManyWithoutUserInput
    doubtRatings?: DoubtRatingUncheckedCreateNestedManyWithoutUserInput
    revisionSessions?: RevisionSessionUncheckedCreateNestedManyWithoutUserInput
    weakTopics?: WeakTopicUncheckedCreateNestedManyWithoutUserInput
    groupStudySessions?: GroupStudySessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHandlingSkillProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHandlingSkillProgressInput, UserUncheckedCreateWithoutHandlingSkillProgressInput>
  }

  export type UserUpsertWithoutHandlingSkillProgressInput = {
    update: XOR<UserUpdateWithoutHandlingSkillProgressInput, UserUncheckedUpdateWithoutHandlingSkillProgressInput>
    create: XOR<UserCreateWithoutHandlingSkillProgressInput, UserUncheckedCreateWithoutHandlingSkillProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHandlingSkillProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHandlingSkillProgressInput, UserUncheckedUpdateWithoutHandlingSkillProgressInput>
  }

  export type UserUpdateWithoutHandlingSkillProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUpdateManyWithoutUserNestedInput
    doubts?: DoubtUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHandlingSkillProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradings?: GradingUncheckedUpdateManyWithoutUserNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutUserNestedInput
    worksheets?: WorksheetUncheckedUpdateManyWithoutUserNestedInput
    doubtRatings?: DoubtRatingUncheckedUpdateManyWithoutUserNestedInput
    revisionSessions?: RevisionSessionUncheckedUpdateManyWithoutUserNestedInput
    weakTopics?: WeakTopicUncheckedUpdateManyWithoutUserNestedInput
    groupStudySessions?: GroupStudySessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuestionCreateManyQuestionPaperInput = {
    id?: string
    questionNumber: string
    questionText: string
    maxScore?: number | null
    topic?: string | null
    concept?: string | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type GradingCreateManyQuestionPaperInput = {
    id?: string
    userId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
  }

  export type QuestionUpdateWithoutQuestionPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateWithoutQuestionPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyWithoutQuestionPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    maxScore?: NullableFloatFieldUpdateOperationsInput | number | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingUpdateWithoutQuestionPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGradingsNestedInput
    pages?: GradingPageUpdateManyWithoutGradingNestedInput
    answers?: AnswerUpdateManyWithoutGradingNestedInput
  }

  export type GradingUncheckedUpdateWithoutQuestionPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: GradingPageUncheckedUpdateManyWithoutGradingNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutGradingNestedInput
  }

  export type GradingUncheckedUpdateManyWithoutQuestionPaperInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingCreateManyUserInput = {
    id?: string
    questionPaperId?: string | null
    answerSheetUrl: string
    totalPages?: number
    subject: string
    language: string
    gradeLevel: string
    totalScore: string
    feedback: string
    matchingMode?: string | null
    totalQuestions?: number | null
    answeredQuestions?: number | null
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
  }

  export type DoubtCreateManyUserInput = {
    id?: string
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    worksheetId?: string | null
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorksheetCreateManyUserInput = {
    id?: string
    imageUrl: string
    imageHash: string
    totalQuestions: number
    currentQuestion?: number
    sessionId: string
    expiresAt: Date | string
    title?: string | null
    subject?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoubtRatingCreateManyUserInput = {
    id?: string
    doubtId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevisionSessionCreateManyUserInput = {
    id?: string
    topic: string
    subject: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number | null
    weakAreas?: string | null
    phasesCompleted?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeakTopicCreateManyUserInput = {
    id?: string
    topic: string
    subject: string
    occurrences?: number
    lastSeen?: Date | string
    improved?: boolean
    improvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupStudySessionCreateManyUserInput = {
    id?: string
    topic: string
    subject: string
    question?: string | null
    classmate1Name: string
    classmate2Name: string
    studentAnswer: string
    classmate1Question?: string | null
    classmate2Counter?: string | null
    classmate1Response?: string | null
    classmate2Response?: string | null
    handlingScore?: number | null
    strengths?: string | null
    improvements?: string | null
    challengesCount?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionPaper?: QuestionPaperUpdateOneWithoutGradingsNestedInput
    pages?: GradingPageUpdateManyWithoutGradingNestedInput
    answers?: AnswerUpdateManyWithoutGradingNestedInput
  }

  export type GradingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionPaperId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: GradingPageUncheckedUpdateManyWithoutGradingNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutGradingNestedInput
  }

  export type GradingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionPaperId?: NullableStringFieldUpdateOperationsInput | string | null
    answerSheetUrl?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    gradeLevel?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    matchingMode?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    answeredQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DoubtMessageUpdateManyWithoutDoubtNestedInput
    worksheet?: WorksheetUpdateOneWithoutDoubtsNestedInput
    worksheetQuestions?: WorksheetQuestionUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    worksheetId?: NullableStringFieldUpdateOperationsInput | string | null
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DoubtMessageUncheckedUpdateManyWithoutDoubtNestedInput
    worksheetQuestions?: WorksheetQuestionUncheckedUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUncheckedUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    worksheetId?: NullableStringFieldUpdateOperationsInput | string | null
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: WorksheetQuestionUpdateManyWithoutWorksheetNestedInput
    doubts?: DoubtUpdateManyWithoutWorksheetNestedInput
  }

  export type WorksheetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: WorksheetQuestionUncheckedUpdateManyWithoutWorksheetNestedInput
    doubts?: DoubtUncheckedUpdateManyWithoutWorksheetNestedInput
  }

  export type WorksheetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    imageHash?: StringFieldUpdateOperationsInput | string
    totalQuestions?: IntFieldUpdateOperationsInput | number
    currentQuestion?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtRatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doubt?: DoubtUpdateOneRequiredWithoutRatingNestedInput
  }

  export type DoubtRatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    doubtId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtRatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    doubtId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevisionSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    weakAreas?: NullableStringFieldUpdateOperationsInput | string | null
    phasesCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevisionSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    weakAreas?: NullableStringFieldUpdateOperationsInput | string | null
    phasesCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevisionSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    weakAreas?: NullableStringFieldUpdateOperationsInput | string | null
    phasesCompleted?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeakTopicUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    occurrences?: IntFieldUpdateOperationsInput | number
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    improved?: BoolFieldUpdateOperationsInput | boolean
    improvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeakTopicUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    occurrences?: IntFieldUpdateOperationsInput | number
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    improved?: BoolFieldUpdateOperationsInput | boolean
    improvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeakTopicUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    occurrences?: IntFieldUpdateOperationsInput | number
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    improved?: BoolFieldUpdateOperationsInput | boolean
    improvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupStudySessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Name?: StringFieldUpdateOperationsInput | string
    classmate2Name?: StringFieldUpdateOperationsInput | string
    studentAnswer?: StringFieldUpdateOperationsInput | string
    classmate1Question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Counter?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Response?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Response?: NullableStringFieldUpdateOperationsInput | string | null
    handlingScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    challengesCount?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupStudySessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Name?: StringFieldUpdateOperationsInput | string
    classmate2Name?: StringFieldUpdateOperationsInput | string
    studentAnswer?: StringFieldUpdateOperationsInput | string
    classmate1Question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Counter?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Response?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Response?: NullableStringFieldUpdateOperationsInput | string | null
    handlingScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    challengesCount?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupStudySessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Name?: StringFieldUpdateOperationsInput | string
    classmate2Name?: StringFieldUpdateOperationsInput | string
    studentAnswer?: StringFieldUpdateOperationsInput | string
    classmate1Question?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Counter?: NullableStringFieldUpdateOperationsInput | string | null
    classmate1Response?: NullableStringFieldUpdateOperationsInput | string | null
    classmate2Response?: NullableStringFieldUpdateOperationsInput | string | null
    handlingScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    challengesCount?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradingPageCreateManyGradingInput = {
    id?: string
    pageNumber: number
    imageUrl: string
    annotations?: string | null
    imageDimensions?: string | null
    createdAt?: Date | string
  }

  export type AnswerCreateManyGradingInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    createdAt?: Date | string
  }

  export type GradingPageUpdateWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pageAnswers?: PageAnswerUpdateManyWithoutPageNestedInput
  }

  export type GradingPageUncheckedUpdateWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pageAnswers?: PageAnswerUncheckedUpdateManyWithoutPageNestedInput
  }

  export type GradingPageUncheckedUpdateManyWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUpdateWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateManyWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageAnswerCreateManyPageInput = {
    id?: string
    questionNumber: string
    studentAnswer?: string | null
    correct: boolean
    score: string
    remarks: string
    matched?: boolean
    matchConfidence?: number | null
    positionX?: number | null
    positionY?: number | null
    continuedFrom?: number | null
    continuedTo?: number | null
    createdAt?: Date | string
  }

  export type PageAnswerUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    continuedFrom?: NullableIntFieldUpdateOperationsInput | number | null
    continuedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageAnswerUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    continuedFrom?: NullableIntFieldUpdateOperationsInput | number | null
    continuedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageAnswerUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: StringFieldUpdateOperationsInput | string
    studentAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    score?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    continuedFrom?: NullableIntFieldUpdateOperationsInput | number | null
    continuedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtMessageCreateManyDoubtInput = {
    id?: string
    role: string
    content: string
    audioUrl?: string | null
    createdAt?: Date | string
  }

  export type WorksheetQuestionCreateManyDoubtInput = {
    id?: string
    worksheetId: string
    questionNumber: number
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
  }

  export type DoubtMessageUpdateWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtMessageUncheckedUpdateWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtMessageUncheckedUpdateManyWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetQuestionUpdateWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    worksheet?: WorksheetUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type WorksheetQuestionUncheckedUpdateWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    worksheetId?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetQuestionUncheckedUpdateManyWithoutDoubtInput = {
    id?: StringFieldUpdateOperationsInput | string
    worksheetId?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetQuestionCreateManyWorksheetInput = {
    id?: string
    questionNumber: number
    doubtId?: string | null
    status?: string
    cachedExplanation?: string | null
    createdAt?: Date | string
  }

  export type DoubtCreateManyWorksheetInput = {
    id?: string
    userId?: string | null
    questionImage?: string | null
    questionText: string
    subject: string
    language: string
    explanation: string
    annotations?: string | null
    imageDimensions?: string | null
    conversationId: string
    questionNumber?: number | null
    isInRevision?: boolean
    addedToRevisionAt?: Date | string | null
    isFavorite?: boolean
    messageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorksheetQuestionUpdateWithoutWorksheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doubt?: DoubtUpdateOneWithoutWorksheetQuestionsNestedInput
  }

  export type WorksheetQuestionUncheckedUpdateWithoutWorksheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    doubtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorksheetQuestionUncheckedUpdateManyWithoutWorksheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionNumber?: IntFieldUpdateOperationsInput | number
    doubtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    cachedExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoubtUpdateWithoutWorksheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDoubtsNestedInput
    messages?: DoubtMessageUpdateManyWithoutDoubtNestedInput
    worksheetQuestions?: WorksheetQuestionUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateWithoutWorksheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DoubtMessageUncheckedUpdateManyWithoutDoubtNestedInput
    worksheetQuestions?: WorksheetQuestionUncheckedUpdateManyWithoutDoubtNestedInput
    rating?: DoubtRatingUncheckedUpdateOneWithoutDoubtNestedInput
  }

  export type DoubtUncheckedUpdateManyWithoutWorksheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questionImage?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    annotations?: NullableStringFieldUpdateOperationsInput | string | null
    imageDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    questionNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isInRevision?: BoolFieldUpdateOperationsInput | boolean
    addedToRevisionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    messageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use QuestionPaperCountOutputTypeDefaultArgs instead
     */
    export type QuestionPaperCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionPaperCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradingCountOutputTypeDefaultArgs instead
     */
    export type GradingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradingPageCountOutputTypeDefaultArgs instead
     */
    export type GradingPageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradingPageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoubtCountOutputTypeDefaultArgs instead
     */
    export type DoubtCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoubtCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorksheetCountOutputTypeDefaultArgs instead
     */
    export type WorksheetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorksheetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionPaperDefaultArgs instead
     */
    export type QuestionPaperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionPaperDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionDefaultArgs instead
     */
    export type QuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradingDefaultArgs instead
     */
    export type GradingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradingPageDefaultArgs instead
     */
    export type GradingPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradingPageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageAnswerDefaultArgs instead
     */
    export type PageAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PageAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnswerDefaultArgs instead
     */
    export type AnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoubtDefaultArgs instead
     */
    export type DoubtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoubtDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoubtMessageDefaultArgs instead
     */
    export type DoubtMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoubtMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorksheetDefaultArgs instead
     */
    export type WorksheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorksheetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorksheetQuestionDefaultArgs instead
     */
    export type WorksheetQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorksheetQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoubtRatingDefaultArgs instead
     */
    export type DoubtRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoubtRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RevisionSessionDefaultArgs instead
     */
    export type RevisionSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RevisionSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeakTopicDefaultArgs instead
     */
    export type WeakTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeakTopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupStudySessionDefaultArgs instead
     */
    export type GroupStudySessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupStudySessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HandlingSkillProgressDefaultArgs instead
     */
    export type HandlingSkillProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HandlingSkillProgressDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}